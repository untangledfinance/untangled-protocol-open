digraph "" {
AccessControlEnumerableUpgradeable -> Initializable [ label="1" ];
AccessControlEnumerableUpgradeable -> IAccessControlEnumerableUpgradeable [ label="2" ];
AccessControlEnumerableUpgradeable -> AccessControlUpgradeable [ label="3" ];
AccessControlEnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControlEnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMember(bytes32,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMemberCount(bytes32)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __AccessControlEnumerable_init()</TD></TR><TR><TD align="left">    __AccessControlEnumerable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _roleMembers</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'hasRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'getRoleAdmin(bytes32)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'grantRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'revokeRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'renounceRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.</font></TD></TR></TABLE> >];

AccessControlUpgradeable -> Initializable [ label="1" ];
AccessControlUpgradeable -> ContextUpgradeable [ label="2" ];
AccessControlUpgradeable -> IAccessControlUpgradeable [ label="3" ];
AccessControlUpgradeable -> ERC165Upgradeable [ label="4" ];
AccessControlUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControlUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __AccessControl_init()</TD></TR><TR><TD align="left">    __AccessControl_init_unchained()</TD></TR><TR><TD align="left">    _checkRole(bytes32)</TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

IAccessControlEnumerableUpgradeable -> IAccessControlUpgradeable;
IAccessControlEnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControlEnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getRoleMember(bytes32,uint256)</TD></TR><TR><TD align="left">    getRoleMemberCount(bytes32)</TD></TR></TABLE> >];

IAccessControlUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControlUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

OwnableUpgradeable -> Initializable [ label="1" ];
OwnableUpgradeable -> ContextUpgradeable [ label="2" ];
OwnableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>OwnableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Ownable_init()</TD></TR><TR><TD align="left">    __Ownable_init_unchained()</TD></TR><TR><TD align="left">    _checkOwner()</TD></TR><TR><TD align="left">    _transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

Initializable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Initializable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _disableInitializers()</TD></TR><TR><TD align="left">    _getInitializedVersion()</TD></TR><TR><TD align="left">    _isInitializing()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    initializer()</TD></TR><TR><TD align="left">    reinitializer(uint8)</TD></TR><TR><TD align="left">    onlyInitializing()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _initialized</TD></TR><TR><TD align="left">    _initializing</TD></TR></TABLE> >];

PausableUpgradeable -> Initializable [ label="1" ];
PausableUpgradeable -> ContextUpgradeable [ label="2" ];
PausableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>PausableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    paused()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Pausable_init()</TD></TR><TR><TD align="left">    __Pausable_init_unchained()</TD></TR><TR><TD align="left">    _requireNotPaused()</TD></TR><TR><TD align="left">    _requirePaused()</TD></TR><TR><TD align="left">    _pause()</TD></TR><TR><TD align="left">    _unpause()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    whenNotPaused()</TD></TR><TR><TD align="left">    whenPaused()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _paused</TD></TR></TABLE> >];

ReentrancyGuardUpgradeable -> Initializable;
ReentrancyGuardUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ReentrancyGuardUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ReentrancyGuard_init()</TD></TR><TR><TD align="left">    __ReentrancyGuard_init_unchained()</TD></TR><TR><TD align="left">    _nonReentrantBefore()</TD></TR><TR><TD align="left">    _nonReentrantAfter()</TD></TR><TR><TD align="left">    _reentrancyGuardEntered()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonReentrant()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _NOT_ENTERED</TD></TR><TR><TD align="left">    _ENTERED</TD></TR><TR><TD align="left">    _status</TD></TR><TR><TD align="left">    __gap</TD></TR></TABLE> >];

ERC1155Upgradeable -> Initializable [ label="1" ];
ERC1155Upgradeable -> ContextUpgradeable [ label="2" ];
ERC1155Upgradeable -> ERC165Upgradeable [ label="3" ];
ERC1155Upgradeable -> IERC1155Upgradeable [ label="4" ];
ERC1155Upgradeable -> IERC1155MetadataURIUpgradeable [ label="5" ];
ERC1155Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    uri(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOfBatch(address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155_init(string)</TD></TR><TR><TD align="left">    __ERC1155_init_unchained(string)</TD></TR><TR><TD align="left">    _safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _setURI(string)</TD></TR><TR><TD align="left">    _mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    _burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _doSafeTransferAcceptanceCheck(address,address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _doSafeBatchTransferAcceptanceCheck(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _asSingletonArray(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR><TR><TD align="left">    _uri</TD></TR></TABLE> >];

IERC1155ReceiverUpgradeable -> IERC165Upgradeable;
IERC1155ReceiverUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155ReceiverUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC1155Received(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

IERC1155Upgradeable -> IERC165Upgradeable;
IERC1155Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address,uint256)</TD></TR><TR><TD align="left">    balanceOfBatch(address[],uint256[])</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

ERC1155BurnableUpgradeable -> Initializable [ label="1" ];
ERC1155BurnableUpgradeable -> ERC1155Upgradeable [ label="2" ];
ERC1155BurnableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155BurnableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155Burnable_init()</TD></TR><TR><TD align="left">    __ERC1155Burnable_init_unchained()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC1155PausableUpgradeable -> Initializable [ label="1" ];
ERC1155PausableUpgradeable -> ERC1155Upgradeable [ label="2" ];
ERC1155PausableUpgradeable -> PausableUpgradeable [ label="3" ];
ERC1155PausableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155PausableUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155Pausable_init()</TD></TR><TR><TD align="left">    __ERC1155Pausable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC1155SupplyUpgradeable -> Initializable [ label="1" ];
ERC1155SupplyUpgradeable -> ERC1155Upgradeable [ label="2" ];
ERC1155SupplyUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155SupplyUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply(uint256)</TD></TR><TR><TD align="left">    exists(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155Supply_init()</TD></TR><TR><TD align="left">    __ERC1155Supply_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _totalSupply</TD></TR></TABLE> >];

IERC1155MetadataURIUpgradeable -> IERC1155Upgradeable;
IERC1155MetadataURIUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155MetadataURIUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    uri(uint256)</TD></TR></TABLE> >];

ERC1155PresetMinterPauserUpgradeable -> Initializable [ label="1" ];
ERC1155PresetMinterPauserUpgradeable -> ContextUpgradeable [ label="2" ];
ERC1155PresetMinterPauserUpgradeable -> AccessControlEnumerableUpgradeable [ label="3" ];
ERC1155PresetMinterPauserUpgradeable -> ERC1155BurnableUpgradeable [ label="4" ];
ERC1155PresetMinterPauserUpgradeable -> ERC1155PausableUpgradeable [ label="5" ];
ERC1155PresetMinterPauserUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155PresetMinterPauserUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(string)</TD></TR><TR><TD align="left">    mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155PresetMinterPauser_init(string)</TD></TR><TR><TD align="left">    __ERC1155PresetMinterPauser_init_unchained(string)</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC721Upgradeable -> Initializable [ label="1" ];
ERC721Upgradeable -> ContextUpgradeable [ label="2" ];
ERC721Upgradeable -> ERC165Upgradeable [ label="3" ];
ERC721Upgradeable -> IERC721Upgradeable [ label="4" ];
ERC721Upgradeable -> IERC721MetadataUpgradeable [ label="5" ];
ERC721Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    ownerOf(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenURI(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getApproved(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721_init(string,string)</TD></TR><TR><TD align="left">    __ERC721_init_unchained(string,string)</TD></TR><TR><TD align="left">    _baseURI()</TD></TR><TR><TD align="left">    _safeTransfer(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _ownerOf(uint256)</TD></TR><TR><TD align="left">    _exists(uint256)</TD></TR><TR><TD align="left">    _isApprovedOrOwner(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256,bytes)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(uint256)</TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _approve(address,uint256)</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _requireMinted(uint256)</TD></TR><TR><TD align="left">    _checkOnERC721Received(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    __unsafe_increaseBalance(address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR><TR><TD align="left">    _owners</TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _tokenApprovals</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR></TABLE> >];

IERC721ReceiverUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721ReceiverUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC721Received(address,address,uint256,bytes)</TD></TR></TABLE> >];

IERC721Upgradeable -> IERC165Upgradeable;
IERC721Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    ownerOf(uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    getApproved(uint256)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR></TABLE> >];

ERC721BurnableUpgradeable -> Initializable [ label="1" ];
ERC721BurnableUpgradeable -> ContextUpgradeable [ label="2" ];
ERC721BurnableUpgradeable -> ERC721Upgradeable [ label="3" ];
ERC721BurnableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721BurnableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721Burnable_init()</TD></TR><TR><TD align="left">    __ERC721Burnable_init_unchained()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC721EnumerableUpgradeable -> Initializable [ label="1" ];
ERC721EnumerableUpgradeable -> ERC721Upgradeable [ label="2" ];
ERC721EnumerableUpgradeable -> IERC721EnumerableUpgradeable [ label="3" ];
ERC721EnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721EnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenOfOwnerByIndex(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenByIndex(uint256)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721Enumerable_init()</TD></TR><TR><TD align="left">    __ERC721Enumerable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left">    _addTokenToOwnerEnumeration(address,uint256)</TD></TR><TR><TD align="left">    _addTokenToAllTokensEnumeration(uint256)</TD></TR><TR><TD align="left">    _removeTokenFromOwnerEnumeration(address,uint256)</TD></TR><TR><TD align="left">    _removeTokenFromAllTokensEnumeration(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _ownedTokens</TD></TR><TR><TD align="left">    _ownedTokensIndex</TD></TR><TR><TD align="left">    _allTokens</TD></TR><TR><TD align="left">    _allTokensIndex</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'balanceOf(address)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'ownerOf(uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'safeTransferFrom(address,address,uint256,bytes)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'safeTransferFrom(address,address,uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'transferFrom(address,address,uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'approve(address,uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'setApprovalForAll(address,bool)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'getApproved(uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'isApprovedForAll(address,address)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.</font></TD></TR></TABLE> >];

ERC721PausableUpgradeable -> Initializable [ label="1" ];
ERC721PausableUpgradeable -> ERC721Upgradeable [ label="2" ];
ERC721PausableUpgradeable -> PausableUpgradeable [ label="3" ];
ERC721PausableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721PausableUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721Pausable_init()</TD></TR><TR><TD align="left">    __ERC721Pausable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

IERC721EnumerableUpgradeable -> IERC721Upgradeable;
IERC721EnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721EnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    tokenOfOwnerByIndex(address,uint256)</TD></TR><TR><TD align="left">    tokenByIndex(uint256)</TD></TR></TABLE> >];

IERC721MetadataUpgradeable -> IERC721Upgradeable;
IERC721MetadataUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721MetadataUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    tokenURI(uint256)</TD></TR></TABLE> >];

ERC721PresetMinterPauserAutoIdUpgradeable -> Initializable [ label="1" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ContextUpgradeable [ label="2" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> AccessControlEnumerableUpgradeable [ label="3" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ERC721EnumerableUpgradeable [ label="4" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ERC721BurnableUpgradeable [ label="5" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ERC721PausableUpgradeable [ label="6" ];
ERC721PresetMinterPauserAutoIdUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721PresetMinterPauserAutoIdUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(string,string,string)</TD></TR><TR><TD align="left">    mint(address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721PresetMinterPauserAutoId_init(string,string,string)</TD></TR><TR><TD align="left">    __ERC721PresetMinterPauserAutoId_init_unchained(string,string,string)</TD></TR><TR><TD align="left"><font color="#FFA500">    _baseURI()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _tokenIdTracker</TD></TR><TR><TD align="left">    _baseTokenURI</TD></TR></TABLE> >];

AddressUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AddressUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResultFromTarget(address,bool,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR><TR><TD align="left">    _revert(bytes,string)</TD></TR></TABLE> >];

ContextUpgradeable -> Initializable;
ContextUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ContextUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Context_init()</TD></TR><TR><TD align="left">    __Context_init_unchained()</TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    __gap</TD></TR></TABLE> >];

CountersUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CountersUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    current(CountersUpgradeable.Counter)</TD></TR><TR><TD align="left">    increment(CountersUpgradeable.Counter)</TD></TR><TR><TD align="left">    decrement(CountersUpgradeable.Counter)</TD></TR><TR><TD align="left">    reset(CountersUpgradeable.Counter)</TD></TR></TABLE> >];

StringsUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>StringsUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toString(int256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left">    toHexString(address)</TD></TR><TR><TD align="left">    equal(string,string)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _SYMBOLS</TD></TR><TR><TD align="left">    _ADDRESS_LENGTH</TD></TR></TABLE> >];

ERC165Upgradeable -> Initializable [ label="1" ];
ERC165Upgradeable -> IERC165Upgradeable [ label="2" ];
ERC165Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC165_init()</TD></TR><TR><TD align="left">    __ERC165_init_unchained()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    __gap</TD></TR></TABLE> >];

IERC165Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

MathUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MathUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(uint256,uint256)</TD></TR><TR><TD align="left">    min(uint256,uint256)</TD></TR><TR><TD align="left">    average(uint256,uint256)</TD></TR><TR><TD align="left">    ceilDiv(uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    sqrt(uint256)</TD></TR><TR><TD align="left">    sqrt(uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    log2(uint256)</TD></TR><TR><TD align="left">    log2(uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    log10(uint256)</TD></TR><TR><TD align="left">    log10(uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    log256(uint256)</TD></TR><TR><TD align="left">    log256(uint256,MathUpgradeable.Rounding)</TD></TR></TABLE> >];

SignedMathUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SignedMathUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(int256,int256)</TD></TR><TR><TD align="left">    min(int256,int256)</TD></TR><TR><TD align="left">    average(int256,int256)</TD></TR><TR><TD align="left">    abs(int256)</TD></TR></TABLE> >];

EnumerableSetUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EnumerableSetUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _add(EnumerableSetUpgradeable.Set,bytes32)</TD></TR><TR><TD align="left">    _remove(EnumerableSetUpgradeable.Set,bytes32)</TD></TR><TR><TD align="left">    _contains(EnumerableSetUpgradeable.Set,bytes32)</TD></TR><TR><TD align="left">    _length(EnumerableSetUpgradeable.Set)</TD></TR><TR><TD align="left">    _at(EnumerableSetUpgradeable.Set,uint256)</TD></TR><TR><TD align="left">    _values(EnumerableSetUpgradeable.Set)</TD></TR><TR><TD align="left">    add(EnumerableSetUpgradeable.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    remove(EnumerableSetUpgradeable.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    contains(EnumerableSetUpgradeable.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    length(EnumerableSetUpgradeable.Bytes32Set)</TD></TR><TR><TD align="left">    at(EnumerableSetUpgradeable.Bytes32Set,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSetUpgradeable.Bytes32Set)</TD></TR><TR><TD align="left">    add(EnumerableSetUpgradeable.AddressSet,address)</TD></TR><TR><TD align="left">    remove(EnumerableSetUpgradeable.AddressSet,address)</TD></TR><TR><TD align="left">    contains(EnumerableSetUpgradeable.AddressSet,address)</TD></TR><TR><TD align="left">    length(EnumerableSetUpgradeable.AddressSet)</TD></TR><TR><TD align="left">    at(EnumerableSetUpgradeable.AddressSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSetUpgradeable.AddressSet)</TD></TR><TR><TD align="left">    add(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    remove(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    contains(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    length(EnumerableSetUpgradeable.UintSet)</TD></TR><TR><TD align="left">    at(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSetUpgradeable.UintSet)</TD></TR></TABLE> >];

AccessControl -> Context [ label="1" ];
AccessControl -> IAccessControl [ label="2" ];
AccessControl -> ERC165 [ label="3" ];
AccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkRole(bytes32)</TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

AccessControlEnumerable -> IAccessControlEnumerable [ label="1" ];
AccessControlEnumerable -> AccessControl [ label="2" ];
AccessControlEnumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControlEnumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMember(bytes32,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMemberCount(bytes32)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roleMembers</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'hasRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'getRoleAdmin(bytes32)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'grantRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'revokeRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'renounceRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.</font></TD></TR></TABLE> >];

IAccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

IAccessControlEnumerable -> IAccessControl;
IAccessControlEnumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControlEnumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getRoleMember(bytes32,uint256)</TD></TR><TR><TD align="left">    getRoleMemberCount(bytes32)</TD></TR></TABLE> >];

Pausable -> Context;
Pausable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Pausable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    paused()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _requireNotPaused()</TD></TR><TR><TD align="left">    _requirePaused()</TD></TR><TR><TD align="left">    _pause()</TD></TR><TR><TD align="left">    _unpause()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    whenNotPaused()</TD></TR><TR><TD align="left">    whenPaused()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _paused</TD></TR></TABLE> >];

ERC1155 -> Context [ label="1" ];
ERC1155 -> ERC165 [ label="2" ];
ERC1155 -> IERC1155 [ label="3" ];
ERC1155 -> IERC1155MetadataURI [ label="4" ];
ERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    uri(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOfBatch(address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _setURI(string)</TD></TR><TR><TD align="left">    _mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    _burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _doSafeTransferAcceptanceCheck(address,address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _doSafeBatchTransferAcceptanceCheck(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _asSingletonArray(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR><TR><TD align="left">    _uri</TD></TR></TABLE> >];

IERC1155 -> IERC165;
IERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address,uint256)</TD></TR><TR><TD align="left">    balanceOfBatch(address[],uint256[])</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

IERC1155Receiver -> IERC165;
IERC1155Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC1155Received(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

ERC1155Burnable -> ERC1155;
ERC1155Burnable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Burnable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    burnBatch(address,uint256[],uint256[])</TD></TR></TABLE> >];

IERC1155MetadataURI -> IERC1155;
IERC1155MetadataURI[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155MetadataURI</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    uri(uint256)</TD></TR></TABLE> >];

ERC20 -> Context [ label="1" ];
ERC20 -> IERC20 [ label="2" ];
ERC20 -> IERC20Metadata [ label="3" ];
ERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transfer(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    allowance(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left">    increaseAllowance(address,uint256)</TD></TR><TR><TD align="left">    decreaseAllowance(address,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(address,uint256)</TD></TR><TR><TD align="left">    _approve(address,address,uint256)</TD></TR><TR><TD align="left">    _spendAllowance(address,address,uint256)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _allowances</TD></TR><TR><TD align="left">    _totalSupply</TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR></TABLE> >];

IERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

ERC20Burnable -> Context [ label="1" ];
ERC20Burnable -> ERC20 [ label="2" ];
ERC20Burnable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Burnable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(uint256)</TD></TR><TR><TD align="left">    burnFrom(address,uint256)</TD></TR></TABLE> >];

ERC20Pausable -> ERC20 [ label="1" ];
ERC20Pausable -> Pausable [ label="2" ];
ERC20Pausable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Pausable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR></TABLE> >];

IERC20Metadata -> IERC20;
IERC20Metadata[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20Metadata</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    decimals()</TD></TR></TABLE> >];

ERC20PresetMinterPauser -> Context [ label="1" ];
ERC20PresetMinterPauser -> AccessControlEnumerable [ label="2" ];
ERC20PresetMinterPauser -> ERC20Burnable [ label="3" ];
ERC20PresetMinterPauser -> ERC20Pausable [ label="4" ];
ERC20PresetMinterPauser[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20PresetMinterPauser</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    mint(address,uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR></TABLE> >];

IERC721 -> IERC165;
IERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    ownerOf(uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    getApproved(uint256)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResultFromTarget(address,bool,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR><TR><TD align="left">    _revert(bytes,string)</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

Strings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Strings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toString(int256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left">    toHexString(address)</TD></TR><TR><TD align="left">    equal(string,string)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _SYMBOLS</TD></TR><TR><TD align="left">    _ADDRESS_LENGTH</TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

Math[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Math</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(uint256,uint256)</TD></TR><TR><TD align="left">    min(uint256,uint256)</TD></TR><TR><TD align="left">    average(uint256,uint256)</TD></TR><TR><TD align="left">    ceilDiv(uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256,Math.Rounding)</TD></TR><TR><TD align="left">    sqrt(uint256)</TD></TR><TR><TD align="left">    sqrt(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log2(uint256)</TD></TR><TR><TD align="left">    log2(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log10(uint256)</TD></TR><TR><TD align="left">    log10(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log256(uint256)</TD></TR><TR><TD align="left">    log256(uint256,Math.Rounding)</TD></TR></TABLE> >];

SafeMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SafeMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    tryAdd(uint256,uint256)</TD></TR><TR><TD align="left">    trySub(uint256,uint256)</TD></TR><TR><TD align="left">    tryMul(uint256,uint256)</TD></TR><TR><TD align="left">    tryDiv(uint256,uint256)</TD></TR><TR><TD align="left">    tryMod(uint256,uint256)</TD></TR><TR><TD align="left">    add(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256)</TD></TR><TR><TD align="left">    mul(uint256,uint256)</TD></TR><TR><TD align="left">    div(uint256,uint256)</TD></TR><TR><TD align="left">    mod(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256,string)</TD></TR><TR><TD align="left">    div(uint256,uint256,string)</TD></TR><TR><TD align="left">    mod(uint256,uint256,string)</TD></TR></TABLE> >];

SignedMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SignedMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(int256,int256)</TD></TR><TR><TD align="left">    min(int256,int256)</TD></TR><TR><TD align="left">    average(int256,int256)</TD></TR><TR><TD align="left">    abs(int256)</TD></TR></TABLE> >];

EnumerableSet[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EnumerableSet</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _add(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _remove(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _contains(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _length(EnumerableSet.Set)</TD></TR><TR><TD align="left">    _at(EnumerableSet.Set,uint256)</TD></TR><TR><TD align="left">    _values(EnumerableSet.Set)</TD></TR><TR><TD align="left">    add(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    remove(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    contains(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    length(EnumerableSet.Bytes32Set)</TD></TR><TR><TD align="left">    at(EnumerableSet.Bytes32Set,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.Bytes32Set)</TD></TR><TR><TD align="left">    add(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    remove(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    contains(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    length(EnumerableSet.AddressSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.AddressSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.AddressSet)</TD></TR><TR><TD align="left">    add(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    remove(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    contains(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    length(EnumerableSet.UintSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.UintSet)</TD></TR></TABLE> >];

UntangledBase -> Initializable [ label="1" ];
UntangledBase -> PausableUpgradeable [ label="2" ];
UntangledBase -> ReentrancyGuardUpgradeable [ label="3" ];
UntangledBase -> AccessControlEnumerableUpgradeable [ label="4" ];
UntangledBase[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UntangledBase</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __UntangledBase__init(address)</TD></TR><TR><TD align="left">    __UntangledBase__init_unchained(address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    OWNER_ROLE</TD></TR></TABLE> >];

IDistributionAssessor[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IDistributionAssessor</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getSOTTokenPrice(address,uint256)</TD></TR><TR><TD align="left">    getJOTTokenPrice(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    calcTokenPrice(address,address)</TD></TR><TR><TD align="left">    getCashBalance(address)</TD></TR><TR><TD align="left">    calcAssetValue(address,address,address)</TD></TR><TR><TD align="left">    calcCorrespondingTotalAssetValue(address,address,uint256)</TD></TR></TABLE> >];

IDistributionOperator[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IDistributionOperator</B></TD></TR></TABLE> >];

IDistributionTranche[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IDistributionTranche</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    redeem(address,address,address,uint256,uint256)</TD></TR><TR><TD align="left">    redeemToken(address,address,uint256)</TD></TR></TABLE> >];

ILoanInterestTermsContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanInterestTermsContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    registerTermStart(bytes32)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    isCompletedRepayments(bytes32[])</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(bytes32,uint256)</TD></TR><TR><TD align="left">    getMultiExpectedRepaymentValues(bytes32[],uint256)</TD></TR><TR><TD align="left">    registerConcludeLoan(bytes32)</TD></TR><TR><TD align="left">    registerRepayment(bytes32,address,address,uint256,address)</TD></TR><TR><TD align="left">    getInterestRate(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    startedLoan</TD></TR><TR><TD align="left">    repaidPrincipalAmounts</TD></TR><TR><TD align="left">    repaidInterestAmounts</TD></TR><TR><TD align="left">    completedRepayment</TD></TR></TABLE> >];

ILoanKernel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanKernel</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    NULL_ISSUANCE_HASH</TD></TR><TR><TD align="left">    NULL_COLLATERAL_INFO_HASH</TD></TR><TR><TD align="left">    NULL_ADDRESS</TD></TR><TR><TD align="left">    issuanceCancelled</TD></TR><TR><TD align="left">    debtOrderCancelled</TD></TR><TR><TD align="left">    debtOrderCompleted</TD></TR></TABLE> >];

ILoanRegistry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanRegistry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    insert(bytes32,address,address,bytes32,address,uint256,uint256,uint8[])</TD></TR><TR><TD align="left">    getLoanDebtor(bytes32)</TD></TR><TR><TD align="left">    getLoanTermParams(bytes32)</TD></TR><TR><TD align="left">    getPrincipalTokenAddress(bytes32)</TD></TR><TR><TD align="left">    getDebtor(bytes32)</TD></TR><TR><TD align="left">    getTermContract(bytes32)</TD></TR><TR><TD align="left">    getRiskScore(bytes32)</TD></TR><TR><TD align="left">    getAssetPurpose(bytes32)</TD></TR><TR><TD align="left">    getIssuanceBlockTimestamp(bytes32)</TD></TR><TR><TD align="left">    getLastRepaymentTimestamp(bytes32)</TD></TR><TR><TD align="left">    getTermsContractParameters(bytes32)</TD></TR><TR><TD align="left">    getExpirationTimestamp(bytes32)</TD></TR><TR><TD align="left">    updateLastRepaymentTimestamp(bytes32,uint256)</TD></TR><TR><TD align="left">    principalPaymentInfo(bytes32)</TD></TR><TR><TD align="left">    setCompletedLoan(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    entries</TD></TR><TR><TD align="left">    manualInterestLoan</TD></TR><TR><TD align="left">    manualInterestAmountLoan</TD></TR><TR><TD align="left">    completedLoans</TD></TR></TABLE> >];

ILoanRepaymentRouter -> UntangledBase;
ILoanRepaymentRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanRepaymentRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    repayInBatch(bytes32[],uint256[],address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

INoteToken -> ERC20PresetMinterPauser;
INoteToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>INoteToken</B></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    poolAddress</TD></TR><TR><TD align="left">    noteTokenType</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _d</TD></TR></TABLE> >];

INoteTokenFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>INoteTokenFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    changeMinterRole(address,address)</TD></TR><TR><TD align="left">    createToken(address,Configuration.NOTE_TOKEN_TYPE,uint8,string)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    tokens</TD></TR><TR><TD align="left">    isExistingTokens</TD></TR></TABLE> >];

ISecuritizationManager[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISecuritizationManager</B></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    isExistingPools</TD></TR><TR><TD align="left">    pools</TD></TR><TR><TD align="left">    poolToSOT</TD></TR><TR><TD align="left">    poolToJOT</TD></TR><TR><TD align="left">    isExistingTGEs</TD></TR><TR><TD align="left">    POOL_CREATOR</TD></TR></TABLE> >];

ISecuritizationPool -> UntangledBase;
ISecuritizationPool[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISecuritizationPool</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,address,uint32)</TD></TR><TR><TD align="left">    getNFTAssetsLength()</TD></TR><TR><TD align="left">    getTokenAssetAddresses()</TD></TR><TR><TD align="left">    getTokenAssetAddressesLength()</TD></TR><TR><TD align="left">    getRiskScoresLength()</TD></TR><TR><TD align="left">    isClosedState()</TD></TR><TR><TD align="left">    hasFinishedRedemption()</TD></TR><TR><TD align="left">    setPot(address)</TD></TR><TR><TD align="left">    setupRiskScores(uint32[],uint32[],uint32[])</TD></TR><TR><TD align="left">    exportAssets(address,address,uint256[])</TD></TR><TR><TD align="left">    withdrawAssets(address[],uint256[],address[])</TD></TR><TR><TD align="left">    collectAssets(address,address,uint256[])</TD></TR><TR><TD align="left">    collectERC20Assets(address[],address[],uint256[])</TD></TR><TR><TD align="left">    withdrawERC20Assets(address[],address[],uint256[])</TD></TR><TR><TD align="left">    claimERC20Assets(address[])</TD></TR><TR><TD align="left">    claimCashRemain(address)</TD></TR><TR><TD align="left">    injectTGEAddress(address,address,Configuration.NOTE_TOKEN_TYPE)</TD></TR><TR><TD align="left">    startCycle(uint64,uint256,uint32,uint64)</TD></TR><TR><TD align="left">    setInterestRateForSOT(uint32)</TD></TR><TR><TD align="left">    increaseLockedDistributeBalance(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    increaseTotalAssetRepaidCurrency(uint256)</TD></TR><TR><TD align="left">    decreaseLockedDistributeBalance(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    redeem(address,address,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    ORIGINATOR_ROLE</TD></TR><TR><TD align="left">    tgeAddress</TD></TR><TR><TD align="left">    secondTGEAddress</TD></TR><TR><TD align="left">    sotToken</TD></TR><TR><TD align="left">    jotToken</TD></TR><TR><TD align="left">    underlyingCurrency</TD></TR><TR><TD align="left">    state</TD></TR><TR><TD align="left">    openingBlockTimestamp</TD></TR><TR><TD align="left">    termLengthInSeconds</TD></TR><TR><TD align="left">    totalRedeemedCurrency</TD></TR><TR><TD align="left">    totalLockedDistributeBalance</TD></TR><TR><TD align="left">    totalLockedRedeemBalances</TD></TR><TR><TD align="left">    lockedDistributeBalances</TD></TR><TR><TD align="left">    lockedRedeemBalances</TD></TR><TR><TD align="left">    totalAssetRepaidCurrency</TD></TR><TR><TD align="left">    paidInterestAmountSOT</TD></TR><TR><TD align="left">    lastRepayTimestampSOT</TD></TR><TR><TD align="left">    principalAmountSOT</TD></TR><TR><TD align="left">    paidPrincipalAmountSOT</TD></TR><TR><TD align="left">    interestRateSOT</TD></TR><TR><TD align="left">    minFirstLossCushion</TD></TR><TR><TD align="left">    riskScores</TD></TR><TR><TD align="left">    nftAssets</TD></TR><TR><TD align="left">    tokenAssetAddresses</TD></TR><TR><TD align="left">    existsTokenAssetAddress</TD></TR><TR><TD align="left">    paidPrincipalAmountSOTByInvestor</TD></TR><TR><TD align="left">    pot</TD></TR></TABLE> >];

ISecuritizationPoolValueService[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISecuritizationPoolValueService</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getOutstandingPrincipalCurrencyByInvestor(address,address)</TD></TR><TR><TD align="left">    getExpectedAssetsValue(address,uint256)</TD></TR><TR><TD align="left">    getSeniorAsset(address)</TD></TR><TR><TD align="left">    getJuniorAsset(address)</TD></TR></TABLE> >];

ISupplyChainManagementProgram -> Initializable [ label="1" ];
ISupplyChainManagementProgram -> PausableUpgradeable [ label="2" ];
ISupplyChainManagementProgram -> AccessControlEnumerableUpgradeable [ label="3" ];
ISupplyChainManagementProgram[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISupplyChainManagementProgram</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    newProject(uint256,string,address)</TD></TR><TR><TD align="left">    updateCompanyId(uint256,string)</TD></TR><TR><TD align="left">    addCommodity(uint256,uint256,string,uint256)</TD></TR><TR><TD align="left">    addTrader(uint256,address)</TD></TR><TR><TD align="left">    addLender(uint256,address)</TD></TR><TR><TD align="left">    addExecutor(uint256,address)</TD></TR><TR><TD align="left">    removeTrader(uint256,address)</TD></TR><TR><TD align="left">    removeLender(uint256,address)</TD></TR><TR><TD align="left">    removeExecutor(uint256,address)</TD></TR><TR><TD align="left">    isTrader(uint256,address)</TD></TR><TR><TD align="left">    isLender(uint256,address)</TD></TR><TR><TD align="left">    isExecutor(uint256,address)</TD></TR><TR><TD align="left">    initMovement(string,uint256,uint256,uint8)</TD></TR><TR><TD align="left">    approveMovement(string,uint256)</TD></TR><TR><TD align="left">    executeMovement(string,uint256,uint256)</TD></TR><TR><TD align="left">    updateStateMovement(string,uint256,ISupplyChainManagementProgram.MovementState,uint256,address)</TD></TR><TR><TD align="left">    isProjectExisting(uint256)</TD></TR><TR><TD align="left">    bulkInsertCompletedMovement(bytes32[],uint256[],uint256[],uint8[],address[],address[],uint256[])</TD></TR><TR><TD align="left">    addExistedBalance(uint256,uint256,address,uint256)</TD></TR><TR><TD align="left">    removeExistedBalance(uint256,uint256,address,uint256)</TD></TR><TR><TD align="left">    getCommodityPrice(uint256)</TD></TR><TR><TD align="left">    updateCommodityPrice(uint256,uint256)</TD></TR><TR><TD align="left">    insertAgreementToCommodity(uint256,bytes32)</TD></TR><TR><TD align="left">    removeAgreementFromCommodity(uint256,bytes32)</TD></TR><TR><TD align="left">    getAgreementsOfProjectCommodity(uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    PRICE_FEED_ROLE</TD></TR><TR><TD align="left">    OWNER_ROLE</TD></TR><TR><TD align="left">    collateralProjects</TD></TR><TR><TD align="left">    isExistingProjects</TD></TR><TR><TD align="left">    projectToLenders</TD></TR><TR><TD align="left">    projectToTraders</TD></TR><TR><TD align="left">    projectToExecutors</TD></TR><TR><TD align="left">    isExistingManager</TD></TR><TR><TD align="left">    projectToExistedProjectCommodity</TD></TR><TR><TD align="left">    projectToMovements</TD></TR><TR><TD align="left">    projectToExistedMovements</TD></TR><TR><TD align="left">    projectCommodityToPrice</TD></TR><TR><TD align="left">    projectCommodityToAgreements</TD></TR><TR><TD align="left">    projectCommodityToCommodity</TD></TR><TR><TD align="left">    projectCommodityToProject</TD></TR></TABLE> >];

ITokenGenerationEventFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ITokenGenerationEventFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    createNewSaleInstance(address,address,address,address,uint8,bool)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    tgeAddresses</TD></TR><TR><TD align="left">    isExistingTge</TD></TR></TABLE> >];

IUntangledERC721 -> ERC721PresetMinterPauserAutoIdUpgradeable;
IUntangledERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IUntangledERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    mint(address,uint256)</TD></TR><TR><TD align="left">    getTotalExpectedRepaymentValue(uint256,uint256)</TD></TR><TR><TD align="left">    getExpirationTimestamp(uint256)</TD></TR><TR><TD align="left">    getInterestRate(uint256)</TD></TR><TR><TD align="left">    getRiskScore(uint256)</TD></TR><TR><TD align="left">    getAssetPurpose(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __UntangledERC721__init(string,string,string)</TD></TR><TR><TD align="left">    __UntangledERC721__init_unchained(string,string,string)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

ConfigHelper[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ConfigHelper</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getAddress(Registry,Configuration.CONTRACT_TYPE)</TD></TR><TR><TD align="left">    getSecuritizationManager(Registry)</TD></TR><TR><TD align="left">    getSecuritizationPool(Registry)</TD></TR><TR><TD align="left">    getNoteTokenFactory(Registry)</TD></TR><TR><TD align="left">    getTokenGenerationEventFactory(Registry)</TD></TR><TR><TD align="left">    getDistributionOperator(Registry)</TD></TR><TR><TD align="left">    getLoanAssetToken(Registry)</TD></TR><TR><TD align="left">    getAcceptedInvoiceToken(Registry)</TD></TR><TR><TD align="left">    getLoanRegistry(Registry)</TD></TR><TR><TD align="left">    getLoanInterestTermsContract(Registry)</TD></TR><TR><TD align="left">    getLoanRepaymentRouter(Registry)</TD></TR><TR><TD align="left">    getLoanKernel(Registry)</TD></TR><TR><TD align="left">    getDistributionTranche(Registry)</TD></TR><TR><TD align="left">    getSecuritizationPoolValueService(Registry)</TD></TR><TR><TD align="left">    getDistributionAssessor(Registry)</TD></TR><TR><TD align="left">    getMintedIncreasingInterestTGE(Registry)</TD></TR><TR><TD align="left">    getMintedNormalTGE(Registry)</TD></TR><TR><TD align="left">    getCollateralManagementToken(Registry)</TD></TR><TR><TD align="left">    getSupplyChainManagementProgram(Registry)</TD></TR><TR><TD align="left">    getInventoryLoanRegistry(Registry)</TD></TR><TR><TD align="left">    getInventoryCollateralizer(Registry)</TD></TR><TR><TD align="left">    getInventoryInterestTermsContract(Registry)</TD></TR><TR><TD align="left">    getInventoryLoanKernel(Registry)</TD></TR><TR><TD align="left">    getInventoryLoanRepaymentRouter(Registry)</TD></TR><TR><TD align="left">    getInvoiceDebtRegistry(Registry)</TD></TR><TR><TD align="left">    getInvoiceCollateralizer(Registry)</TD></TR><TR><TD align="left">    getInvoiceFinanceInterestTermsContract(Registry)</TD></TR><TR><TD align="left">    getInvoiceLoanKernel(Registry)</TD></TR><TR><TD align="left">    getInvoiceLoanRepaymentRouter(Registry)</TD></TR></TABLE> >];

Configuration[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Configuration</B></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    PRICE_SCALING_FACTOR</TD></TR></TABLE> >];

SignaturesLib[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SignaturesLib</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    isValidSignature(address,bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    PREFIX</TD></TR></TABLE> >];

TransferHelper[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TransferHelper</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    safeApprove(address,address,uint256)</TD></TR><TR><TD align="left">    safeTransfer(address,address,uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,address,uint256)</TD></TR></TABLE> >];

Unpack[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Unpack</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    unpackPrincipalAmount(bytes32)</TD></TR><TR><TD align="left">    unpackInterestRate(bytes32)</TD></TR><TR><TD align="left">    unpackAmortizationUnitType(bytes32)</TD></TR><TR><TD align="left">    unpackTermLengthInAmortizationUnits(bytes32)</TD></TR><TR><TD align="left">    unpackGracePeriodInDays(bytes32)</TD></TR></TABLE> >];

Unpack16[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Unpack16</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    unpackCollateralTokenId(bytes16)</TD></TR><TR><TD align="left">    unpackCollateralAmount(bytes16)</TD></TR></TABLE> >];

UnpackLoanParamtersLib[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UnpackLoanParamtersLib</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _bitShiftRight(bytes32,uint256)</TD></TR><TR><TD align="left">    _unpackLoanTermsParametersFromBytes(bytes32)</TD></TR><TR><TD align="left">    unpackParametersFromBytes(bytes32)</TD></TR></TABLE> >];

UntangledMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UntangledMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    rpow(uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ONE</TD></TR></TABLE> >];

SupplyChainManagementProgram -> ISupplyChainManagementProgram;
SupplyChainManagementProgram[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SupplyChainManagementProgram</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    initialize(Registry)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    newProject(uint256,string,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    updateCompanyId(uint256,string)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addCommodity(uint256,uint256,string,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addTrader(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addLender(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addExecutor(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeTrader(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeLender(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeExecutor(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isTrader(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isLender(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isExecutor(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    initMovement(string,uint256,uint256,uint8)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approveMovement(string,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    executeMovement(string,uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    updateStateMovement(string,uint256,ISupplyChainManagementProgram.MovementState,uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isProjectExisting(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    bulkInsertCompletedMovement(bytes32[],uint256[],uint256[],uint8[],address[],address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addExistedBalance(uint256,uint256,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeExistedBalance(uint256,uint256,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getCommodityPrice(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    updateCommodityPrice(uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    insertAgreementToCommodity(uint256,bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeAgreementFromCommodity(uint256,bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAgreementsOfProjectCommodity(uint256)</font></TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _isMovementExisting(uint256,string)</TD></TR><TR><TD align="left">    _isMovementExisting(uint256,bytes32)</TD></TR><TR><TD align="left">    _isCollateralManager(uint256,address)</TD></TR><TR><TD align="left">    _doWithdraw(address,uint256,uint256)</TD></TR><TR><TD align="left">    _doDeposit(address,uint256,uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyCollateralManager(uint256)</TD></TR><TR><TD align="left">    onlyTrader(uint256)</TD></TR><TR><TD align="left">    onlyProjectExisted(uint256)</TD></TR><TR><TD align="left">    onlyPriceFeedManager()</TD></TR></TABLE> >];

LoanTyping[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LoanTyping</B></TD></TR></TABLE> >];

CRInventoryDecisionEngine -> SignaturesLib;
CRInventoryDecisionEngine[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CRInventoryDecisionEngine</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _computeCR(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _computeCR(uint256,uint256)</TD></TR><TR><TD align="left">    _computePriceValue(uint256,uint256)</TD></TR><TR><TD align="left">    _computePrincipalValueRequire(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _verifyPrice(uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    PRICE_PRECISION</TD></TR><TR><TD align="left">    CR_PRECISION</TD></TR><TR><TD align="left">    MAX_PRICE_TTL_IN_SECONDS</TD></TR><TR><TD align="left">    COLLATERAL_PRECISION</TD></TR><TR><TD align="left">    PRINCIPAL_PRECISION</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    MAX_UINT256</TD></TR></TABLE> >];

InventoryCollateralizer -> IERC721ReceiverUpgradeable [ label="1" ];
InventoryCollateralizer -> IERC1155ReceiverUpgradeable [ label="2" ];
InventoryCollateralizer -> UntangledBase [ label="3" ];
InventoryCollateralizer[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryCollateralizer</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    collateralizeERC1155(bytes32,address,address)</TD></TR><TR><TD align="left">    additionInventoryCollateralize(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    withdrawInventoryCollateralize(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    burnInventoryCollateralize(bytes32,uint256,address)</TD></TR><TR><TD align="left">    returnInventoryCollateral(bytes32)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155Received(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left">    timestampAdjustedForGracePeriod(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _unpackLoanTermsParametersFromBytes(bytes32)</TD></TR><TR><TD align="left">    _unpackInventoryCollateralParametersFromBytes(bytes16)</TD></TR><TR><TD align="left">    retrieveInventoryCollateralParameters(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyPermissionedInventoryTermContract(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    COLLATERALIZER</TD></TR><TR><TD align="left">    agreementToCollateralizer</TD></TR><TR><TD align="left">    SECONDS_IN_DAY</TD></TR><TR><TD align="left">    CONTEXT</TD></TR><TR><TD align="left">    CONTEXT_COLLATERAL_SALE</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'supportsInterface(bytes4)' collides in inherited contracts IERC165Upgradeable, AccessControlEnumerableUpgradeable where AccessControlEnumerableUpgradeable is chosen.</font></TD></TR></TABLE> >];

InventoryInterestTermsContract -> CRInventoryDecisionEngine [ label="1" ];
InventoryInterestTermsContract -> LoanTyping [ label="2" ];
InventoryInterestTermsContract -> PausableUpgradeable [ label="3" ];
InventoryInterestTermsContract -> OwnableUpgradeable [ label="4" ];
InventoryInterestTermsContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryInterestTermsContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    registerTermStart(bytes32,address[2])</TD></TR><TR><TD align="left">    registerRepayment(bytes32,uint256,address)</TD></TR><TR><TD align="left">    registerSecureLoanWithCollateral(bytes32,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    registerInsecureLoanByWithdrawCollateral(bytes32,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    registerSellCollateral(bytes32,uint256,uint256,uint256,address,bytes16)</TD></TR><TR><TD align="left">    registerPayCollateralByFiat(bytes32,bytes32,address)</TD></TR><TR><TD align="left">    registerPayCollateralByInvoice(bytes32,bytes32,address,uint256,uint256)</TD></TR><TR><TD align="left">    registerPayFromInvoice(bytes32,uint256,address,address)</TD></TR><TR><TD align="left">    registerDrawdownLoan(bytes32,uint256,bytes32)</TD></TR><TR><TD align="left">    registerForeclosureLoan(bytes32)</TD></TR><TR><TD align="left">    getTermEndTimestamp(bytes32)</TD></TR><TR><TD align="left">    registerConcludeTerm(bytes32)</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(bytes32,uint256)</TD></TR><TR><TD align="left">    getTermStartUnixTimestamp(bytes32)</TD></TR><TR><TD align="left">    getTotalExpectedRepaymentValue(bytes32,uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    collateralize(bytes32,address[2])</TD></TR><TR><TD align="left">    _getAmortizationUnitLengthInSeconds(InventoryInterestTermsContract.AmortizationUnitType)</TD></TR><TR><TD align="left">    _unpackParamsForAgreementID(LoanTyping.LoanTypes,bytes32)</TD></TR><TR><TD align="left">    _validateNewInventoryCollateralParamsSecureLoan(bytes16,bytes16,uint256)</TD></TR><TR><TD align="left">    _validateNewInventoryTermsContractParamsDrawdown(bytes32,bytes32,uint256)</TD></TR><TR><TD align="left">    _validateNewInventoryCollateralParamsSellCollateral(bytes16,bytes16,uint256)</TD></TR><TR><TD align="left">    _validateNewCollateralAmount(bytes32,bytes16,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _validateNewCollateralRatioWithInvoice(uint256,bytes32,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _validateNewCollateralRatioWhenDrawdown(bytes32,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _repayLoanIfNeed(uint256,bytes32,uint256,uint256,address[2],uint256)</TD></TR><TR><TD align="left">    _computeExpectedCR(bytes32,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _burnCollateralAndUpdateInfo(bytes32,uint256,address,bytes16,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _createAITFinanced(bytes32,address,uint256,uint256,uint256,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _getSellCollateralId(bytes32,uint256,uint256)</TD></TR><TR><TD align="left">    _calculateInterestForDuration(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getStartDateInTimestamp(uint256)</TD></TR><TR><TD align="left">    _calculateInterestAmountToTimestamp(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _getExpectedRepaymentValuesToTimestamp(InventoryInterestTermsContract.InterestParams,uint256,uint256,uint256,uint256,bool,uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRouter(LoanTyping.LoanTypes)</TD></TR><TR><TD align="left">    onlyDebtKernel()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    NUM_AMORTIZATION_UNIT_TYPES</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    WEEK_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    MONTH_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_MULTIPLIER</TD></TR></TABLE> >];

InventoryLoanKernel -> PausableUpgradeable [ label="1" ];
InventoryLoanKernel -> OwnableUpgradeable [ label="2" ];
InventoryLoanKernel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryLoanKernel</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    _fillDebtOrder(address,address,uint256,address[6],uint256[7],bytes32[1],bytes16[1],address[5],address[5],uint256[5],uint256[5])</TD></TR><TR><TD align="left">    fillDebtOrder(address,address[6],uint256[7],bytes32[1],bytes16[1],uint8[2],bytes32[2],bytes32[2],address[5],address[5],uint256[5],uint256[5])</TD></TR><TR><TD align="left">    concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left">    secureLoanWithCollateral(bytes32,address,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    cancelDebtOrder(address[6],uint256[7],bytes32[1],bytes16[1])</TD></TR><TR><TD align="left">    cancelIssuance(address,address,address,bytes32,bytes16,uint256)</TD></TR><TR><TD align="left">    sellCollateral(bytes32,uint256,uint256,uint256,uint256,address,bytes16,address[3],uint8[3],bytes32[3],bytes32[3])</TD></TR><TR><TD align="left">    payCollateralByFiat(bytes32,bytes32,address)</TD></TR><TR><TD align="left">    payCollateralByInvoice(bytes32,bytes32,address,uint256,uint256)</TD></TR><TR><TD align="left">    insecureLoanByWithdrawCollateral(bytes32,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    foreclosureLoanBySellCollateral(bytes32,uint256,uint256,uint256,uint256,address,bytes16,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    drawdownLoan(bytes32,uint256,bytes32,uint8[2],bytes32[2],bytes32[2])</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getDebtOrderHash(InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _getDebtOrder(address[6],uint256[7],bytes32[1],bytes16[1])</TD></TR><TR><TD align="left">    _getAgreementId(address,address,address,uint256,bytes32)</TD></TR><TR><TD align="left">    _getIssuance(address,address,address,uint256,bytes32,bytes16)</TD></TR><TR><TD align="left">    _issueDebtAgreement(address,InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _burnLoanAssetToken(address,bytes32)</TD></TR><TR><TD align="left">    _getBalance(address,address)</TD></TR><TR><TD align="left">    _getAllowance(address,address)</TD></TR><TR><TD align="left">    _isValidSignature(address,bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _assertDebtOrderValidityInvariants(InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _assertDebtOrderConsensualityInvariants(InventoryLoanKernel.DebtOrder,address,uint8[2],bytes32[2],bytes32[2])</TD></TR><TR><TD align="left">    _assertDebtExisting(bytes32)</TD></TR><TR><TD align="left">    _assertCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    _concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left">    _transferFeesToBeneficiaries(address,address,address,address[5],uint256[5])</TD></TR><TR><TD align="left">    _sumTotalFees(uint256[5])</TD></TR><TR><TD align="left">    getSignatureRS()</TD></TR><TR><TD align="left">    getSignatureV()</TD></TR><TR><TD align="left">    getAssetHolder(InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _isParticipantOfProject(uint256,address,address,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NULL_ISSUANCE_HASH</TD></TR><TR><TD align="left">    EXTERNAL_QUERY_GAS_LIMIT</TD></TR><TR><TD align="left">    issuanceCancelled</TD></TR><TR><TD align="left">    debtOrderCancelled</TD></TR><TR><TD align="left">    debtOrderCompleted</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

InventoryLoanRegistry -> UntangledBase [ label="1" ];
InventoryLoanRegistry -> CRInventoryDecisionEngine [ label="2" ];
InventoryLoanRegistry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryLoanRegistry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    insert(address,address,address,address,address,address,bytes32,bytes16,uint256[4])</TD></TR><TR><TD align="left">    insertInvoiceFinancedToInventoryLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    evaluateCollateralRatio(bytes32,uint256,uint256)</TD></TR><TR><TD align="left">    selfEvaluateCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    updateLoanTermParameters(bytes32,bytes32)</TD></TR><TR><TD align="left">    updateCollateralInfoParameters(bytes32,bytes16)</TD></TR><TR><TD align="left">    setMinCollateralRatio(bytes32,uint256)</TD></TR><TR><TD align="left">    setLiquidationRatio(bytes32,uint256)</TD></TR><TR><TD align="left">    modifyBeneficiary(bytes32,address)</TD></TR><TR><TD align="left">    updateLastRepaymentTimestamp(bytes32,uint256)</TD></TR><TR><TD align="left">    doesEntryExist(bytes32)</TD></TR><TR><TD align="left">    getBeneficiary(bytes32)</TD></TR><TR><TD align="left">    getDebtor(bytes32)</TD></TR><TR><TD align="left">    getTerms(bytes32)</TD></TR><TR><TD align="left">    getTermsContract(bytes32)</TD></TR><TR><TD align="left">    getTermsContractParameters(bytes32)</TD></TR><TR><TD align="left">    getIssuanceBlockTimestamp(bytes32)</TD></TR><TR><TD align="left">    getLastRepaymentTimestamp(bytes32)</TD></TR><TR><TD align="left">    getExpirationTimestamp(bytes32)</TD></TR><TR><TD align="left">    get(bytes32)</TD></TR><TR><TD align="left">    getLiquidationRatio(bytes32)</TD></TR><TR><TD align="left">    getMinCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    getCollateralLastPrice(bytes32)</TD></TR><TR><TD align="left">    getInitCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    isReadyForLiquidation(bytes32)</TD></TR><TR><TD align="left">    latestCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    getCollateralInfoParameters(bytes32)</TD></TR><TR><TD align="left">    getInvoiceIds(bytes32)</TD></TR><TR><TD align="left">    removeInvoiceId(bytes32,uint256)</TD></TR><TR><TD align="left">    _getTotalInvoiceAmount(bytes32)</TD></TR><TR><TD align="left">    setWaitingSellCollateral(bytes32,bytes32,uint256,uint256)</TD></TR><TR><TD align="left">    isWaitingSellCollateralExisted(bytes32,bytes32)</TD></TR><TR><TD align="left">    getWaitingSellCollateral(bytes32,bytes32)</TD></TR><TR><TD align="left">    setLoanLiquidated(bytes32)</TD></TR><TR><TD align="left">    removeLiquidatedLoan(bytes32)</TD></TR><TR><TD align="left">    isExpiredOrReadyForLiquidation(bytes32)</TD></TR><TR><TD align="left">    setCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    getRepaidPrincipalAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getRepaidInterestAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    setCompletedLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestLoan(bytes32,bool)</TD></TR><TR><TD align="left">    getManualInterestAmountLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestAmountLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    getAgreement(bytes32)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getAgreementId(InventoryLoanRegistry.Entry,address,uint256)</TD></TR><TR><TD align="left">    _evaluateCollateralRatio(bytes32,uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonNullBeneficiary(address)</TD></TR><TR><TD align="left">    onlyExtantEntry(bytes32)</TD></TR><TR><TD align="left">    onlyAuthorizedToEdit()</TD></TR><TR><TD align="left">    onlyPriceFeedOperator(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    entries</TD></TR><TR><TD align="left">    registryToInvoice</TD></TR><TR><TD align="left">    waitingSellCollateral</TD></TR><TR><TD align="left">    waitingSellCollateralExisted</TD></TR><TR><TD align="left">    liquidatedLoan</TD></TR><TR><TD align="left">    completedRepayment</TD></TR><TR><TD align="left">    repaidPrincipalAmount</TD></TR><TR><TD align="left">    repaidInterestAmount</TD></TR><TR><TD align="left">    completedLoans</TD></TR><TR><TD align="left">    manualInterestLoan</TD></TR><TR><TD align="left">    INSERT_CONTEXT</TD></TR><TR><TD align="left">    EDIT_CONTEXT</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    debtorToDebts</TD></TR><TR><TD align="left">    manualInterestAmountLoan</TD></TR></TABLE> >];

InventoryLoanRepaymentRouter -> PausableUpgradeable [ label="1" ];
InventoryLoanRepaymentRouter -> OwnableUpgradeable [ label="2" ];
InventoryLoanRepaymentRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryLoanRepaymentRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    _doRepay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    repay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _assertRepaymentRequest(bytes32,address,uint256,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

CRDecisionEngine -> SignaturesLib;
CRDecisionEngine[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CRDecisionEngine</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _computeCR(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _computeInvoiceCR(uint256,uint256)</TD></TR><TR><TD align="left">    _verifyPrice(uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    PRICE_PRECISION</TD></TR><TR><TD align="left">    CR_PRECISION</TD></TR><TR><TD align="left">    MAX_PRICE_TTL_IN_SECONDS</TD></TR><TR><TD align="left">    COLLATERAL_PRECISION</TD></TR><TR><TD align="left">    PRINCIPAL_PRECISION</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    MAX_UINT256</TD></TR></TABLE> >];

InvoiceCollateralizer -> Initializable [ label="1" ];
InvoiceCollateralizer -> PausableUpgradeable [ label="2" ];
InvoiceCollateralizer -> AccessControlEnumerableUpgradeable [ label="3" ];
InvoiceCollateralizer -> IERC721ReceiverUpgradeable [ label="4" ];
InvoiceCollateralizer[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceCollateralizer</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    collateralizeERC721(bytes32,address)</TD></TR><TR><TD align="left">    additionERC721Collateralize(bytes32,address,bytes32,address)</TD></TR><TR><TD align="left">    withdrawERC721Collateralize(bytes32,address,bytes32,address)</TD></TR><TR><TD align="left">    returnInvoiceCollateral(bytes32)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left">    timestampAdjustedForGracePeriod(uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    retrieveInvoiceCollateralParameters(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyPermissionedInvoiceTermContract(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    COLLATERALIZER</TD></TR><TR><TD align="left">    agreementToCollateralizer</TD></TR><TR><TD align="left">    SECONDS_IN_DAY</TD></TR><TR><TD align="left">    CONTEXT</TD></TR><TR><TD align="left">    CONTEXT_COLLATERAL_SALE</TD></TR></TABLE> >];

InvoiceDebtRegistry -> Initializable [ label="1" ];
InvoiceDebtRegistry -> PausableUpgradeable [ label="2" ];
InvoiceDebtRegistry -> OwnableUpgradeable [ label="3" ];
InvoiceDebtRegistry -> CRDecisionEngine [ label="4" ];
InvoiceDebtRegistry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceDebtRegistry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    insert(address,address,address,address,address,bytes32,bytes32[],uint256[3])</TD></TR><TR><TD align="left">    updateLoanTermParameters(bytes32,bytes32)</TD></TR><TR><TD align="left">    setMinCollateralRatio(bytes32,uint256)</TD></TR><TR><TD align="left">    modifyBeneficiary(bytes32,address)</TD></TR><TR><TD align="left">    selfEvaluateCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    updateLastRepaymentTimestamp(bytes32,uint256)</TD></TR><TR><TD align="left">    doesEntryExist(bytes32)</TD></TR><TR><TD align="left">    getBeneficiary(bytes32)</TD></TR><TR><TD align="left">    getDebtor(bytes32)</TD></TR><TR><TD align="left">    getTerms(bytes32)</TD></TR><TR><TD align="left">    getInvoiceTokenIds(bytes32)</TD></TR><TR><TD align="left">    insertInvoiceFinancedToInvoiceLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    removeInvoiceId(bytes32,uint256)</TD></TR><TR><TD align="left">    _getTotalInvoiceAmount(bytes32)</TD></TR><TR><TD align="left">    getTermsContract(bytes32)</TD></TR><TR><TD align="left">    getTermsContractParameters(bytes32)</TD></TR><TR><TD align="left">    getIssuanceBlockTimestamp(bytes32)</TD></TR><TR><TD align="left">    getLastRepaymentTimestamp(bytes32)</TD></TR><TR><TD align="left">    getExpirationTimestamp(bytes32)</TD></TR><TR><TD align="left">    get(bytes32)</TD></TR><TR><TD align="left">    getCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    getMinCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    isCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    setCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    getRepaidPrincipalAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getRepaidInterestAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    isCompletedLoan(bytes32)</TD></TR><TR><TD align="left">    setCompletedLoan(bytes32)</TD></TR><TR><TD align="left">    isManualInterestLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestLoan(bytes32,bool)</TD></TR><TR><TD align="left">    getManualInterestAmountLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestAmountLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    getAgreement(bytes32)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getAgreementId(InvoiceDebtRegistry.Entry,address,uint256)</TD></TR><TR><TD align="left">    _evaluateCollateralRatio(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonNullBeneficiary(address)</TD></TR><TR><TD align="left">    onlyExtantEntry(bytes32)</TD></TR><TR><TD align="left">    onlyAuthorizedToEdit()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    completedRepayment</TD></TR><TR><TD align="left">    repaidPrincipalAmount</TD></TR><TR><TD align="left">    repaidInterestAmount</TD></TR><TR><TD align="left">    completedLoans</TD></TR><TR><TD align="left">    manualInterestLoan</TD></TR><TR><TD align="left">    manualInterestAmountLoan</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    entries</TD></TR><TR><TD align="left">    registryToInvoice</TD></TR><TR><TD align="left">    debtorToDebts</TD></TR></TABLE> >];

InvoiceFinanceInterestTermsContract -> PausableUpgradeable [ label="1" ];
InvoiceFinanceInterestTermsContract -> OwnableUpgradeable [ label="2" ];
InvoiceFinanceInterestTermsContract -> CRDecisionEngine [ label="3" ];
InvoiceFinanceInterestTermsContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceFinanceInterestTermsContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    registerInvoiceLoanTermStart(bytes32,address)</TD></TR><TR><TD align="left">    registerRepayment(bytes32,address,address,uint256,address)</TD></TR><TR><TD align="left">    registerSecureLoanWithInvoice(bytes32,address,address,bytes32[])</TD></TR><TR><TD align="left">    registerInsecureLoanByWithdrawInvoice(bytes32,address,address,bytes32[])</TD></TR><TR><TD align="left">    registerConcludeInvoiceLoan(bytes32)</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(bytes32,uint256)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    isTermsContractExpired(bytes32)</TD></TR><TR><TD align="left">    registerDrawdownLoan(bytes32,uint256,bytes32)</TD></TR><TR><TD align="left">    getTotalExpectedRepaymentValue(bytes32,uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _unpackParamsForAgreementID(bytes32)</TD></TR><TR><TD align="left">    _getAmortizationUnitLengthInSeconds(InvoiceFinanceInterestTermsContract.AmortizationUnitType)</TD></TR><TR><TD align="left">    _getExpectedRepaymentValuesToTimestamp(InvoiceFinanceInterestTermsContract.InterestParams,uint256,uint256,uint256,uint256,bool,uint256)</TD></TR><TR><TD align="left">    _calculateInterestForDuration(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getStartDateInTimestamp(uint256)</TD></TR><TR><TD align="left">    _calculateInterestAmountToTimestamp(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _validateNewTermsContractParamsDrawdown(bytes32,bytes32,uint256)</TD></TR><TR><TD align="left">    _validateNewCollateralRatioWhenDrawdown(bytes32,uint256,InvoiceDebtRegistry)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRouter()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NUM_AMORTIZATION_UNIT_TYPES</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    WEEK_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    MONTH_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_MULTIPLIER</TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

InvoiceLoanKernel -> PausableUpgradeable [ label="1" ];
InvoiceLoanKernel -> OwnableUpgradeable [ label="2" ];
InvoiceLoanKernel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceLoanKernel</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    concludeLoan(address,address,bytes32,address)</TD></TR><TR><TD align="left">    cancelDebtOrder(address[5],uint256[6],bytes32[])</TD></TR><TR><TD align="left">    cancelIssuance(address,address,address,bytes32,bytes32[],uint256)</TD></TR><TR><TD align="left">    fillDebtOrder(address,address[5],uint256[6],bytes32[],uint8[2],bytes32[2],bytes32[2],address[10],uint256[10])</TD></TR><TR><TD align="left">    drawdownLoan(bytes32,uint256,bytes32,uint8[2],bytes32[2],bytes32[2])</TD></TR><TR><TD align="left">    secureLoanWithInvoice(bytes32,address,address,address,bytes32[])</TD></TR><TR><TD align="left">    insecureLoanByWithdrawInvoice(bytes32,address,address,bytes32[])</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getDebtOrderHash(InvoiceLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    getInvoiceTokenIds(bytes32[])</TD></TR><TR><TD align="left">    _getDebtOrder(address[5],uint256[6],bytes32[])</TD></TR><TR><TD align="left">    _getAgreementId(address,address,address,uint256,bytes32)</TD></TR><TR><TD align="left">    _getIssuance(address,address,address,uint256,bytes32,bytes32[])</TD></TR><TR><TD align="left">    _burnLoanAssetToken(bytes32)</TD></TR><TR><TD align="left">    _getBalance(address,address)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _assertDebtOrderValidityInvariants(InvoiceLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _assertDebtExisting(bytes32)</TD></TR><TR><TD align="left">    _assertCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    _concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left">    _transferFeesToBeneficiaries(address,address,address,address[5],uint256[5])</TD></TR><TR><TD align="left">    _sumTotalFees(uint256[5])</TD></TR><TR><TD align="left">    getDebtorCreditorFeeBeneficiaries(address[10],bool)</TD></TR><TR><TD align="left">    getDebtorCreditorFeeAmounts(uint256[10],bool)</TD></TR><TR><TD align="left">    _transferTokensLoanIssuance(InvoiceLoanKernel.DebtOrder,address,address[10],uint256[10])</TD></TR><TR><TD align="left">    _issueDebtAgreement(address,InvoiceLoanKernel.DebtOrder)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NULL_ISSUANCE_HASH</TD></TR><TR><TD align="left">    EXTERNAL_QUERY_GAS_LIMIT</TD></TR><TR><TD align="left">    issuanceCancelled</TD></TR><TR><TD align="left">    debtOrderCancelled</TD></TR><TR><TD align="left">    debtOrderCompleted</TD></TR><TR><TD align="left">    agreementToLiability</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

InvoiceLoanRepaymentRouter -> PausableUpgradeable [ label="1" ];
InvoiceLoanRepaymentRouter -> OwnableUpgradeable [ label="2" ];
InvoiceLoanRepaymentRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceLoanRepaymentRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    repayFromInvoicePayment(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    repay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _assertRepaymentRequest(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    _doRepay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

MintedIncreasingInterestTGE -> IncreasingInterestCrowdsale [ label="1" ];
MintedIncreasingInterestTGE -> LongSaleInterest [ label="2" ];
MintedIncreasingInterestTGE[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MintedIncreasingInterestTGE</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,address,address,address,bool)</TD></TR><TR><TD align="left"><font color="#FFA500">    isLongSale()</font></TD></TR><TR><TD align="left">    setYield(uint256)</TD></TR><TR><TD align="left">    setupLongSale(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getLongSaleTokenPrice(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getLongSaleTokenAmount(uint256)</font></TD></TR><TR><TD align="left">    startNewRoundSale(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _preValidateNewSaleRound()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    longSale</TD></TR><TR><TD align="left">    timeStartEarningInterest</TD></TR><TR><TD align="left">    termLengthInSeconds</TD></TR><TR><TD align="left">    interestRate</TD></TR><TR><TD align="left">    yield</TD></TR></TABLE> >];

MintedNormalTGE -> FinalizableCrowdsale [ label="1" ];
MintedNormalTGE -> LongSaleInterest [ label="2" ];
MintedNormalTGE[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MintedNormalTGE</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,address,address,address,bool)</TD></TR><TR><TD align="left"><font color="#FFA500">    isLongSale()</font></TD></TR><TR><TD align="left">    setYield(uint256)</TD></TR><TR><TD align="left">    setupLongSale(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getLongSaleTokenPrice(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getLongSaleTokenAmount(uint256)</font></TD></TR><TR><TD align="left">    startNewRoundSale(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _preValidateNewSaleRound()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    longSale</TD></TR><TR><TD align="left">    timeStartEarningInterest</TD></TR><TR><TD align="left">    termLengthInSeconds</TD></TR><TR><TD align="left">    interestRate</TD></TR><TR><TD align="left">    yield</TD></TR></TABLE> >];

LongSaleInterest[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LongSaleInterest</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getPurchasePrice(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    PURCHASE_PRICE_SCALING_FACTOR</TD></TR></TABLE> >];

Crowdsale -> UntangledBase;
Crowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Crowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    addFunding(uint256)</TD></TR><TR><TD align="left">    buyTokens(address,address,uint256)</TD></TR><TR><TD align="left">    isDistributedFully()</TD></TR><TR><TD align="left">    getTokenRemainAmount()</TD></TR><TR><TD align="left">    getCurrencyRemainAmount()</TD></TR><TR><TD align="left">    isLongSale()</TD></TR><TR><TD align="left">    getLongSaleTokenAmount(uint256)</TD></TR><TR><TD align="left">    _getTokenAmount(uint256)</TD></TR><TR><TD align="left">    totalCapReached()</TD></TR><TR><TD align="left">    isUnderTotalCap(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Crowdsale__init(Registry,address,address,address)</TD></TR><TR><TD align="left">    _newSaleRound(uint256)</TD></TR><TR><TD align="left">    _defaultPreValidatePurchase(address,uint256,uint256)</TD></TR><TR><TD align="left">    _preValidatePurchase(address,uint256,uint256)</TD></TR><TR><TD align="left">    _deliverTokens(address,uint256)</TD></TR><TR><TD align="left">    _ejectTokens(uint256)</TD></TR><TR><TD align="left">    _processPurchase(address,uint256)</TD></TR><TR><TD align="left">    _claimPayment(address,uint256)</TD></TR><TR><TD align="left">    _getCurrencyAmount(uint256)</TD></TR><TR><TD align="left">    _forwardFunds(address,uint256)</TD></TR><TR><TD align="left">    _setTotalCap(uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    securitizationPoolRestricted()</TD></TR><TR><TD align="left">    smpRestricted()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    RATE_SCALING_FACTOR</TD></TR><TR><TD align="left">    pool</TD></TR><TR><TD align="left">    token</TD></TR><TR><TD align="left">    currency</TD></TR><TR><TD align="left">    rate</TD></TR><TR><TD align="left">    hasStarted</TD></TR><TR><TD align="left">    currencyRaised</TD></TR><TR><TD align="left">    tokenRaised</TD></TR><TR><TD align="left">    totalCap</TD></TR><TR><TD align="left">    currencyRaisedByInvestor</TD></TR></TABLE> >];

FinalizableCrowdsale -> TimedCrowdsale;
FinalizableCrowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>FinalizableCrowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    finalize(bool,address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _finalization()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    finalized</TD></TR></TABLE> >];

IncreasingInterestCrowdsale -> FinalizableCrowdsale;
IncreasingInterestCrowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IncreasingInterestCrowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    setInterestRange(uint32,uint32,uint32,uint32)</TD></TR><TR><TD align="left">    getCurrentInterest()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _finalization()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _preValidatePurchase(address,uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    initialInterest</TD></TR><TR><TD align="left">    finalInterest</TD></TR><TR><TD align="left">    timeInterval</TD></TR><TR><TD align="left">    amountChangeEachInterval</TD></TR><TR><TD align="left">    pickedInterest</TD></TR></TABLE> >];

TimedCrowdsale -> Crowdsale;
TimedCrowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TimedCrowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    isOpen()</TD></TR><TR><TD align="left">    hasClosed()</TD></TR><TR><TD align="left">    extendTime(uint256)</TD></TR><TR><TD align="left">    newSaleRoundTime(uint256,uint256)</TD></TR><TR><TD align="left">    setUsingTimeLimit(bool)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __TimedCrowdsale__init(Registry,address,address,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyWhileOpen()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    openingTime</TD></TR><TR><TD align="left">    closingTime</TD></TR><TR><TD align="left">    isEnableTimeLimit</TD></TR></TABLE> >];

SecuritizationPool -> ISecuritizationPool [ label="1" ];
SecuritizationPool -> IERC721ReceiverUpgradeable [ label="2" ];
SecuritizationPool[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SecuritizationPool</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    initialize(Registry,address,uint32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getNFTAssetsLength()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTokenAssetAddresses()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTokenAssetAddressesLength()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRiskScoresLength()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isClosedState()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasFinishedRedemption()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setPot(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setupRiskScores(uint32[],uint32[],uint32[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    exportAssets(address,address,uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    withdrawAssets(address[],uint256[],address[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    collectAssets(address,address,uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    collectERC20Assets(address[],address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    withdrawERC20Assets(address[],address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    claimERC20Assets(address[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    claimCashRemain(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    injectTGEAddress(address,address,Configuration.NOTE_TOKEN_TYPE)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    startCycle(uint64,uint256,uint32,uint64)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setInterestRateForSOT(uint32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    increaseLockedDistributeBalance(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    decreaseLockedDistributeBalance(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    increaseTotalAssetRepaidCurrency(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    redeem(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _removeNFTAsset(address,uint256)</TD></TR><TR><TD align="left">    _removeNFTAssetIndex(uint256)</TD></TR><TR><TD align="left">    _pushTokenAssetAddress(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyIssuingTokenStage()</TD></TR><TR><TD align="left">    notClosingStage()</TD></TR><TR><TD align="left">    finishRedemptionValidator()</TD></TR><TR><TD align="left">    onlySecuritizationManager()</TD></TR><TR><TD align="left">    onlyDistributionOperator()</TD></TR><TR><TD align="left">    onlyLoanRepaymentRouter()</TD></TR></TABLE> >];

Registry -> UntangledBase;
Registry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Registry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize()</TD></TR><TR><TD align="left">    getAddress(uint8)</TD></TR><TR><TD align="left">    setSecuritizationManager(address)</TD></TR><TR><TD align="left">    setSecuritizationPool(address)</TD></TR><TR><TD align="left">    setNoteTokenFactory(address)</TD></TR><TR><TD align="left">    setTokenGenerationEventFactory(address)</TD></TR><TR><TD align="left">    setMintedIncreasingInterestTGE(address)</TD></TR><TR><TD align="left">    setMintedNormalTGE(address)</TD></TR><TR><TD align="left">    setDistributionOperator(address)</TD></TR><TR><TD align="left">    setDistributionAssessor(address)</TD></TR><TR><TD align="left">    setLoanAssetToken(address)</TD></TR><TR><TD align="left">    setAcceptedInvoiceToken(address)</TD></TR><TR><TD align="left">    setDistributionTranche(address)</TD></TR><TR><TD align="left">    setSecuritizationPoolValueService(address)</TD></TR><TR><TD align="left">    setLoanRegistry(address)</TD></TR><TR><TD align="left">    setLoanInterestTermsContract(address)</TD></TR><TR><TD align="left">    setLoanRepaymentRouter(address)</TD></TR><TR><TD align="left">    setLoanKernel(address)</TD></TR><TR><TD align="left">    setCollateralManagementToken(address)</TD></TR><TR><TD align="left">    setSupplyChainManagementProgram(address)</TD></TR><TR><TD align="left">    setInventoryLoanKernel(address)</TD></TR><TR><TD align="left">    setInventoryLoanRegistry(address)</TD></TR><TR><TD align="left">    setInventoryLoanRepaymentRouter(address)</TD></TR><TR><TD align="left">    setInventoryInterestTermsContract(address)</TD></TR><TR><TD align="left">    setInventoryCollateralizer(address)</TD></TR><TR><TD align="left">    setInvoiceLoanKernel(address)</TD></TR><TR><TD align="left">    setInvoiceDebtRegistry(address)</TD></TR><TR><TD align="left">    setInvoiceLoanRepaymentRouter(address)</TD></TR><TR><TD align="left">    setInvoiceFinanceInterestTermsContract(address)</TD></TR><TR><TD align="left">    setInvoiceCollateralizer(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setAddress(uint8,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    contractAddresses</TD></TR></TABLE> >];

CollateralManagementToken -> ERC1155PresetMinterPauserUpgradeable [ label="1" ];
CollateralManagementToken -> ERC1155SupplyUpgradeable [ label="2" ];
CollateralManagementToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CollateralManagementToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(address,string,string,uint8,string)</TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    decimals()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left">    totalSupplyOfBatch(uint256[])</TD></TR><TR><TD align="left">    balanceOfProjects(address,uint256[])</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR><TR><TD align="left">    _decimals</TD></TR></TABLE> >];

NoteToken -> INoteToken;
NoteToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>NoteToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR></TABLE> >];

AcceptedInvoiceToken -> IUntangledERC721;
AcceptedInvoiceToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AcceptedInvoiceToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,string,string,string)</TD></TR><TR><TD align="left">    createBatch(address[],uint256[],address[],uint256[],uint256[],uint8[])</TD></TR><TR><TD align="left">    payInBatch(uint256[],uint256[])</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(uint256,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getTotalExpectedRepaymentValue(uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getExpirationTimestamp(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getInterestRate(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAssetPurpose(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRiskScore(uint256)</font></TD></TR><TR><TD align="left">    getFiatAmount(uint256)</TD></TR><TR><TD align="left">    isPaid(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _generateEntryHash(address,address,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _createAIT(address,address,uint256,address,uint256,uint256,uint8,Configuration.ASSET_PURPOSE)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    INVOICE_CREATOR_ROLE</TD></TR><TR><TD align="left">    entries</TD></TR></TABLE> >];

AccessControlEnumerableUpgradeable -> Initializable [ label="1" ];
AccessControlEnumerableUpgradeable -> IAccessControlEnumerableUpgradeable [ label="2" ];
AccessControlEnumerableUpgradeable -> AccessControlUpgradeable [ label="3" ];
AccessControlEnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControlEnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMember(bytes32,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMemberCount(bytes32)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __AccessControlEnumerable_init()</TD></TR><TR><TD align="left">    __AccessControlEnumerable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _roleMembers</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'hasRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'getRoleAdmin(bytes32)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'grantRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'revokeRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.<BR/>'renounceRole(bytes32,address)' collides in inherited contracts IAccessControlUpgradeable, AccessControlUpgradeable where AccessControlUpgradeable is chosen.</font></TD></TR></TABLE> >];

AccessControlUpgradeable -> Initializable [ label="1" ];
AccessControlUpgradeable -> ContextUpgradeable [ label="2" ];
AccessControlUpgradeable -> IAccessControlUpgradeable [ label="3" ];
AccessControlUpgradeable -> ERC165Upgradeable [ label="4" ];
AccessControlUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControlUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __AccessControl_init()</TD></TR><TR><TD align="left">    __AccessControl_init_unchained()</TD></TR><TR><TD align="left">    _checkRole(bytes32)</TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

IAccessControlEnumerableUpgradeable -> IAccessControlUpgradeable;
IAccessControlEnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControlEnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getRoleMember(bytes32,uint256)</TD></TR><TR><TD align="left">    getRoleMemberCount(bytes32)</TD></TR></TABLE> >];

IAccessControlUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControlUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

OwnableUpgradeable -> Initializable [ label="1" ];
OwnableUpgradeable -> ContextUpgradeable [ label="2" ];
OwnableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>OwnableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Ownable_init()</TD></TR><TR><TD align="left">    __Ownable_init_unchained()</TD></TR><TR><TD align="left">    _checkOwner()</TD></TR><TR><TD align="left">    _transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

Initializable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Initializable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _disableInitializers()</TD></TR><TR><TD align="left">    _getInitializedVersion()</TD></TR><TR><TD align="left">    _isInitializing()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    initializer()</TD></TR><TR><TD align="left">    reinitializer(uint8)</TD></TR><TR><TD align="left">    onlyInitializing()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _initialized</TD></TR><TR><TD align="left">    _initializing</TD></TR></TABLE> >];

PausableUpgradeable -> Initializable [ label="1" ];
PausableUpgradeable -> ContextUpgradeable [ label="2" ];
PausableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>PausableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    paused()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Pausable_init()</TD></TR><TR><TD align="left">    __Pausable_init_unchained()</TD></TR><TR><TD align="left">    _requireNotPaused()</TD></TR><TR><TD align="left">    _requirePaused()</TD></TR><TR><TD align="left">    _pause()</TD></TR><TR><TD align="left">    _unpause()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    whenNotPaused()</TD></TR><TR><TD align="left">    whenPaused()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _paused</TD></TR></TABLE> >];

ReentrancyGuardUpgradeable -> Initializable;
ReentrancyGuardUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ReentrancyGuardUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ReentrancyGuard_init()</TD></TR><TR><TD align="left">    __ReentrancyGuard_init_unchained()</TD></TR><TR><TD align="left">    _nonReentrantBefore()</TD></TR><TR><TD align="left">    _nonReentrantAfter()</TD></TR><TR><TD align="left">    _reentrancyGuardEntered()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonReentrant()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _NOT_ENTERED</TD></TR><TR><TD align="left">    _ENTERED</TD></TR><TR><TD align="left">    _status</TD></TR><TR><TD align="left">    __gap</TD></TR></TABLE> >];

ERC1155Upgradeable -> Initializable [ label="1" ];
ERC1155Upgradeable -> ContextUpgradeable [ label="2" ];
ERC1155Upgradeable -> ERC165Upgradeable [ label="3" ];
ERC1155Upgradeable -> IERC1155Upgradeable [ label="4" ];
ERC1155Upgradeable -> IERC1155MetadataURIUpgradeable [ label="5" ];
ERC1155Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    uri(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOfBatch(address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155_init(string)</TD></TR><TR><TD align="left">    __ERC1155_init_unchained(string)</TD></TR><TR><TD align="left">    _safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _setURI(string)</TD></TR><TR><TD align="left">    _mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    _burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _doSafeTransferAcceptanceCheck(address,address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _doSafeBatchTransferAcceptanceCheck(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _asSingletonArray(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR><TR><TD align="left">    _uri</TD></TR></TABLE> >];

IERC1155ReceiverUpgradeable -> IERC165Upgradeable;
IERC1155ReceiverUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155ReceiverUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC1155Received(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

IERC1155Upgradeable -> IERC165Upgradeable;
IERC1155Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address,uint256)</TD></TR><TR><TD align="left">    balanceOfBatch(address[],uint256[])</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

ERC1155BurnableUpgradeable -> Initializable [ label="1" ];
ERC1155BurnableUpgradeable -> ERC1155Upgradeable [ label="2" ];
ERC1155BurnableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155BurnableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155Burnable_init()</TD></TR><TR><TD align="left">    __ERC1155Burnable_init_unchained()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC1155PausableUpgradeable -> Initializable [ label="1" ];
ERC1155PausableUpgradeable -> ERC1155Upgradeable [ label="2" ];
ERC1155PausableUpgradeable -> PausableUpgradeable [ label="3" ];
ERC1155PausableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155PausableUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155Pausable_init()</TD></TR><TR><TD align="left">    __ERC1155Pausable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC1155SupplyUpgradeable -> Initializable [ label="1" ];
ERC1155SupplyUpgradeable -> ERC1155Upgradeable [ label="2" ];
ERC1155SupplyUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155SupplyUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply(uint256)</TD></TR><TR><TD align="left">    exists(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155Supply_init()</TD></TR><TR><TD align="left">    __ERC1155Supply_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _totalSupply</TD></TR></TABLE> >];

IERC1155MetadataURIUpgradeable -> IERC1155Upgradeable;
IERC1155MetadataURIUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155MetadataURIUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    uri(uint256)</TD></TR></TABLE> >];

ERC1155PresetMinterPauserUpgradeable -> Initializable [ label="1" ];
ERC1155PresetMinterPauserUpgradeable -> ContextUpgradeable [ label="2" ];
ERC1155PresetMinterPauserUpgradeable -> AccessControlEnumerableUpgradeable [ label="3" ];
ERC1155PresetMinterPauserUpgradeable -> ERC1155BurnableUpgradeable [ label="4" ];
ERC1155PresetMinterPauserUpgradeable -> ERC1155PausableUpgradeable [ label="5" ];
ERC1155PresetMinterPauserUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155PresetMinterPauserUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(string)</TD></TR><TR><TD align="left">    mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155PresetMinterPauser_init(string)</TD></TR><TR><TD align="left">    __ERC1155PresetMinterPauser_init_unchained(string)</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC1155ReceiverUpgradeable -> Initializable [ label="1" ];
ERC1155ReceiverUpgradeable -> ERC165Upgradeable [ label="2" ];
ERC1155ReceiverUpgradeable -> IERC1155ReceiverUpgradeable [ label="3" ];
ERC1155ReceiverUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155ReceiverUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC1155Receiver_init()</TD></TR><TR><TD align="left">    __ERC1155Receiver_init_unchained()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC721Upgradeable -> Initializable [ label="1" ];
ERC721Upgradeable -> ContextUpgradeable [ label="2" ];
ERC721Upgradeable -> ERC165Upgradeable [ label="3" ];
ERC721Upgradeable -> IERC721Upgradeable [ label="4" ];
ERC721Upgradeable -> IERC721MetadataUpgradeable [ label="5" ];
ERC721Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    ownerOf(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenURI(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getApproved(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721_init(string,string)</TD></TR><TR><TD align="left">    __ERC721_init_unchained(string,string)</TD></TR><TR><TD align="left">    _baseURI()</TD></TR><TR><TD align="left">    _safeTransfer(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _ownerOf(uint256)</TD></TR><TR><TD align="left">    _exists(uint256)</TD></TR><TR><TD align="left">    _isApprovedOrOwner(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256,bytes)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(uint256)</TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _approve(address,uint256)</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _requireMinted(uint256)</TD></TR><TR><TD align="left">    _checkOnERC721Received(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    __unsafe_increaseBalance(address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR><TR><TD align="left">    _owners</TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _tokenApprovals</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR></TABLE> >];

IERC721ReceiverUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721ReceiverUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC721Received(address,address,uint256,bytes)</TD></TR></TABLE> >];

IERC721Upgradeable -> IERC165Upgradeable;
IERC721Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    ownerOf(uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    getApproved(uint256)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR></TABLE> >];

ERC721BurnableUpgradeable -> Initializable [ label="1" ];
ERC721BurnableUpgradeable -> ContextUpgradeable [ label="2" ];
ERC721BurnableUpgradeable -> ERC721Upgradeable [ label="3" ];
ERC721BurnableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721BurnableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721Burnable_init()</TD></TR><TR><TD align="left">    __ERC721Burnable_init_unchained()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

ERC721EnumerableUpgradeable -> Initializable [ label="1" ];
ERC721EnumerableUpgradeable -> ERC721Upgradeable [ label="2" ];
ERC721EnumerableUpgradeable -> IERC721EnumerableUpgradeable [ label="3" ];
ERC721EnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721EnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenOfOwnerByIndex(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenByIndex(uint256)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721Enumerable_init()</TD></TR><TR><TD align="left">    __ERC721Enumerable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left">    _addTokenToOwnerEnumeration(address,uint256)</TD></TR><TR><TD align="left">    _addTokenToAllTokensEnumeration(uint256)</TD></TR><TR><TD align="left">    _removeTokenFromOwnerEnumeration(address,uint256)</TD></TR><TR><TD align="left">    _removeTokenFromAllTokensEnumeration(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _ownedTokens</TD></TR><TR><TD align="left">    _ownedTokensIndex</TD></TR><TR><TD align="left">    _allTokens</TD></TR><TR><TD align="left">    _allTokensIndex</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'balanceOf(address)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'ownerOf(uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'safeTransferFrom(address,address,uint256,bytes)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'safeTransferFrom(address,address,uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'transferFrom(address,address,uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'approve(address,uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'setApprovalForAll(address,bool)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'getApproved(uint256)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.<BR/>'isApprovedForAll(address,address)' collides in inherited contracts IERC721Upgradeable, ERC721Upgradeable where ERC721Upgradeable is chosen.</font></TD></TR></TABLE> >];

ERC721PausableUpgradeable -> Initializable [ label="1" ];
ERC721PausableUpgradeable -> ERC721Upgradeable [ label="2" ];
ERC721PausableUpgradeable -> PausableUpgradeable [ label="3" ];
ERC721PausableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721PausableUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721Pausable_init()</TD></TR><TR><TD align="left">    __ERC721Pausable_init_unchained()</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR></TABLE> >];

IERC721EnumerableUpgradeable -> IERC721Upgradeable;
IERC721EnumerableUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721EnumerableUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    tokenOfOwnerByIndex(address,uint256)</TD></TR><TR><TD align="left">    tokenByIndex(uint256)</TD></TR></TABLE> >];

IERC721MetadataUpgradeable -> IERC721Upgradeable;
IERC721MetadataUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721MetadataUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    tokenURI(uint256)</TD></TR></TABLE> >];

ERC721PresetMinterPauserAutoIdUpgradeable -> Initializable [ label="1" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ContextUpgradeable [ label="2" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> AccessControlEnumerableUpgradeable [ label="3" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ERC721EnumerableUpgradeable [ label="4" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ERC721BurnableUpgradeable [ label="5" ];
ERC721PresetMinterPauserAutoIdUpgradeable -> ERC721PausableUpgradeable [ label="6" ];
ERC721PresetMinterPauserAutoIdUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721PresetMinterPauserAutoIdUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(string,string,string)</TD></TR><TR><TD align="left">    mint(address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC721PresetMinterPauserAutoId_init(string,string,string)</TD></TR><TR><TD align="left">    __ERC721PresetMinterPauserAutoId_init_unchained(string,string,string)</TD></TR><TR><TD align="left"><font color="#FFA500">    _baseURI()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left"><font color="red">    __gap</font></TD></TR><TR><TD align="left">    _tokenIdTracker</TD></TR><TR><TD align="left">    _baseTokenURI</TD></TR></TABLE> >];

AddressUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AddressUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResultFromTarget(address,bool,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR><TR><TD align="left">    _revert(bytes,string)</TD></TR></TABLE> >];

ContextUpgradeable -> Initializable;
ContextUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ContextUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Context_init()</TD></TR><TR><TD align="left">    __Context_init_unchained()</TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    __gap</TD></TR></TABLE> >];

CountersUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CountersUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    current(CountersUpgradeable.Counter)</TD></TR><TR><TD align="left">    increment(CountersUpgradeable.Counter)</TD></TR><TR><TD align="left">    decrement(CountersUpgradeable.Counter)</TD></TR><TR><TD align="left">    reset(CountersUpgradeable.Counter)</TD></TR></TABLE> >];

StringsUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>StringsUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toString(int256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left">    toHexString(address)</TD></TR><TR><TD align="left">    equal(string,string)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _SYMBOLS</TD></TR><TR><TD align="left">    _ADDRESS_LENGTH</TD></TR></TABLE> >];

ERC165Upgradeable -> Initializable [ label="1" ];
ERC165Upgradeable -> IERC165Upgradeable [ label="2" ];
ERC165Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __ERC165_init()</TD></TR><TR><TD align="left">    __ERC165_init_unchained()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    __gap</TD></TR></TABLE> >];

IERC165Upgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165Upgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

MathUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MathUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(uint256,uint256)</TD></TR><TR><TD align="left">    min(uint256,uint256)</TD></TR><TR><TD align="left">    average(uint256,uint256)</TD></TR><TR><TD align="left">    ceilDiv(uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    sqrt(uint256)</TD></TR><TR><TD align="left">    sqrt(uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    log2(uint256)</TD></TR><TR><TD align="left">    log2(uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    log10(uint256)</TD></TR><TR><TD align="left">    log10(uint256,MathUpgradeable.Rounding)</TD></TR><TR><TD align="left">    log256(uint256)</TD></TR><TR><TD align="left">    log256(uint256,MathUpgradeable.Rounding)</TD></TR></TABLE> >];

SignedMathUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SignedMathUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(int256,int256)</TD></TR><TR><TD align="left">    min(int256,int256)</TD></TR><TR><TD align="left">    average(int256,int256)</TD></TR><TR><TD align="left">    abs(int256)</TD></TR></TABLE> >];

EnumerableSetUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EnumerableSetUpgradeable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _add(EnumerableSetUpgradeable.Set,bytes32)</TD></TR><TR><TD align="left">    _remove(EnumerableSetUpgradeable.Set,bytes32)</TD></TR><TR><TD align="left">    _contains(EnumerableSetUpgradeable.Set,bytes32)</TD></TR><TR><TD align="left">    _length(EnumerableSetUpgradeable.Set)</TD></TR><TR><TD align="left">    _at(EnumerableSetUpgradeable.Set,uint256)</TD></TR><TR><TD align="left">    _values(EnumerableSetUpgradeable.Set)</TD></TR><TR><TD align="left">    add(EnumerableSetUpgradeable.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    remove(EnumerableSetUpgradeable.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    contains(EnumerableSetUpgradeable.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    length(EnumerableSetUpgradeable.Bytes32Set)</TD></TR><TR><TD align="left">    at(EnumerableSetUpgradeable.Bytes32Set,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSetUpgradeable.Bytes32Set)</TD></TR><TR><TD align="left">    add(EnumerableSetUpgradeable.AddressSet,address)</TD></TR><TR><TD align="left">    remove(EnumerableSetUpgradeable.AddressSet,address)</TD></TR><TR><TD align="left">    contains(EnumerableSetUpgradeable.AddressSet,address)</TD></TR><TR><TD align="left">    length(EnumerableSetUpgradeable.AddressSet)</TD></TR><TR><TD align="left">    at(EnumerableSetUpgradeable.AddressSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSetUpgradeable.AddressSet)</TD></TR><TR><TD align="left">    add(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    remove(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    contains(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    length(EnumerableSetUpgradeable.UintSet)</TD></TR><TR><TD align="left">    at(EnumerableSetUpgradeable.UintSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSetUpgradeable.UintSet)</TD></TR></TABLE> >];

AccessControl -> Context [ label="1" ];
AccessControl -> IAccessControl [ label="2" ];
AccessControl -> ERC165 [ label="3" ];
AccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkRole(bytes32)</TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

AccessControlEnumerable -> IAccessControlEnumerable [ label="1" ];
AccessControlEnumerable -> AccessControl [ label="2" ];
AccessControlEnumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControlEnumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMember(bytes32,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMemberCount(bytes32)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roleMembers</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'hasRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'getRoleAdmin(bytes32)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'grantRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'revokeRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'renounceRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.</font></TD></TR></TABLE> >];

IAccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

IAccessControlEnumerable -> IAccessControl;
IAccessControlEnumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControlEnumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getRoleMember(bytes32,uint256)</TD></TR><TR><TD align="left">    getRoleMemberCount(bytes32)</TD></TR></TABLE> >];

Pausable -> Context;
Pausable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Pausable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    paused()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _requireNotPaused()</TD></TR><TR><TD align="left">    _requirePaused()</TD></TR><TR><TD align="left">    _pause()</TD></TR><TR><TD align="left">    _unpause()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    whenNotPaused()</TD></TR><TR><TD align="left">    whenPaused()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _paused</TD></TR></TABLE> >];

ERC1155 -> Context [ label="1" ];
ERC1155 -> ERC165 [ label="2" ];
ERC1155 -> IERC1155 [ label="3" ];
ERC1155 -> IERC1155MetadataURI [ label="4" ];
ERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    uri(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOfBatch(address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _setURI(string)</TD></TR><TR><TD align="left">    _mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    _burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _doSafeTransferAcceptanceCheck(address,address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _doSafeBatchTransferAcceptanceCheck(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _asSingletonArray(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR><TR><TD align="left">    _uri</TD></TR></TABLE> >];

IERC1155 -> IERC165;
IERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address,uint256)</TD></TR><TR><TD align="left">    balanceOfBatch(address[],uint256[])</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

IERC1155Receiver -> IERC165;
IERC1155Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC1155Received(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

ERC1155Burnable -> ERC1155;
ERC1155Burnable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Burnable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    burnBatch(address,uint256[],uint256[])</TD></TR></TABLE> >];

IERC1155MetadataURI -> IERC1155;
IERC1155MetadataURI[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155MetadataURI</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    uri(uint256)</TD></TR></TABLE> >];

ERC20 -> Context [ label="1" ];
ERC20 -> IERC20 [ label="2" ];
ERC20 -> IERC20Metadata [ label="3" ];
ERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transfer(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    allowance(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left">    increaseAllowance(address,uint256)</TD></TR><TR><TD align="left">    decreaseAllowance(address,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(address,uint256)</TD></TR><TR><TD align="left">    _approve(address,address,uint256)</TD></TR><TR><TD align="left">    _spendAllowance(address,address,uint256)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _allowances</TD></TR><TR><TD align="left">    _totalSupply</TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR></TABLE> >];

IERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

ERC20Burnable -> Context [ label="1" ];
ERC20Burnable -> ERC20 [ label="2" ];
ERC20Burnable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Burnable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    burn(uint256)</TD></TR><TR><TD align="left">    burnFrom(address,uint256)</TD></TR></TABLE> >];

ERC20Pausable -> ERC20 [ label="1" ];
ERC20Pausable -> Pausable [ label="2" ];
ERC20Pausable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Pausable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR></TABLE> >];

IERC20Metadata -> IERC20;
IERC20Metadata[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20Metadata</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    decimals()</TD></TR></TABLE> >];

ERC20PresetMinterPauser -> Context [ label="1" ];
ERC20PresetMinterPauser -> AccessControlEnumerable [ label="2" ];
ERC20PresetMinterPauser -> ERC20Burnable [ label="3" ];
ERC20PresetMinterPauser -> ERC20Pausable [ label="4" ];
ERC20PresetMinterPauser[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20PresetMinterPauser</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    mint(address,uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    MINTER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR></TABLE> >];

IERC721 -> IERC165;
IERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    ownerOf(uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    getApproved(uint256)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResultFromTarget(address,bool,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR><TR><TD align="left">    _revert(bytes,string)</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

Strings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Strings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toString(int256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left">    toHexString(address)</TD></TR><TR><TD align="left">    equal(string,string)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _SYMBOLS</TD></TR><TR><TD align="left">    _ADDRESS_LENGTH</TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

Math[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Math</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(uint256,uint256)</TD></TR><TR><TD align="left">    min(uint256,uint256)</TD></TR><TR><TD align="left">    average(uint256,uint256)</TD></TR><TR><TD align="left">    ceilDiv(uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256,Math.Rounding)</TD></TR><TR><TD align="left">    sqrt(uint256)</TD></TR><TR><TD align="left">    sqrt(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log2(uint256)</TD></TR><TR><TD align="left">    log2(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log10(uint256)</TD></TR><TR><TD align="left">    log10(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log256(uint256)</TD></TR><TR><TD align="left">    log256(uint256,Math.Rounding)</TD></TR></TABLE> >];

SafeMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SafeMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    tryAdd(uint256,uint256)</TD></TR><TR><TD align="left">    trySub(uint256,uint256)</TD></TR><TR><TD align="left">    tryMul(uint256,uint256)</TD></TR><TR><TD align="left">    tryDiv(uint256,uint256)</TD></TR><TR><TD align="left">    tryMod(uint256,uint256)</TD></TR><TR><TD align="left">    add(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256)</TD></TR><TR><TD align="left">    mul(uint256,uint256)</TD></TR><TR><TD align="left">    div(uint256,uint256)</TD></TR><TR><TD align="left">    mod(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256,string)</TD></TR><TR><TD align="left">    div(uint256,uint256,string)</TD></TR><TR><TD align="left">    mod(uint256,uint256,string)</TD></TR></TABLE> >];

SignedMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SignedMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(int256,int256)</TD></TR><TR><TD align="left">    min(int256,int256)</TD></TR><TR><TD align="left">    average(int256,int256)</TD></TR><TR><TD align="left">    abs(int256)</TD></TR></TABLE> >];

EnumerableSet[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EnumerableSet</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _add(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _remove(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _contains(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _length(EnumerableSet.Set)</TD></TR><TR><TD align="left">    _at(EnumerableSet.Set,uint256)</TD></TR><TR><TD align="left">    _values(EnumerableSet.Set)</TD></TR><TR><TD align="left">    add(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    remove(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    contains(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    length(EnumerableSet.Bytes32Set)</TD></TR><TR><TD align="left">    at(EnumerableSet.Bytes32Set,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.Bytes32Set)</TD></TR><TR><TD align="left">    add(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    remove(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    contains(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    length(EnumerableSet.AddressSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.AddressSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.AddressSet)</TD></TR><TR><TD align="left">    add(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    remove(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    contains(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    length(EnumerableSet.UintSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.UintSet)</TD></TR></TABLE> >];

Factory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Factory</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    deployMinimal(address)</TD></TR></TABLE> >];

UntangledBase -> Initializable [ label="1" ];
UntangledBase -> PausableUpgradeable [ label="2" ];
UntangledBase -> ReentrancyGuardUpgradeable [ label="3" ];
UntangledBase -> AccessControlEnumerableUpgradeable [ label="4" ];
UntangledBase[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UntangledBase</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __UntangledBase__init(address)</TD></TR><TR><TD align="left">    __UntangledBase__init_unchained(address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    OWNER_ROLE</TD></TR></TABLE> >];

IERCProxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERCProxy</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    proxyType()</TD></TR><TR><TD align="left">    implementation()</TD></TR></TABLE> >];

Proxy -> IERCProxy;
Proxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Proxy</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    proxyType()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    implementation()</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    delegatedFwd(address)</TD></TR></TABLE> >];

UpgradableProxy -> Proxy;
UpgradableProxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UpgradableProxy</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    fallback()</TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left">    proxyOwner()</TD></TR><TR><TD align="left"><font color="#FFA500">    implementation()</font></TD></TR><TR><TD align="left">    transferProxyOwnership(address)</TD></TR><TR><TD align="left">    updateImplementation(address)</TD></TR><TR><TD align="left">    updateAndCall(address,bytes)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    loadProxyOwner()</TD></TR><TR><TD align="left">    loadImplementation()</TD></TR><TR><TD align="left">    setProxyOwner(address)</TD></TR><TR><TD align="left">    setImplementation(address)</TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyProxyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    IMPLEMENTATION_SLOT</TD></TR><TR><TD align="left">    OWNER_SLOT</TD></TR></TABLE> >];

ICrowdSale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ICrowdSale</B></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    currencyRaisedByInvestor</TD></TR><TR><TD align="left">    currencyRaised</TD></TR></TABLE> >];

IDistributionAssessor[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IDistributionAssessor</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getSOTTokenPrice(address,uint256)</TD></TR><TR><TD align="left">    getJOTTokenPrice(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    calcTokenPrice(address,address)</TD></TR><TR><TD align="left">    getCashBalance(address)</TD></TR><TR><TD align="left">    calcAssetValue(address,address,address)</TD></TR><TR><TD align="left">    calcCorrespondingTotalAssetValue(address,address,uint256)</TD></TR></TABLE> >];

IDistributionOperator[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IDistributionOperator</B></TD></TR></TABLE> >];

IDistributionTranche[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IDistributionTranche</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    redeem(address,address,address,uint256,uint256)</TD></TR><TR><TD align="left">    redeemToken(address,address,uint256)</TD></TR></TABLE> >];

ILoanInterestTermsContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanInterestTermsContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    registerTermStart(bytes32)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    isCompletedRepayments(bytes32[])</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(bytes32,uint256)</TD></TR><TR><TD align="left">    getMultiExpectedRepaymentValues(bytes32[],uint256)</TD></TR><TR><TD align="left">    registerConcludeLoan(bytes32)</TD></TR><TR><TD align="left">    registerRepayment(bytes32,address,address,uint256,address)</TD></TR><TR><TD align="left">    getInterestRate(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    startedLoan</TD></TR><TR><TD align="left">    repaidPrincipalAmounts</TD></TR><TR><TD align="left">    repaidInterestAmounts</TD></TR><TR><TD align="left">    completedRepayment</TD></TR></TABLE> >];

ILoanKernel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanKernel</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    NULL_ISSUANCE_HASH</TD></TR><TR><TD align="left">    NULL_COLLATERAL_INFO_HASH</TD></TR><TR><TD align="left">    NULL_ADDRESS</TD></TR><TR><TD align="left">    issuanceCancelled</TD></TR><TR><TD align="left">    debtOrderCancelled</TD></TR><TR><TD align="left">    debtOrderCompleted</TD></TR></TABLE> >];

ILoanRegistry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanRegistry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    insert(bytes32,address,address,bytes32,address,uint256,uint256,uint8[])</TD></TR><TR><TD align="left">    getLoanDebtor(bytes32)</TD></TR><TR><TD align="left">    getLoanTermParams(bytes32)</TD></TR><TR><TD align="left">    getPrincipalTokenAddress(bytes32)</TD></TR><TR><TD align="left">    getDebtor(bytes32)</TD></TR><TR><TD align="left">    getTermContract(bytes32)</TD></TR><TR><TD align="left">    getRiskScore(bytes32)</TD></TR><TR><TD align="left">    getAssetPurpose(bytes32)</TD></TR><TR><TD align="left">    getIssuanceBlockTimestamp(bytes32)</TD></TR><TR><TD align="left">    getLastRepaymentTimestamp(bytes32)</TD></TR><TR><TD align="left">    getTermsContractParameters(bytes32)</TD></TR><TR><TD align="left">    getExpirationTimestamp(bytes32)</TD></TR><TR><TD align="left">    updateLastRepaymentTimestamp(bytes32,uint256)</TD></TR><TR><TD align="left">    principalPaymentInfo(bytes32)</TD></TR><TR><TD align="left">    setCompletedLoan(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    entries</TD></TR><TR><TD align="left">    manualInterestLoan</TD></TR><TR><TD align="left">    manualInterestAmountLoan</TD></TR><TR><TD align="left">    completedLoans</TD></TR></TABLE> >];

ILoanRepaymentRouter -> UntangledBase;
ILoanRepaymentRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ILoanRepaymentRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    repayInBatch(bytes32[],uint256[],address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

IMintedIncreasingInterestTGE -> UntangledBase;
IMintedIncreasingInterestTGE[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IMintedIncreasingInterestTGE</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,address,address,address,bool)</TD></TR><TR><TD align="left">    setupLongSale(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    buyTokens(address,address,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    finalized</TD></TR><TR><TD align="left">    currencyRaised</TD></TR></TABLE> >];

INoteToken -> ERC20PresetMinterPauser;
INoteToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>INoteToken</B></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    poolAddress</TD></TR><TR><TD align="left">    noteTokenType</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _d</TD></TR></TABLE> >];

INoteTokenFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>INoteTokenFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    changeMinterRole(address,address)</TD></TR><TR><TD align="left">    createToken(address,Configuration.NOTE_TOKEN_TYPE,uint8,string)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    tokens</TD></TR><TR><TD align="left">    isExistingTokens</TD></TR></TABLE> >];

ISecuritizationManager[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISecuritizationManager</B></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    isExistingPools</TD></TR><TR><TD align="left">    pools</TD></TR><TR><TD align="left">    poolToSOT</TD></TR><TR><TD align="left">    poolToJOT</TD></TR><TR><TD align="left">    isExistingTGEs</TD></TR><TR><TD align="left">    POOL_CREATOR</TD></TR></TABLE> >];

ISecuritizationPool -> UntangledBase;
ISecuritizationPool[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISecuritizationPool</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,address,uint32)</TD></TR><TR><TD align="left">    getNFTAssetsLength()</TD></TR><TR><TD align="left">    getTokenAssetAddresses()</TD></TR><TR><TD align="left">    getTokenAssetAddressesLength()</TD></TR><TR><TD align="left">    getRiskScoresLength()</TD></TR><TR><TD align="left">    isClosedState()</TD></TR><TR><TD align="left">    hasFinishedRedemption()</TD></TR><TR><TD align="left">    setPot(address)</TD></TR><TR><TD align="left">    setupRiskScores(uint32[],uint32[],uint32[])</TD></TR><TR><TD align="left">    exportAssets(address,address,uint256[])</TD></TR><TR><TD align="left">    withdrawAssets(address[],uint256[],address[])</TD></TR><TR><TD align="left">    collectAssets(address,address,uint256[])</TD></TR><TR><TD align="left">    collectERC20Assets(address[],address[],uint256[])</TD></TR><TR><TD align="left">    withdrawERC20Assets(address[],address[],uint256[])</TD></TR><TR><TD align="left">    claimERC20Assets(address[])</TD></TR><TR><TD align="left">    claimCashRemain(address)</TD></TR><TR><TD align="left">    injectTGEAddress(address,address,Configuration.NOTE_TOKEN_TYPE)</TD></TR><TR><TD align="left">    startCycle(uint64,uint256,uint32,uint64)</TD></TR><TR><TD align="left">    setInterestRateForSOT(uint32)</TD></TR><TR><TD align="left">    increaseLockedDistributeBalance(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    increaseTotalAssetRepaidCurrency(uint256)</TD></TR><TR><TD align="left">    decreaseLockedDistributeBalance(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    redeem(address,address,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    ORIGINATOR_ROLE</TD></TR><TR><TD align="left">    tgeAddress</TD></TR><TR><TD align="left">    secondTGEAddress</TD></TR><TR><TD align="left">    sotToken</TD></TR><TR><TD align="left">    jotToken</TD></TR><TR><TD align="left">    underlyingCurrency</TD></TR><TR><TD align="left">    state</TD></TR><TR><TD align="left">    openingBlockTimestamp</TD></TR><TR><TD align="left">    termLengthInSeconds</TD></TR><TR><TD align="left">    totalRedeemedCurrency</TD></TR><TR><TD align="left">    totalLockedDistributeBalance</TD></TR><TR><TD align="left">    totalLockedRedeemBalances</TD></TR><TR><TD align="left">    lockedDistributeBalances</TD></TR><TR><TD align="left">    lockedRedeemBalances</TD></TR><TR><TD align="left">    totalAssetRepaidCurrency</TD></TR><TR><TD align="left">    paidInterestAmountSOT</TD></TR><TR><TD align="left">    lastRepayTimestampSOT</TD></TR><TR><TD align="left">    principalAmountSOT</TD></TR><TR><TD align="left">    paidPrincipalAmountSOT</TD></TR><TR><TD align="left">    interestRateSOT</TD></TR><TR><TD align="left">    minFirstLossCushion</TD></TR><TR><TD align="left">    riskScores</TD></TR><TR><TD align="left">    nftAssets</TD></TR><TR><TD align="left">    tokenAssetAddresses</TD></TR><TR><TD align="left">    existsTokenAssetAddress</TD></TR><TR><TD align="left">    paidPrincipalAmountSOTByInvestor</TD></TR><TR><TD align="left">    pot</TD></TR></TABLE> >];

ISecuritizationPoolValueService[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISecuritizationPoolValueService</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getOutstandingPrincipalCurrencyByInvestor(address,address)</TD></TR><TR><TD align="left">    getExpectedAssetsValue(address,uint256)</TD></TR><TR><TD align="left">    getSeniorAsset(address)</TD></TR><TR><TD align="left">    getJuniorAsset(address)</TD></TR></TABLE> >];

ISupplyChainManagementProgram -> Initializable [ label="1" ];
ISupplyChainManagementProgram -> PausableUpgradeable [ label="2" ];
ISupplyChainManagementProgram -> AccessControlEnumerableUpgradeable [ label="3" ];
ISupplyChainManagementProgram[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISupplyChainManagementProgram</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    newProject(uint256,string,address)</TD></TR><TR><TD align="left">    updateCompanyId(uint256,string)</TD></TR><TR><TD align="left">    addCommodity(uint256,uint256,string,uint256)</TD></TR><TR><TD align="left">    addTrader(uint256,address)</TD></TR><TR><TD align="left">    addLender(uint256,address)</TD></TR><TR><TD align="left">    addExecutor(uint256,address)</TD></TR><TR><TD align="left">    removeTrader(uint256,address)</TD></TR><TR><TD align="left">    removeLender(uint256,address)</TD></TR><TR><TD align="left">    removeExecutor(uint256,address)</TD></TR><TR><TD align="left">    isTrader(uint256,address)</TD></TR><TR><TD align="left">    isLender(uint256,address)</TD></TR><TR><TD align="left">    isExecutor(uint256,address)</TD></TR><TR><TD align="left">    initMovement(string,uint256,uint256,uint8)</TD></TR><TR><TD align="left">    approveMovement(string,uint256)</TD></TR><TR><TD align="left">    executeMovement(string,uint256,uint256)</TD></TR><TR><TD align="left">    updateStateMovement(string,uint256,ISupplyChainManagementProgram.MovementState,uint256,address)</TD></TR><TR><TD align="left">    isProjectExisting(uint256)</TD></TR><TR><TD align="left">    bulkInsertCompletedMovement(bytes32[],uint256[],uint256[],uint8[],address[],address[],uint256[])</TD></TR><TR><TD align="left">    addExistedBalance(uint256,uint256,address,uint256)</TD></TR><TR><TD align="left">    removeExistedBalance(uint256,uint256,address,uint256)</TD></TR><TR><TD align="left">    getCommodityPrice(uint256)</TD></TR><TR><TD align="left">    updateCommodityPrice(uint256,uint256)</TD></TR><TR><TD align="left">    insertAgreementToCommodity(uint256,bytes32)</TD></TR><TR><TD align="left">    removeAgreementFromCommodity(uint256,bytes32)</TD></TR><TR><TD align="left">    getAgreementsOfProjectCommodity(uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    PRICE_FEED_ROLE</TD></TR><TR><TD align="left">    OWNER_ROLE</TD></TR><TR><TD align="left">    collateralProjects</TD></TR><TR><TD align="left">    isExistingProjects</TD></TR><TR><TD align="left">    projectToLenders</TD></TR><TR><TD align="left">    projectToTraders</TD></TR><TR><TD align="left">    projectToExecutors</TD></TR><TR><TD align="left">    isExistingManager</TD></TR><TR><TD align="left">    projectToExistedProjectCommodity</TD></TR><TR><TD align="left">    projectToMovements</TD></TR><TR><TD align="left">    projectToExistedMovements</TD></TR><TR><TD align="left">    projectCommodityToPrice</TD></TR><TR><TD align="left">    projectCommodityToAgreements</TD></TR><TR><TD align="left">    projectCommodityToCommodity</TD></TR><TR><TD align="left">    projectCommodityToProject</TD></TR></TABLE> >];

ITokenGenerationEventFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ITokenGenerationEventFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    createNewSaleInstance(address,address,address,address,uint8,bool)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    tgeAddresses</TD></TR><TR><TD align="left">    isExistingTge</TD></TR></TABLE> >];

IUntangledERC721 -> ERC721PresetMinterPauserAutoIdUpgradeable;
IUntangledERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IUntangledERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    mint(address,uint256)</TD></TR><TR><TD align="left">    getTotalExpectedRepaymentValue(uint256,uint256)</TD></TR><TR><TD align="left">    getExpirationTimestamp(uint256)</TD></TR><TR><TD align="left">    getInterestRate(uint256)</TD></TR><TR><TD align="left">    getRiskScore(uint256)</TD></TR><TR><TD align="left">    getAssetPurpose(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __UntangledERC721__init(string,string,string)</TD></TR><TR><TD align="left">    __UntangledERC721__init_unchained(string,string,string)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

ConfigHelper[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ConfigHelper</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getAddress(Registry,Configuration.CONTRACT_TYPE)</TD></TR><TR><TD align="left">    getSecuritizationManager(Registry)</TD></TR><TR><TD align="left">    getSecuritizationPool(Registry)</TD></TR><TR><TD align="left">    getNoteTokenFactory(Registry)</TD></TR><TR><TD align="left">    getTokenGenerationEventFactory(Registry)</TD></TR><TR><TD align="left">    getDistributionOperator(Registry)</TD></TR><TR><TD align="left">    getLoanAssetToken(Registry)</TD></TR><TR><TD align="left">    getAcceptedInvoiceToken(Registry)</TD></TR><TR><TD align="left">    getLoanRegistry(Registry)</TD></TR><TR><TD align="left">    getLoanInterestTermsContract(Registry)</TD></TR><TR><TD align="left">    getLoanRepaymentRouter(Registry)</TD></TR><TR><TD align="left">    getLoanKernel(Registry)</TD></TR><TR><TD align="left">    getDistributionTranche(Registry)</TD></TR><TR><TD align="left">    getSecuritizationPoolValueService(Registry)</TD></TR><TR><TD align="left">    getDistributionAssessor(Registry)</TD></TR><TR><TD align="left">    getMintedIncreasingInterestTGE(Registry)</TD></TR><TR><TD align="left">    getMintedNormalTGE(Registry)</TD></TR><TR><TD align="left">    getCollateralManagementToken(Registry)</TD></TR><TR><TD align="left">    getSupplyChainManagementProgram(Registry)</TD></TR><TR><TD align="left">    getInventoryLoanRegistry(Registry)</TD></TR><TR><TD align="left">    getInventoryCollateralizer(Registry)</TD></TR><TR><TD align="left">    getInventoryInterestTermsContract(Registry)</TD></TR><TR><TD align="left">    getInventoryLoanKernel(Registry)</TD></TR><TR><TD align="left">    getInventoryLoanRepaymentRouter(Registry)</TD></TR><TR><TD align="left">    getInvoiceDebtRegistry(Registry)</TD></TR><TR><TD align="left">    getInvoiceCollateralizer(Registry)</TD></TR><TR><TD align="left">    getInvoiceFinanceInterestTermsContract(Registry)</TD></TR><TR><TD align="left">    getInvoiceLoanKernel(Registry)</TD></TR><TR><TD align="left">    getInvoiceLoanRepaymentRouter(Registry)</TD></TR></TABLE> >];

Configuration[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Configuration</B></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    PRICE_SCALING_FACTOR</TD></TR></TABLE> >];

SignaturesLib[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SignaturesLib</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    isValidSignature(address,bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    PREFIX</TD></TR></TABLE> >];

TransferHelper[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TransferHelper</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    safeApprove(address,address,uint256)</TD></TR><TR><TD align="left">    safeTransfer(address,address,uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,address,uint256)</TD></TR></TABLE> >];

Unpack[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Unpack</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    unpackPrincipalAmount(bytes32)</TD></TR><TR><TD align="left">    unpackInterestRate(bytes32)</TD></TR><TR><TD align="left">    unpackAmortizationUnitType(bytes32)</TD></TR><TR><TD align="left">    unpackTermLengthInAmortizationUnits(bytes32)</TD></TR><TR><TD align="left">    unpackGracePeriodInDays(bytes32)</TD></TR></TABLE> >];

Unpack16[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Unpack16</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    unpackCollateralTokenId(bytes16)</TD></TR><TR><TD align="left">    unpackCollateralAmount(bytes16)</TD></TR></TABLE> >];

UnpackLoanParamtersLib[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UnpackLoanParamtersLib</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _bitShiftRight(bytes32,uint256)</TD></TR><TR><TD align="left">    _unpackLoanTermsParametersFromBytes(bytes32)</TD></TR><TR><TD align="left">    unpackParametersFromBytes(bytes32)</TD></TR></TABLE> >];

UntangledMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UntangledMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    rpow(uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ONE</TD></TR></TABLE> >];

SupplyChainManagementProgram -> ISupplyChainManagementProgram;
SupplyChainManagementProgram[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SupplyChainManagementProgram</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    initialize(Registry)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    newProject(uint256,string,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    updateCompanyId(uint256,string)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addCommodity(uint256,uint256,string,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addTrader(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addLender(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addExecutor(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeTrader(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeLender(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeExecutor(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isTrader(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isLender(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isExecutor(uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    initMovement(string,uint256,uint256,uint8)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approveMovement(string,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    executeMovement(string,uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    updateStateMovement(string,uint256,ISupplyChainManagementProgram.MovementState,uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isProjectExisting(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    bulkInsertCompletedMovement(bytes32[],uint256[],uint256[],uint8[],address[],address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addExistedBalance(uint256,uint256,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeExistedBalance(uint256,uint256,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getCommodityPrice(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    updateCommodityPrice(uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    insertAgreementToCommodity(uint256,bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeAgreementFromCommodity(uint256,bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAgreementsOfProjectCommodity(uint256)</font></TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _isMovementExisting(uint256,string)</TD></TR><TR><TD align="left">    _isMovementExisting(uint256,bytes32)</TD></TR><TR><TD align="left">    _isCollateralManager(uint256,address)</TD></TR><TR><TD align="left">    _doWithdraw(address,uint256,uint256)</TD></TR><TR><TD align="left">    _doDeposit(address,uint256,uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyCollateralManager(uint256)</TD></TR><TR><TD align="left">    onlyTrader(uint256)</TD></TR><TR><TD align="left">    onlyProjectExisted(uint256)</TD></TR><TR><TD align="left">    onlyPriceFeedManager()</TD></TR></TABLE> >];

LoanInterestTermsContract -> UntangledBase [ label="1" ];
LoanInterestTermsContract -> ILoanInterestTermsContract [ label="2" ];
LoanInterestTermsContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LoanInterestTermsContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left"><font color="#FFA500">    registerTermStart(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    registerConcludeLoan(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    registerRepayment(bytes32,address,address,uint256,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getValueRepaidToDate(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isCompletedRepayments(bytes32[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getExpectedRepaymentValues(bytes32,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getMultiExpectedRepaymentValues(bytes32[],uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getInterestRate(bytes32)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _addRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    _addRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    _setCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    _getAmortizationUnitLengthInSeconds(UnpackLoanParamtersLib.AmortizationUnitType)</TD></TR><TR><TD align="left">    _unpackParamsForAgreementID(bytes32)</TD></TR><TR><TD align="left">    _calculateInterestForDuration(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _getExpectedRepaymentValuesToTimestamp(UnpackLoanParamtersLib.InterestParams,uint256,uint256,uint256,uint256,bool,uint256)</TD></TR><TR><TD align="left">    _calculateInterestAmountToTimestamp(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyKernel()</TD></TR><TR><TD align="left">    onlyRouter()</TD></TR><TR><TD align="left">    onlyHaventStartedLoan(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NUM_AMORTIZATION_UNIT_TYPES</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    WEEK_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    MONTH_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_MULTIPLIER</TD></TR></TABLE> >];

LoanKernel -> ILoanKernel [ label="1" ];
LoanKernel -> UntangledBase [ label="2" ];
LoanKernel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LoanKernel</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left"><font color="#FFA500">    concludeLoan(address,bytes32,address)</font></TD></TR><TR><TD align="left">    concludeLoans(address[],bytes32[],address)</TD></TR><TR><TD align="left">    fillDebtOrder(address[],uint256[],bytes32[],bytes32[])</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getIssuance(address[],address[],bytes32[],uint256[])</TD></TR><TR><TD align="left">    _getDebtOrderHash(bytes32,uint256,uint256,address,uint256)</TD></TR><TR><TD align="left">    _getDebtOrderHashes(ILoanKernel.LoanOrder)</TD></TR><TR><TD align="left">    _getLoanOrder(address[],address[],uint256[],bytes32[],uint256[])</TD></TR><TR><TD align="left">    _issueDebtAgreements(bytes32,address,address,address,bytes32,address,uint256,uint256,uint8[])</TD></TR><TR><TD align="left">    _debtorsFromOrderAddresses(address[],uint256)</TD></TR><TR><TD align="left">    _principalAmountsFromOrderValues(uint256[],uint256)</TD></TR><TR><TD align="left">    _expirationTimestampsFromOrderValues(uint256[],uint256)</TD></TR><TR><TD align="left">    _saltFromOrderValues(uint256[],uint256)</TD></TR><TR><TD align="left">    _riskScoresFromOrderValues(uint256[],uint256)</TD></TR><TR><TD align="left">    _getAssetPurposeAndRiskScore(uint8,uint8)</TD></TR><TR><TD align="left">    _burnLoanAssetToken(bytes32)</TD></TR><TR><TD align="left">    _assertDebtExisting(bytes32)</TD></TR><TR><TD align="left">    _assertCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    _getDebtOrderHash(bytes32,uint256,address,address,uint256)</TD></TR><TR><TD align="left">    _getAgreementId(address,address,address,bytes32,uint256)</TD></TR><TR><TD align="left">    _genInputLoanAgreementId(address,address,address,address,uint256)</TD></TR><TR><TD align="left">    _genLoanAgreementIds(address,address[],address,bytes32[],uint256[])</TD></TR><TR><TD align="left">    _assertDebtOrderValidityInvariants(uint256,uint256,bytes32,uint256,bytes32)</TD></TR><TR><TD align="left">    _getBalance(address,address)</TD></TR><TR><TD align="left">    _getAllowance(address,address)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _transferFeesToBeneficiaries(address,address,address,address[5],uint256[5])</TD></TR><TR><TD align="left">    _assertExternalBalanceAndAllowanceInvariants(address,uint256,address,bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    validFillingOrderAddresses(address[])</TD></TR></TABLE> >];

LoanRegistry -> UntangledBase [ label="1" ];
LoanRegistry -> ILoanRegistry [ label="2" ];
LoanRegistry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LoanRegistry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    initialize(Registry)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    insert(bytes32,address,address,bytes32,address,uint256,uint256,uint8[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getLoanDebtor(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getLoanTermParams(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getPrincipalTokenAddress(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getDebtor(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTermContract(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRiskScore(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAssetPurpose(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getIssuanceBlockTimestamp(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getLastRepaymentTimestamp(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTermsContractParameters(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getExpirationTimestamp(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    updateLastRepaymentTimestamp(bytes32,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    principalPaymentInfo(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setCompletedLoan(bytes32)</font></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyLoanKernel()</TD></TR><TR><TD align="left">    onlyLoanInterestTermsContract()</TD></TR></TABLE> >];

LoanRepaymentRouter -> ILoanRepaymentRouter;
LoanRepaymentRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LoanRepaymentRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    initialize(Registry)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    repayInBatch(bytes32[],uint256[],address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _assertRepaymentRequest(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    _doRepay(bytes32,address,uint256,address)</TD></TR></TABLE> >];

LoanTyping[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LoanTyping</B></TD></TR></TABLE> >];

CRInventoryDecisionEngine -> SignaturesLib;
CRInventoryDecisionEngine[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CRInventoryDecisionEngine</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _computeCR(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _computeCR(uint256,uint256)</TD></TR><TR><TD align="left">    _computePriceValue(uint256,uint256)</TD></TR><TR><TD align="left">    _computePrincipalValueRequire(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _verifyPrice(uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    PRICE_PRECISION</TD></TR><TR><TD align="left">    CR_PRECISION</TD></TR><TR><TD align="left">    MAX_PRICE_TTL_IN_SECONDS</TD></TR><TR><TD align="left">    COLLATERAL_PRECISION</TD></TR><TR><TD align="left">    PRINCIPAL_PRECISION</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    MAX_UINT256</TD></TR></TABLE> >];

InventoryCollateralizer -> IERC721ReceiverUpgradeable [ label="1" ];
InventoryCollateralizer -> IERC1155ReceiverUpgradeable [ label="2" ];
InventoryCollateralizer -> UntangledBase [ label="3" ];
InventoryCollateralizer[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryCollateralizer</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    collateralizeERC1155(bytes32,address,address)</TD></TR><TR><TD align="left">    additionInventoryCollateralize(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    withdrawInventoryCollateralize(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    burnInventoryCollateralize(bytes32,uint256,address)</TD></TR><TR><TD align="left">    returnInventoryCollateral(bytes32)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155Received(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left">    timestampAdjustedForGracePeriod(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _unpackLoanTermsParametersFromBytes(bytes32)</TD></TR><TR><TD align="left">    _unpackInventoryCollateralParametersFromBytes(bytes16)</TD></TR><TR><TD align="left">    retrieveInventoryCollateralParameters(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyPermissionedInventoryTermContract(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    COLLATERALIZER</TD></TR><TR><TD align="left">    agreementToCollateralizer</TD></TR><TR><TD align="left">    SECONDS_IN_DAY</TD></TR><TR><TD align="left">    CONTEXT</TD></TR><TR><TD align="left">    CONTEXT_COLLATERAL_SALE</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'supportsInterface(bytes4)' collides in inherited contracts IERC165Upgradeable, AccessControlEnumerableUpgradeable where AccessControlEnumerableUpgradeable is chosen.</font></TD></TR></TABLE> >];

InventoryInterestTermsContract -> CRInventoryDecisionEngine [ label="1" ];
InventoryInterestTermsContract -> LoanTyping [ label="2" ];
InventoryInterestTermsContract -> PausableUpgradeable [ label="3" ];
InventoryInterestTermsContract -> OwnableUpgradeable [ label="4" ];
InventoryInterestTermsContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryInterestTermsContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    registerTermStart(bytes32,address[2])</TD></TR><TR><TD align="left">    registerRepayment(bytes32,uint256,address)</TD></TR><TR><TD align="left">    registerSecureLoanWithCollateral(bytes32,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    registerInsecureLoanByWithdrawCollateral(bytes32,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    registerSellCollateral(bytes32,uint256,uint256,uint256,address,bytes16)</TD></TR><TR><TD align="left">    registerPayCollateralByFiat(bytes32,bytes32,address)</TD></TR><TR><TD align="left">    registerPayCollateralByInvoice(bytes32,bytes32,address,uint256,uint256)</TD></TR><TR><TD align="left">    registerPayFromInvoice(bytes32,uint256,address,address)</TD></TR><TR><TD align="left">    registerDrawdownLoan(bytes32,uint256,bytes32)</TD></TR><TR><TD align="left">    registerForeclosureLoan(bytes32)</TD></TR><TR><TD align="left">    getTermEndTimestamp(bytes32)</TD></TR><TR><TD align="left">    registerConcludeTerm(bytes32)</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(bytes32,uint256)</TD></TR><TR><TD align="left">    getTermStartUnixTimestamp(bytes32)</TD></TR><TR><TD align="left">    getTotalExpectedRepaymentValue(bytes32,uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    collateralize(bytes32,address[2])</TD></TR><TR><TD align="left">    _getAmortizationUnitLengthInSeconds(InventoryInterestTermsContract.AmortizationUnitType)</TD></TR><TR><TD align="left">    _unpackParamsForAgreementID(LoanTyping.LoanTypes,bytes32)</TD></TR><TR><TD align="left">    _validateNewInventoryCollateralParamsSecureLoan(bytes16,bytes16,uint256)</TD></TR><TR><TD align="left">    _validateNewInventoryTermsContractParamsDrawdown(bytes32,bytes32,uint256)</TD></TR><TR><TD align="left">    _validateNewInventoryCollateralParamsSellCollateral(bytes16,bytes16,uint256)</TD></TR><TR><TD align="left">    _validateNewCollateralAmount(bytes32,bytes16,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _validateNewCollateralRatioWithInvoice(uint256,bytes32,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _validateNewCollateralRatioWhenDrawdown(bytes32,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _repayLoanIfNeed(uint256,bytes32,uint256,uint256,address[2],uint256)</TD></TR><TR><TD align="left">    _computeExpectedCR(bytes32,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _burnCollateralAndUpdateInfo(bytes32,uint256,address,bytes16,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _createAITFinanced(bytes32,address,uint256,uint256,uint256,uint256,InventoryLoanRegistry)</TD></TR><TR><TD align="left">    _getSellCollateralId(bytes32,uint256,uint256)</TD></TR><TR><TD align="left">    _calculateInterestForDuration(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getStartDateInTimestamp(uint256)</TD></TR><TR><TD align="left">    _calculateInterestAmountToTimestamp(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _getExpectedRepaymentValuesToTimestamp(InventoryInterestTermsContract.InterestParams,uint256,uint256,uint256,uint256,bool,uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRouter(LoanTyping.LoanTypes)</TD></TR><TR><TD align="left">    onlyDebtKernel()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    NUM_AMORTIZATION_UNIT_TYPES</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    WEEK_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    MONTH_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_MULTIPLIER</TD></TR></TABLE> >];

InventoryLoanKernel -> PausableUpgradeable [ label="1" ];
InventoryLoanKernel -> OwnableUpgradeable [ label="2" ];
InventoryLoanKernel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryLoanKernel</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    _fillDebtOrder(address,address,uint256,address[6],uint256[7],bytes32[1],bytes16[1],address[5],address[5],uint256[5],uint256[5])</TD></TR><TR><TD align="left">    fillDebtOrder(address,address[6],uint256[7],bytes32[1],bytes16[1],uint8[2],bytes32[2],bytes32[2],address[5],address[5],uint256[5],uint256[5])</TD></TR><TR><TD align="left">    concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left">    secureLoanWithCollateral(bytes32,address,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    cancelDebtOrder(address[6],uint256[7],bytes32[1],bytes16[1])</TD></TR><TR><TD align="left">    cancelIssuance(address,address,address,bytes32,bytes16,uint256)</TD></TR><TR><TD align="left">    sellCollateral(bytes32,uint256,uint256,uint256,uint256,address,bytes16,address[3],uint8[3],bytes32[3],bytes32[3])</TD></TR><TR><TD align="left">    payCollateralByFiat(bytes32,bytes32,address)</TD></TR><TR><TD align="left">    payCollateralByInvoice(bytes32,bytes32,address,uint256,uint256)</TD></TR><TR><TD align="left">    insecureLoanByWithdrawCollateral(bytes32,address,uint256,address,bytes16)</TD></TR><TR><TD align="left">    foreclosureLoanBySellCollateral(bytes32,uint256,uint256,uint256,uint256,address,bytes16,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    drawdownLoan(bytes32,uint256,bytes32,uint8[2],bytes32[2],bytes32[2])</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getDebtOrderHash(InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _getDebtOrder(address[6],uint256[7],bytes32[1],bytes16[1])</TD></TR><TR><TD align="left">    _getAgreementId(address,address,address,uint256,bytes32)</TD></TR><TR><TD align="left">    _getIssuance(address,address,address,uint256,bytes32,bytes16)</TD></TR><TR><TD align="left">    _issueDebtAgreement(address,InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _burnLoanAssetToken(address,bytes32)</TD></TR><TR><TD align="left">    _getBalance(address,address)</TD></TR><TR><TD align="left">    _getAllowance(address,address)</TD></TR><TR><TD align="left">    _isValidSignature(address,bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _assertDebtOrderValidityInvariants(InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _assertDebtOrderConsensualityInvariants(InventoryLoanKernel.DebtOrder,address,uint8[2],bytes32[2],bytes32[2])</TD></TR><TR><TD align="left">    _assertDebtExisting(bytes32)</TD></TR><TR><TD align="left">    _assertCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    _concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left">    _transferFeesToBeneficiaries(address,address,address,address[5],uint256[5])</TD></TR><TR><TD align="left">    _sumTotalFees(uint256[5])</TD></TR><TR><TD align="left">    getSignatureRS()</TD></TR><TR><TD align="left">    getSignatureV()</TD></TR><TR><TD align="left">    getAssetHolder(InventoryLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _isParticipantOfProject(uint256,address,address,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NULL_ISSUANCE_HASH</TD></TR><TR><TD align="left">    EXTERNAL_QUERY_GAS_LIMIT</TD></TR><TR><TD align="left">    issuanceCancelled</TD></TR><TR><TD align="left">    debtOrderCancelled</TD></TR><TR><TD align="left">    debtOrderCompleted</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

InventoryLoanRegistry -> UntangledBase [ label="1" ];
InventoryLoanRegistry -> CRInventoryDecisionEngine [ label="2" ];
InventoryLoanRegistry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryLoanRegistry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    insert(address,address,address,address,address,address,bytes32,bytes16,uint256[4])</TD></TR><TR><TD align="left">    insertInvoiceFinancedToInventoryLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    evaluateCollateralRatio(bytes32,uint256,uint256)</TD></TR><TR><TD align="left">    selfEvaluateCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    updateLoanTermParameters(bytes32,bytes32)</TD></TR><TR><TD align="left">    updateCollateralInfoParameters(bytes32,bytes16)</TD></TR><TR><TD align="left">    setMinCollateralRatio(bytes32,uint256)</TD></TR><TR><TD align="left">    setLiquidationRatio(bytes32,uint256)</TD></TR><TR><TD align="left">    modifyBeneficiary(bytes32,address)</TD></TR><TR><TD align="left">    updateLastRepaymentTimestamp(bytes32,uint256)</TD></TR><TR><TD align="left">    doesEntryExist(bytes32)</TD></TR><TR><TD align="left">    getBeneficiary(bytes32)</TD></TR><TR><TD align="left">    getDebtor(bytes32)</TD></TR><TR><TD align="left">    getTerms(bytes32)</TD></TR><TR><TD align="left">    getTermsContract(bytes32)</TD></TR><TR><TD align="left">    getTermsContractParameters(bytes32)</TD></TR><TR><TD align="left">    getIssuanceBlockTimestamp(bytes32)</TD></TR><TR><TD align="left">    getLastRepaymentTimestamp(bytes32)</TD></TR><TR><TD align="left">    getExpirationTimestamp(bytes32)</TD></TR><TR><TD align="left">    get(bytes32)</TD></TR><TR><TD align="left">    getLiquidationRatio(bytes32)</TD></TR><TR><TD align="left">    getMinCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    getCollateralLastPrice(bytes32)</TD></TR><TR><TD align="left">    getInitCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    isReadyForLiquidation(bytes32)</TD></TR><TR><TD align="left">    latestCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    getCollateralInfoParameters(bytes32)</TD></TR><TR><TD align="left">    getInvoiceIds(bytes32)</TD></TR><TR><TD align="left">    removeInvoiceId(bytes32,uint256)</TD></TR><TR><TD align="left">    _getTotalInvoiceAmount(bytes32)</TD></TR><TR><TD align="left">    setWaitingSellCollateral(bytes32,bytes32,uint256,uint256)</TD></TR><TR><TD align="left">    isWaitingSellCollateralExisted(bytes32,bytes32)</TD></TR><TR><TD align="left">    getWaitingSellCollateral(bytes32,bytes32)</TD></TR><TR><TD align="left">    setLoanLiquidated(bytes32)</TD></TR><TR><TD align="left">    removeLiquidatedLoan(bytes32)</TD></TR><TR><TD align="left">    isExpiredOrReadyForLiquidation(bytes32)</TD></TR><TR><TD align="left">    setCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    getRepaidPrincipalAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getRepaidInterestAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    setCompletedLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestLoan(bytes32,bool)</TD></TR><TR><TD align="left">    getManualInterestAmountLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestAmountLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    getAgreement(bytes32)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getAgreementId(InventoryLoanRegistry.Entry,address,uint256)</TD></TR><TR><TD align="left">    _evaluateCollateralRatio(bytes32,uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonNullBeneficiary(address)</TD></TR><TR><TD align="left">    onlyExtantEntry(bytes32)</TD></TR><TR><TD align="left">    onlyAuthorizedToEdit()</TD></TR><TR><TD align="left">    onlyPriceFeedOperator(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    entries</TD></TR><TR><TD align="left">    registryToInvoice</TD></TR><TR><TD align="left">    waitingSellCollateral</TD></TR><TR><TD align="left">    waitingSellCollateralExisted</TD></TR><TR><TD align="left">    liquidatedLoan</TD></TR><TR><TD align="left">    completedRepayment</TD></TR><TR><TD align="left">    repaidPrincipalAmount</TD></TR><TR><TD align="left">    repaidInterestAmount</TD></TR><TR><TD align="left">    completedLoans</TD></TR><TR><TD align="left">    manualInterestLoan</TD></TR><TR><TD align="left">    INSERT_CONTEXT</TD></TR><TR><TD align="left">    EDIT_CONTEXT</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    debtorToDebts</TD></TR><TR><TD align="left">    manualInterestAmountLoan</TD></TR></TABLE> >];

InventoryLoanRepaymentRouter -> PausableUpgradeable [ label="1" ];
InventoryLoanRepaymentRouter -> OwnableUpgradeable [ label="2" ];
InventoryLoanRepaymentRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InventoryLoanRepaymentRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    _doRepay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    repay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _assertRepaymentRequest(bytes32,address,uint256,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

CRDecisionEngine -> SignaturesLib;
CRDecisionEngine[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CRDecisionEngine</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _computeCR(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _computeInvoiceCR(uint256,uint256)</TD></TR><TR><TD align="left">    _verifyPrice(uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    PRICE_PRECISION</TD></TR><TR><TD align="left">    CR_PRECISION</TD></TR><TR><TD align="left">    MAX_PRICE_TTL_IN_SECONDS</TD></TR><TR><TD align="left">    COLLATERAL_PRECISION</TD></TR><TR><TD align="left">    PRINCIPAL_PRECISION</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    MAX_UINT256</TD></TR></TABLE> >];

InvoiceCollateralizer -> Initializable [ label="1" ];
InvoiceCollateralizer -> PausableUpgradeable [ label="2" ];
InvoiceCollateralizer -> AccessControlEnumerableUpgradeable [ label="3" ];
InvoiceCollateralizer -> IERC721ReceiverUpgradeable [ label="4" ];
InvoiceCollateralizer[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceCollateralizer</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    collateralizeERC721(bytes32,address)</TD></TR><TR><TD align="left">    additionERC721Collateralize(bytes32,address,bytes32,address)</TD></TR><TR><TD align="left">    withdrawERC721Collateralize(bytes32,address,bytes32,address)</TD></TR><TR><TD align="left">    returnInvoiceCollateral(bytes32)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left">    timestampAdjustedForGracePeriod(uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    retrieveInvoiceCollateralParameters(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyPermissionedInvoiceTermContract(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    COLLATERALIZER</TD></TR><TR><TD align="left">    agreementToCollateralizer</TD></TR><TR><TD align="left">    SECONDS_IN_DAY</TD></TR><TR><TD align="left">    CONTEXT</TD></TR><TR><TD align="left">    CONTEXT_COLLATERAL_SALE</TD></TR></TABLE> >];

InvoiceDebtRegistry -> Initializable [ label="1" ];
InvoiceDebtRegistry -> PausableUpgradeable [ label="2" ];
InvoiceDebtRegistry -> OwnableUpgradeable [ label="3" ];
InvoiceDebtRegistry -> CRDecisionEngine [ label="4" ];
InvoiceDebtRegistry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceDebtRegistry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    insert(address,address,address,address,address,bytes32,bytes32[],uint256[3])</TD></TR><TR><TD align="left">    updateLoanTermParameters(bytes32,bytes32)</TD></TR><TR><TD align="left">    setMinCollateralRatio(bytes32,uint256)</TD></TR><TR><TD align="left">    modifyBeneficiary(bytes32,address)</TD></TR><TR><TD align="left">    selfEvaluateCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    updateLastRepaymentTimestamp(bytes32,uint256)</TD></TR><TR><TD align="left">    doesEntryExist(bytes32)</TD></TR><TR><TD align="left">    getBeneficiary(bytes32)</TD></TR><TR><TD align="left">    getDebtor(bytes32)</TD></TR><TR><TD align="left">    getTerms(bytes32)</TD></TR><TR><TD align="left">    getInvoiceTokenIds(bytes32)</TD></TR><TR><TD align="left">    insertInvoiceFinancedToInvoiceLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    removeInvoiceId(bytes32,uint256)</TD></TR><TR><TD align="left">    _getTotalInvoiceAmount(bytes32)</TD></TR><TR><TD align="left">    getTermsContract(bytes32)</TD></TR><TR><TD align="left">    getTermsContractParameters(bytes32)</TD></TR><TR><TD align="left">    getIssuanceBlockTimestamp(bytes32)</TD></TR><TR><TD align="left">    getLastRepaymentTimestamp(bytes32)</TD></TR><TR><TD align="left">    getExpirationTimestamp(bytes32)</TD></TR><TR><TD align="left">    get(bytes32)</TD></TR><TR><TD align="left">    getCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    getMinCollateralRatio(bytes32)</TD></TR><TR><TD align="left">    isCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    setCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    getRepaidPrincipalAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidPrincipalAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getRepaidInterestAmount(bytes32)</TD></TR><TR><TD align="left">    addRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    setRepaidInterestAmount(bytes32,uint256)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    isCompletedLoan(bytes32)</TD></TR><TR><TD align="left">    setCompletedLoan(bytes32)</TD></TR><TR><TD align="left">    isManualInterestLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestLoan(bytes32,bool)</TD></TR><TR><TD align="left">    getManualInterestAmountLoan(bytes32)</TD></TR><TR><TD align="left">    setManualInterestAmountLoan(bytes32,uint256)</TD></TR><TR><TD align="left">    getAgreement(bytes32)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getAgreementId(InvoiceDebtRegistry.Entry,address,uint256)</TD></TR><TR><TD align="left">    _evaluateCollateralRatio(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonNullBeneficiary(address)</TD></TR><TR><TD align="left">    onlyExtantEntry(bytes32)</TD></TR><TR><TD align="left">    onlyAuthorizedToEdit()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    completedRepayment</TD></TR><TR><TD align="left">    repaidPrincipalAmount</TD></TR><TR><TD align="left">    repaidInterestAmount</TD></TR><TR><TD align="left">    completedLoans</TD></TR><TR><TD align="left">    manualInterestLoan</TD></TR><TR><TD align="left">    manualInterestAmountLoan</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    entries</TD></TR><TR><TD align="left">    registryToInvoice</TD></TR><TR><TD align="left">    debtorToDebts</TD></TR></TABLE> >];

InvoiceFinanceInterestTermsContract -> PausableUpgradeable [ label="1" ];
InvoiceFinanceInterestTermsContract -> OwnableUpgradeable [ label="2" ];
InvoiceFinanceInterestTermsContract -> CRDecisionEngine [ label="3" ];
InvoiceFinanceInterestTermsContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceFinanceInterestTermsContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    registerInvoiceLoanTermStart(bytes32,address)</TD></TR><TR><TD align="left">    registerRepayment(bytes32,address,address,uint256,address)</TD></TR><TR><TD align="left">    registerSecureLoanWithInvoice(bytes32,address,address,bytes32[])</TD></TR><TR><TD align="left">    registerInsecureLoanByWithdrawInvoice(bytes32,address,address,bytes32[])</TD></TR><TR><TD align="left">    registerConcludeInvoiceLoan(bytes32)</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(bytes32,uint256)</TD></TR><TR><TD align="left">    getValueRepaidToDate(bytes32)</TD></TR><TR><TD align="left">    isTermsContractExpired(bytes32)</TD></TR><TR><TD align="left">    registerDrawdownLoan(bytes32,uint256,bytes32)</TD></TR><TR><TD align="left">    getTotalExpectedRepaymentValue(bytes32,uint256)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _unpackParamsForAgreementID(bytes32)</TD></TR><TR><TD align="left">    _getAmortizationUnitLengthInSeconds(InvoiceFinanceInterestTermsContract.AmortizationUnitType)</TD></TR><TR><TD align="left">    _getExpectedRepaymentValuesToTimestamp(InvoiceFinanceInterestTermsContract.InterestParams,uint256,uint256,uint256,uint256,bool,uint256)</TD></TR><TR><TD align="left">    _calculateInterestForDuration(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getStartDateInTimestamp(uint256)</TD></TR><TR><TD align="left">    _calculateInterestAmountToTimestamp(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _validateNewTermsContractParamsDrawdown(bytes32,bytes32,uint256)</TD></TR><TR><TD align="left">    _validateNewCollateralRatioWhenDrawdown(bytes32,uint256,InvoiceDebtRegistry)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRouter()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NUM_AMORTIZATION_UNIT_TYPES</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    WEEK_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    MONTH_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_MULTIPLIER</TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

InvoiceLoanKernel -> PausableUpgradeable [ label="1" ];
InvoiceLoanKernel -> OwnableUpgradeable [ label="2" ];
InvoiceLoanKernel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceLoanKernel</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    concludeLoan(address,address,bytes32,address)</TD></TR><TR><TD align="left">    cancelDebtOrder(address[5],uint256[6],bytes32[])</TD></TR><TR><TD align="left">    cancelIssuance(address,address,address,bytes32,bytes32[],uint256)</TD></TR><TR><TD align="left">    fillDebtOrder(address,address[5],uint256[6],bytes32[],uint8[2],bytes32[2],bytes32[2],address[10],uint256[10])</TD></TR><TR><TD align="left">    drawdownLoan(bytes32,uint256,bytes32,uint8[2],bytes32[2],bytes32[2])</TD></TR><TR><TD align="left">    secureLoanWithInvoice(bytes32,address,address,address,bytes32[])</TD></TR><TR><TD align="left">    insecureLoanByWithdrawInvoice(bytes32,address,address,bytes32[])</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getDebtOrderHash(InvoiceLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    getInvoiceTokenIds(bytes32[])</TD></TR><TR><TD align="left">    _getDebtOrder(address[5],uint256[6],bytes32[])</TD></TR><TR><TD align="left">    _getAgreementId(address,address,address,uint256,bytes32)</TD></TR><TR><TD align="left">    _getIssuance(address,address,address,uint256,bytes32,bytes32[])</TD></TR><TR><TD align="left">    _burnLoanAssetToken(bytes32)</TD></TR><TR><TD align="left">    _getBalance(address,address)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _assertDebtOrderValidityInvariants(InvoiceLoanKernel.DebtOrder)</TD></TR><TR><TD align="left">    _assertDebtExisting(bytes32)</TD></TR><TR><TD align="left">    _assertCompletedRepayment(bytes32)</TD></TR><TR><TD align="left">    _concludeLoan(address,bytes32,address)</TD></TR><TR><TD align="left">    _transferFeesToBeneficiaries(address,address,address,address[5],uint256[5])</TD></TR><TR><TD align="left">    _sumTotalFees(uint256[5])</TD></TR><TR><TD align="left">    getDebtorCreditorFeeBeneficiaries(address[10],bool)</TD></TR><TR><TD align="left">    getDebtorCreditorFeeAmounts(uint256[10],bool)</TD></TR><TR><TD align="left">    _transferTokensLoanIssuance(InvoiceLoanKernel.DebtOrder,address,address[10],uint256[10])</TD></TR><TR><TD align="left">    _issueDebtAgreement(address,InvoiceLoanKernel.DebtOrder)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    NULL_ISSUANCE_HASH</TD></TR><TR><TD align="left">    EXTERNAL_QUERY_GAS_LIMIT</TD></TR><TR><TD align="left">    issuanceCancelled</TD></TR><TR><TD align="left">    debtOrderCancelled</TD></TR><TR><TD align="left">    debtOrderCompleted</TD></TR><TR><TD align="left">    agreementToLiability</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

InvoiceLoanRepaymentRouter -> PausableUpgradeable [ label="1" ];
InvoiceLoanRepaymentRouter -> OwnableUpgradeable [ label="2" ];
InvoiceLoanRepaymentRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>InvoiceLoanRepaymentRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    repayFromInvoicePayment(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    repay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _assertRepaymentRequest(bytes32,address,uint256,address)</TD></TR><TR><TD align="left">    _doRepay(bytes32,address,uint256,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

MintedIncreasingInterestTGE -> IncreasingInterestCrowdsale [ label="1" ];
MintedIncreasingInterestTGE -> LongSaleInterest [ label="2" ];
MintedIncreasingInterestTGE[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MintedIncreasingInterestTGE</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,address,address,address,bool)</TD></TR><TR><TD align="left"><font color="#FFA500">    isLongSale()</font></TD></TR><TR><TD align="left">    setYield(uint256)</TD></TR><TR><TD align="left">    setupLongSale(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getLongSaleTokenPrice(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getLongSaleTokenAmount(uint256)</font></TD></TR><TR><TD align="left">    startNewRoundSale(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _preValidateNewSaleRound()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    longSale</TD></TR><TR><TD align="left">    timeStartEarningInterest</TD></TR><TR><TD align="left">    termLengthInSeconds</TD></TR><TR><TD align="left">    interestRate</TD></TR><TR><TD align="left">    yield</TD></TR></TABLE> >];

MintedNormalTGE -> FinalizableCrowdsale [ label="1" ];
MintedNormalTGE -> LongSaleInterest [ label="2" ];
MintedNormalTGE[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MintedNormalTGE</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,address,address,address,bool)</TD></TR><TR><TD align="left"><font color="#FFA500">    isLongSale()</font></TD></TR><TR><TD align="left">    setYield(uint256)</TD></TR><TR><TD align="left">    setupLongSale(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    getLongSaleTokenPrice(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getLongSaleTokenAmount(uint256)</font></TD></TR><TR><TD align="left">    startNewRoundSale(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _preValidateNewSaleRound()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    longSale</TD></TR><TR><TD align="left">    timeStartEarningInterest</TD></TR><TR><TD align="left">    termLengthInSeconds</TD></TR><TR><TD align="left">    interestRate</TD></TR><TR><TD align="left">    yield</TD></TR></TABLE> >];

LongSaleInterest[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LongSaleInterest</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getPurchasePrice(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    PURCHASE_PRICE_SCALING_FACTOR</TD></TR></TABLE> >];

Crowdsale -> UntangledBase;
Crowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Crowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    addFunding(uint256)</TD></TR><TR><TD align="left">    buyTokens(address,address,uint256)</TD></TR><TR><TD align="left">    isDistributedFully()</TD></TR><TR><TD align="left">    getTokenRemainAmount()</TD></TR><TR><TD align="left">    getCurrencyRemainAmount()</TD></TR><TR><TD align="left">    isLongSale()</TD></TR><TR><TD align="left">    getLongSaleTokenAmount(uint256)</TD></TR><TR><TD align="left">    _getTokenAmount(uint256)</TD></TR><TR><TD align="left">    totalCapReached()</TD></TR><TR><TD align="left">    isUnderTotalCap(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __Crowdsale__init(Registry,address,address,address)</TD></TR><TR><TD align="left">    _newSaleRound(uint256)</TD></TR><TR><TD align="left">    _defaultPreValidatePurchase(address,uint256,uint256)</TD></TR><TR><TD align="left">    _preValidatePurchase(address,uint256,uint256)</TD></TR><TR><TD align="left">    _deliverTokens(address,uint256)</TD></TR><TR><TD align="left">    _ejectTokens(uint256)</TD></TR><TR><TD align="left">    _processPurchase(address,uint256)</TD></TR><TR><TD align="left">    _claimPayment(address,uint256)</TD></TR><TR><TD align="left">    _getCurrencyAmount(uint256)</TD></TR><TR><TD align="left">    _forwardFunds(address,uint256)</TD></TR><TR><TD align="left">    _setTotalCap(uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    securitizationPoolRestricted()</TD></TR><TR><TD align="left">    smpRestricted()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    RATE_SCALING_FACTOR</TD></TR><TR><TD align="left">    pool</TD></TR><TR><TD align="left">    token</TD></TR><TR><TD align="left">    currency</TD></TR><TR><TD align="left">    rate</TD></TR><TR><TD align="left">    hasStarted</TD></TR><TR><TD align="left">    currencyRaised</TD></TR><TR><TD align="left">    tokenRaised</TD></TR><TR><TD align="left">    totalCap</TD></TR><TR><TD align="left">    currencyRaisedByInvestor</TD></TR></TABLE> >];

FinalizableCrowdsale -> TimedCrowdsale;
FinalizableCrowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>FinalizableCrowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    finalize(bool,address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _finalization()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    finalized</TD></TR></TABLE> >];

IncreasingInterestCrowdsale -> FinalizableCrowdsale;
IncreasingInterestCrowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IncreasingInterestCrowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    setInterestRange(uint32,uint32,uint32,uint32)</TD></TR><TR><TD align="left">    getCurrentInterest()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _finalization()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _preValidatePurchase(address,uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    initialInterest</TD></TR><TR><TD align="left">    finalInterest</TD></TR><TR><TD align="left">    timeInterval</TD></TR><TR><TD align="left">    amountChangeEachInterval</TD></TR><TR><TD align="left">    pickedInterest</TD></TR></TABLE> >];

TimedCrowdsale -> Crowdsale;
TimedCrowdsale[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TimedCrowdsale</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    isOpen()</TD></TR><TR><TD align="left">    hasClosed()</TD></TR><TR><TD align="left">    extendTime(uint256)</TD></TR><TR><TD align="left">    newSaleRoundTime(uint256,uint256)</TD></TR><TR><TD align="left">    setUsingTimeLimit(bool)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    __TimedCrowdsale__init(Registry,address,address,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyWhileOpen()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    openingTime</TD></TR><TR><TD align="left">    closingTime</TD></TR><TR><TD align="left">    isEnableTimeLimit</TD></TR></TABLE> >];

NoteTokenFactory -> UntangledBase [ label="1" ];
NoteTokenFactory -> INoteTokenFactory [ label="2" ];
NoteTokenFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>NoteTokenFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left"><font color="#FFA500">    changeMinterRole(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    createToken(address,Configuration.NOTE_TOKEN_TYPE,uint8,string)</font></TD></TR><TR><TD align="left">    pauseUnpauseToken(address)</TD></TR><TR><TD align="left">    pauseAllTokens()</TD></TR><TR><TD align="left">    unPauseAllTokens()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlySecuritizationManager()</TD></TR></TABLE> >];

TokenGenerationEventFactory -> ITokenGenerationEventFactory [ label="1" ];
TokenGenerationEventFactory -> UntangledBase [ label="2" ];
TokenGenerationEventFactory -> Factory [ label="3" ];
TokenGenerationEventFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TokenGenerationEventFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left"><font color="#FFA500">    createNewSaleInstance(address,address,address,address,uint8,bool)</font></TD></TR><TR><TD align="left">    pauseUnpauseTge(address)</TD></TR><TR><TD align="left">    pauseUnpauseAllTges()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _newMintedIncreasingInterestSale(address,address,address,address,bool)</TD></TR><TR><TD align="left">    _newNormalSale(address,address,address,address,bool)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlySecuritizationManager()</TD></TR></TABLE> >];

DistributionAssessor -> Interest [ label="1" ];
DistributionAssessor -> SecuritizationPoolServiceBase [ label="2" ];
DistributionAssessor -> IDistributionAssessor [ label="3" ];
DistributionAssessor[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>DistributionAssessor</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    getSOTTokenPrice(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    calcAssetValue(address,address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    calcCorrespondingTotalAssetValue(address,address,uint256)</font></TD></TR><TR><TD align="left">    calcCorrespondingAssetValue(address,address,uint256)</TD></TR><TR><TD align="left">    calcAssetValue(address,address,address[])</TD></TR><TR><TD align="left">    calcCorrespondingAssetValue(address,address[],uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    calcTokenPrice(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getJOTTokenPrice(ISecuritizationPool,uint256)</font></TD></TR><TR><TD align="left">    calcSeniorAssetValue(address,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getCashBalance(address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _calcCorrespondingAssetValue(address,address,uint256)</TD></TR><TR><TD align="left">    _calcJuniorAssetValue(address,uint256)</TD></TR><TR><TD align="left">    _calcPrincipalInterestSOT(ISecuritizationPool,address,address,uint32,uint256,uint256)</TD></TR><TR><TD align="left">    _calcPrincipalInterestJOT(address,address,address,uint256)</TD></TR><TR><TD align="left">    _getPrincipalLeftOfSOT(ISecuritizationPool,address)</TD></TR><TR><TD align="left">    _calcSeniorAssetValue(uint256,uint256,uint256,uint256)</TD></TR></TABLE> >];

DistributionOperator -> SecuritizationPoolServiceBase [ label="1" ];
DistributionOperator -> IDistributionOperator [ label="2" ];
DistributionOperator[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>DistributionOperator</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    makeRedeemRequest(INoteToken,uint256)</TD></TR><TR><TD align="left">    redeemBatch(address[],address,address)</TD></TR><TR><TD align="left">    redeem(address,address,address)</TD></TR><TR><TD align="left">    makeRedeemRequestAndRedeem(address,INoteToken,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _redeem(address,address,address,uint256,uint256,IDistributionTranche,ISecuritizationPool)</TD></TR><TR><TD align="left">    _calculateAmountDistribute(address,address,uint256,uint256,ISecuritizationPool)</TD></TR></TABLE> >];

DistributionTranche -> SecuritizationPoolServiceBase [ label="1" ];
DistributionTranche -> IDistributionTranche [ label="2" ];
DistributionTranche[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>DistributionTranche</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    redeem(address,address,address,uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    redeemToken(address,address,uint256)</font></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOperator()</TD></TR></TABLE> >];

SecuritizationManager -> UntangledBase [ label="1" ];
SecuritizationManager -> Factory [ label="2" ];
SecuritizationManager -> ISecuritizationManager [ label="3" ];
SecuritizationManager[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SecuritizationManager</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left">    getPoolsLength()</TD></TR><TR><TD align="left">    newPoolInstance(address,uint32)</TD></TR><TR><TD align="left">    initialTGEForSOT(address,ISecuritizationPool,uint8[],bool,string)</TD></TR><TR><TD align="left">    setUpTGEForSOT(address,ISecuritizationPool,uint8[],bool,uint256,uint32,uint32,uint32,uint32,SecuritizationManager.NewRoundSaleParam,string)</TD></TR><TR><TD align="left">    setUpTGEForJOT(address,ISecuritizationPool,uint8[],bool,uint256,SecuritizationManager.NewRoundSaleParam,string)</TD></TR><TR><TD align="left">    initialTGEForJOT(address,ISecuritizationPool,uint8[],bool,string)</TD></TR><TR><TD align="left">    buyTokens(address,uint256)</TD></TR><TR><TD align="left">    pausePool(address)</TD></TR><TR><TD align="left">    unpausePool(address)</TD></TR><TR><TD align="left">    pauseAllPools()</TD></TR><TR><TD align="left">    unpauseAllPools()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyPoolExisted(ISecuritizationPool)</TD></TR><TR><TD align="left">    onlyManager(ISecuritizationPool)</TD></TR><TR><TD align="left">    doesSOTExist(ISecuritizationPool)</TD></TR><TR><TD align="left">    doesJOTExist(ISecuritizationPool)</TD></TR></TABLE> >];

SecuritizationPoolValueService -> SecuritizationPoolServiceBase [ label="1" ];
SecuritizationPoolValueService -> NAVCalculation [ label="2" ];
SecuritizationPoolValueService -> ISecuritizationPoolValueService [ label="3" ];
SecuritizationPoolValueService[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SecuritizationPoolValueService</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getExpectedAssetValue(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    getExpectedAssetValues(address,address[],uint256[],uint256)</TD></TR><TR><TD align="left">    getAssetInterestRate(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    getAssetInterestRates(address,address[],uint256[],uint256)</TD></TR><TR><TD align="left">    getExpectedERC20AssetValue(address,address,address,uint256,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getExpectedAssetsValue(address,uint256)</font></TD></TR><TR><TD align="left">    getAssetRiskScoreIdx(address,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getOutstandingPrincipalCurrencyByInvestor(address,address)</font></TD></TR><TR><TD align="left">    getOutstandingPrincipalCurrencyByInvestors(address,address[])</TD></TR><TR><TD align="left">    getOutstandingPrincipalCurrency(address)</TD></TR><TR><TD align="left">    getPoolValue(address)</TD></TR><TR><TD align="left">    getBeginningSeniorAsset(address)</TD></TR><TR><TD align="left">    getBeginningSeniorDebt(address)</TD></TR><TR><TD align="left">    getSeniorDebt(address)</TD></TR><TR><TD align="left">    getSeniorBalance(address)</TD></TR><TR><TD align="left">    getReserve(address,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getSeniorAsset(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getJuniorAsset(address)</font></TD></TR><TR><TD align="left">    getJuniorRatio(address)</TD></TR><TR><TD align="left">    getSeniorRatio(address)</TD></TR><TR><TD align="left">    getExpectedSeniorAssets(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getPresentValueWithNAVCalculation(address,uint256,uint256,uint256,uint256,Configuration.ASSET_PURPOSE)</TD></TR><TR><TD align="left">    getDaysPastDueByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getAdvanceRateByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getPenaltyRateByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getInterestRateByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getProbabilityOfDefaultByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getLossGivenDefaultByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getGracePeriodByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getCollectionPeriodByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getWriteOffAfterGracePeriodByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getWriteOffAfterCollectionPeriodByIdx(ISecuritizationPool,uint256)</TD></TR><TR><TD align="left">    getRiskScoreByIdx(address,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    RATE_SCALING_FACTOR</TD></TR></TABLE> >];

Interest[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Interest</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    chargeInterest(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    chargeLendingInterest(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _calculateInterestAmountToTimestamp(uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _calculateInterestAmountToTimestamp(uint256,uint256,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _calculateInterestForDuration(uint256,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_MULTIPLIER</TD></TR></TABLE> >];

NAVCalculation[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>NAVCalculation</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _calculateAssetValue(uint256,uint256,uint256,NAVCalculation.RiskScore,Configuration.ASSET_PURPOSE)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_DAYS</TD></TR><TR><TD align="left">    MINUTE_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    HOUR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    DAY_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    YEAR_LENGTH_IN_SECONDS</TD></TR><TR><TD align="left">    INTEREST_RATE_SCALING_FACTOR_PERCENT</TD></TR><TR><TD align="left">    ONE_HUNDRED_PERCENT</TD></TR></TABLE> >];

SecuritizationPoolServiceBase -> UntangledBase;
SecuritizationPoolServiceBase[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SecuritizationPoolServiceBase</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _convertTokenValueToCurrencyAmount(address,address,uint256)</TD></TR><TR><TD align="left">    _convertCurrencyAmountToTokenValue(address,address,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR></TABLE> >];

Registry -> UntangledBase;
Registry[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Registry</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize()</TD></TR><TR><TD align="left">    getAddress(uint8)</TD></TR><TR><TD align="left">    setSecuritizationManager(address)</TD></TR><TR><TD align="left">    setSecuritizationPool(address)</TD></TR><TR><TD align="left">    setNoteTokenFactory(address)</TD></TR><TR><TD align="left">    setTokenGenerationEventFactory(address)</TD></TR><TR><TD align="left">    setMintedIncreasingInterestTGE(address)</TD></TR><TR><TD align="left">    setMintedNormalTGE(address)</TD></TR><TR><TD align="left">    setDistributionOperator(address)</TD></TR><TR><TD align="left">    setDistributionAssessor(address)</TD></TR><TR><TD align="left">    setLoanAssetToken(address)</TD></TR><TR><TD align="left">    setAcceptedInvoiceToken(address)</TD></TR><TR><TD align="left">    setDistributionTranche(address)</TD></TR><TR><TD align="left">    setSecuritizationPoolValueService(address)</TD></TR><TR><TD align="left">    setLoanRegistry(address)</TD></TR><TR><TD align="left">    setLoanInterestTermsContract(address)</TD></TR><TR><TD align="left">    setLoanRepaymentRouter(address)</TD></TR><TR><TD align="left">    setLoanKernel(address)</TD></TR><TR><TD align="left">    setCollateralManagementToken(address)</TD></TR><TR><TD align="left">    setSupplyChainManagementProgram(address)</TD></TR><TR><TD align="left">    setInventoryLoanKernel(address)</TD></TR><TR><TD align="left">    setInventoryLoanRegistry(address)</TD></TR><TR><TD align="left">    setInventoryLoanRepaymentRouter(address)</TD></TR><TR><TD align="left">    setInventoryInterestTermsContract(address)</TD></TR><TR><TD align="left">    setInventoryCollateralizer(address)</TD></TR><TR><TD align="left">    setInvoiceLoanKernel(address)</TD></TR><TR><TD align="left">    setInvoiceDebtRegistry(address)</TD></TR><TR><TD align="left">    setInvoiceLoanRepaymentRouter(address)</TD></TR><TR><TD align="left">    setInvoiceFinanceInterestTermsContract(address)</TD></TR><TR><TD align="left">    setInvoiceCollateralizer(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setAddress(uint8,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    contractAddresses</TD></TR></TABLE> >];

CollateralManagementToken -> ERC1155PresetMinterPauserUpgradeable [ label="1" ];
CollateralManagementToken -> ERC1155SupplyUpgradeable [ label="2" ];
CollateralManagementToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>CollateralManagementToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(address,string,string,uint8,string)</TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    decimals()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left">    totalSupplyOfBatch(uint256[])</TD></TR><TR><TD align="left">    balanceOfProjects(address,uint256[])</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR><TR><TD align="left">    _decimals</TD></TR></TABLE> >];

FiatToken -> ERC20PresetMinterPauser;
FiatToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>FiatToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _d</TD></TR></TABLE> >];

NoteToken -> INoteToken;
NoteToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>NoteToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR></TABLE> >];

LoanAssetToken -> IUntangledERC721;
LoanAssetToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LoanAssetToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,string,string,string)</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(uint256,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getExpirationTimestamp(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRiskScore(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAssetPurpose(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getInterestRate(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTotalExpectedRepaymentValue(uint256,uint256)</font></TD></TR></TABLE> >];

AcceptedInvoiceToken -> IUntangledERC721;
AcceptedInvoiceToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AcceptedInvoiceToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(Registry,string,string,string)</TD></TR><TR><TD align="left">    createBatch(address[],uint256[],address[],uint256[],uint256[],uint8[])</TD></TR><TR><TD align="left">    payInBatch(uint256[],uint256[])</TD></TR><TR><TD align="left">    getExpectedRepaymentValues(uint256,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    getTotalExpectedRepaymentValue(uint256,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getExpirationTimestamp(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getInterestRate(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAssetPurpose(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRiskScore(uint256)</font></TD></TR><TR><TD align="left">    getFiatAmount(uint256)</TD></TR><TR><TD align="left">    isPaid(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _generateEntryHash(address,address,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _createAIT(address,address,uint256,address,uint256,uint256,uint8,Configuration.ASSET_PURPOSE)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    INVOICE_CREATOR_ROLE</TD></TR><TR><TD align="left">    entries</TD></TR></TABLE> >];

AssetsTransformation[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AssetsTransformation</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    payFee(uint256,address)</TD></TR><TR><TD align="left">    setupFee(uint256,uint256,address,address)</TD></TR><TR><TD align="left">    feePaymentStatus()</TD></TR><TR><TD align="left">    isCompletedFeesPayment()</TD></TR><TR><TD align="left">    getExpirationTime()</TD></TR><TR><TD align="left">    getCreatedTime()</TD></TR><TR><TD align="left">    getState()</TD></TR><TR><TD align="left">    validateExpirationTime()</TD></TR><TR><TD align="left">    expirationTimeLeft()</TD></TR><TR><TD align="left">    setExpirationTime(uint256)</TD></TR><TR><TD align="left">    isExpired()</TD></TR><TR><TD align="left">    getBeneficiaryByFeeId(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _transferFeeToBeneficiary(uint256,address,address)</TD></TR><TR><TD align="left">    _addFeeToken(address)</TD></TR><TR><TD align="left">    _addFeeTypeId(uint256)</TD></TR><TR><TD align="left">    _setupNewFeePayment(uint256,address)</TD></TR><TR><TD align="left">    _setupFee(uint256,uint256,address,address)</TD></TR><TR><TD align="left">    _newFeePaymentHasCompleted(address,uint256,address)</TD></TR><TR><TD align="left">    _newFeeReleaseHasCompleted(address,uint256,address)</TD></TR><TR><TD align="left">    _isCompletedFeePaymentWithToken(address)</TD></TR><TR><TD align="left">    _releaseFees()</TD></TR><TR><TD align="left">    _inState(AssetsTransformation.State)</TD></TR><TR><TD align="left">    _notInState(AssetsTransformation.State)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyCreator()</TD></TR><TR><TD align="left">    onlyTokenOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    creator</TD></TR><TR><TD align="left">    tokenOwner</TD></TR><TR><TD align="left">    tokenAddress</TD></TR><TR><TD align="left">    referenceID</TD></TR><TR><TD align="left">    amount</TD></TR><TR><TD align="left">    createdTime</TD></TR><TR><TD align="left">    expirationTime</TD></TR><TR><TD align="left">    isFeeTokens</TD></TR><TR><TD align="left">    feeTokens</TD></TR><TR><TD align="left">    requiredFees</TD></TR><TR><TD align="left">    isRequiredFeeTypes</TD></TR><TR><TD align="left">    requiredFeeTypeIds</TD></TR><TR><TD align="left">    tokenFeeAmounts</TD></TR><TR><TD align="left">    paidTokenFeeAmounts</TD></TR><TR><TD align="left">    releasedTokenFeeAmounts</TD></TR><TR><TD align="left">    state</TD></TR><TR><TD align="left">    tokenType</TD></TR></TABLE> >];

TokenTopup -> AssetsTransformation;
TokenTopup[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TokenTopup</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    submitExpirationRelease()</TD></TR><TR><TD align="left">    cancel()</TD></TR><TR><TD align="left">    complete()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _topupTermination()</TD></TR><TR><TD align="left">    _releaseTopup()</TD></TR></TABLE> >];

TokenTopupController -> UntangledBase;
TokenTopupController[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TokenTopupController</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize()</TD></TR><TR><TD align="left">    newTopup(string,address,uint8,address,uint256,uint256)</TD></TR><TR><TD align="left">    contractAddressOf(string)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    topups</TD></TR></TABLE> >];

EReceiptInventoryTrade -> Initializable [ label="1" ];
EReceiptInventoryTrade -> PausableUpgradeable [ label="2" ];
EReceiptInventoryTrade -> OwnableUpgradeable [ label="3" ];
EReceiptInventoryTrade -> ERC1155ReceiverUpgradeable [ label="4" ];
EReceiptInventoryTrade[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EReceiptInventoryTrade</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(address[4],uint256[2],uint256[2],uint256,uint256[2])</TD></TR><TR><TD align="left">    setupOptionalFee(uint256,address,uint256,address,address)</TD></TR><TR><TD align="left">    removeOptionalFee(uint256,address,address)</TD></TR><TR><TD align="left">    isCompletedFeesPayment(address)</TD></TR><TR><TD align="left">    feePaymentStatus(address)</TD></TR><TR><TD align="left">    expirationTimeLeft()</TD></TR><TR><TD align="left">    isExpired()</TD></TR><TR><TD align="left">    isCompleted()</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155Received(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left">    setExpirationTime(uint256)</TD></TR><TR><TD align="left">    updateCommodityTokenIndex(uint256)</TD></TR><TR><TD align="left">    updateFiatTokenAddress(address)</TD></TR><TR><TD align="left">    updateBuyerPaymentAmount(uint256)</TD></TR><TR><TD align="left">    updateSellerPaymentAmount(uint256)</TD></TR><TR><TD align="left">    checkExpirationTime()</TD></TR><TR><TD align="left">    paymentStatusCheck()</TD></TR><TR><TD align="left">    payFee(address,uint256,address)</TD></TR><TR><TD align="left">    submitExpirationRelease()</TD></TR><TR><TD align="left">    doFiatPayment(uint256)</TD></TR><TR><TD align="left">    doCommodityPayment(uint256)</TD></TR><TR><TD align="left">    initLoanForTrade(address,address[6],uint256[7],bytes32[1],bytes16[1],address[5],address[5],uint256[5],uint256[5])</TD></TR><TR><TD align="left">    swap()</TD></TR><TR><TD align="left">    abortTrade()</TD></TR><TR><TD align="left">    getContractState()</TD></TR><TR><TD align="left">    getSellerPaymentStatus()</TD></TR><TR><TD align="left">    getTradeInfo()</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _isOptionalFeeType(uint256)</TD></TR><TR><TD align="left">    _isMandatoryFeeType(uint256)</TD></TR><TR><TD align="left">    _addPayer(address)</TD></TR><TR><TD align="left">    _addOptionalFeeTypeId(uint256)</TD></TR><TR><TD align="left">    _addMandatoryFeeTypeId(uint256)</TD></TR><TR><TD align="left">    _addFeeToken(address)</TD></TR><TR><TD align="left">    _addMandatoryFeeToken(address)</TD></TR><TR><TD align="left">    _transferFeeToBeneficiary(address,uint256,address,address)</TD></TR><TR><TD align="left">    _transferTokensFrom(address,address,address,uint256)</TD></TR><TR><TD align="left">    _setupFee(uint256,address,uint256,address,address,bool)</TD></TR><TR><TD align="left">    _newFeePaymentHasCompleted(address,uint256,address)</TD></TR><TR><TD align="left">    _newFeeReleaseHasCompleted(address,uint256,address)</TD></TR><TR><TD align="left">    _setupNewFeePayment(address,uint256,address)</TD></TR><TR><TD align="left">    _doFeePayment(address,uint256,address)</TD></TR><TR><TD align="left">    _isCompletedFeePaymentWithToken(address,address)</TD></TR><TR><TD align="left">    _refundOptionalFees()</TD></TR><TR><TD align="left">    _releaseOptionalFees()</TD></TR><TR><TD align="left">    _transferFeeToBeneficiaries()</TD></TR><TR><TD align="left">    _inState(EReceiptInventoryTrade.State)</TD></TR><TR><TD align="left">    _paymentStatusCheck()</TD></TR><TR><TD align="left">    _newFiatPayment(uint256)</TD></TR><TR><TD align="left">    _newCommodityPayment(uint256)</TD></TR><TR><TD align="left">    returnPaymentAmountAndCollectFee()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyFeePayer()</TD></TR><TR><TD align="left">    onlyUncompletedTrade()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry<font color="blue" POINT-SIZE="10"> (Registry)</font></TD></TR><TR><TD align="left">    isRefundedOptionalFees</TD></TR><TR><TD align="left">    isFeePayers</TD></TR><TR><TD align="left">    feePayers</TD></TR><TR><TD align="left">    isOptionalFeeTypeIds</TD></TR><TR><TD align="left">    optionalFeeTypeIds</TD></TR><TR><TD align="left">    isMandatoryFeeTypeIds</TD></TR><TR><TD align="left">    mandatoryFeeTypeIds</TD></TR><TR><TD align="left">    isFeeTokens</TD></TR><TR><TD align="left">    feeTokens</TD></TR><TR><TD align="left">    isMandatoryFeeTokens</TD></TR><TR><TD align="left">    mandatoryFeeTokens</TD></TR><TR><TD align="left">    requiredFees</TD></TR><TR><TD align="left">    hasSetupFees</TD></TR><TR><TD align="left">    tokenFeeAmounts</TD></TR><TR><TD align="left">    paidTokenFeeAmounts</TD></TR><TR><TD align="left">    seller</TD></TR><TR><TD align="left">    buyer</TD></TR><TR><TD align="left">    expirationTime</TD></TR><TR><TD align="left">    creationTime</TD></TR><TR><TD align="left">    principalAmount</TD></TR><TR><TD align="left">    debtorFee</TD></TR><TR><TD align="left">    loanAgreementId</TD></TR><TR><TD align="left">    state</TD></TR><TR><TD align="left">    buyerPayment</TD></TR><TR><TD align="left">    sellerPayment</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    releasedTokenAmounts</TD></TR></TABLE> >];

EReceiptInventoryTradeFactory -> Initializable [ label="1" ];
EReceiptInventoryTradeFactory -> PausableUpgradeable [ label="2" ];
EReceiptInventoryTradeFactory -> OwnableUpgradeable [ label="3" ];
EReceiptInventoryTradeFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EReceiptInventoryTradeFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initialize(address)</TD></TR><TR><TD align="left">    newContract(string,address[3],uint256[2],uint256[2],uint256,uint256[2])</TD></TR><TR><TD align="left">    contractAddressOf(string)</TD></TR><TR><TD align="left">    isExistedTrade(address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _addReferenceId(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyIfReferenceIdNotInUse(string)</TD></TR><TR><TD align="left">    onlyExistedTrade(address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    registry</TD></TR><TR><TD align="left">    tradeContracts</TD></TR><TR><TD align="left">    existedTrade</TD></TR><TR><TD align="left">    isExistingReferenceId</TD></TR></TABLE> >];

}
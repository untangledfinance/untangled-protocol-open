{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"../extensions/ERC721BurnableUpgradeable.sol\";\nimport \"../extensions/ERC721PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC721PresetMinterPauserAutoIdUpgradeable is\n    Initializable, ContextUpgradeable,\n    AccessControlEnumerableUpgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721BurnableUpgradeable,\n    ERC721PausableUpgradeable\n{\n    function initialize(string memory name, string memory symbol, string memory baseTokenURI) public virtual initializer {\n        __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);\n    }\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    CountersUpgradeable.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n     * See {ERC721-tokenURI}.\n     */\n    function __ERC721PresetMinterPauserAutoId_init(string memory name, string memory symbol, string memory baseTokenURI) internal onlyInitializing {\n        __ERC721_init_unchained(name, symbol);\n        __Pausable_init_unchained();\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __ERC721PresetMinterPauserAutoId_init_unchained(string memory, string memory, string memory baseTokenURI) internal onlyInitializing {\n        _baseTokenURI = baseTokenURI;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/base/IPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IPauseable {\n    function pause() external;\n    function unpause() external;\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/base/UntangledBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\n\nimport '../libraries/Configuration.sol';\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Abstract contract that serves as a base contract for other contracts in the Untangled system.\n *  It provides functionalities for contract initialization, pausing, and access control.\n * @author Untangled Team\n */\nabstract contract UntangledBase is\n    Initializable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\n\n    function isAdmin() public view virtual returns (bool) {\n        return hasRole(OWNER_ROLE, _msgSender());\n    }\n\n    modifier onlyAdmin() {\n        require(isAdmin(), 'UntangledBase: Must have admin role to perform this action');\n        _;\n    }\n\n    function __UntangledBase__init(address owner) internal onlyInitializing {\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n        __UntangledBase__init_unchained(owner);\n    }\n\n    function __UntangledBase__init_unchained(address owner) internal onlyInitializing {\n        if (owner == address(0)) owner = _msgSender();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(OWNER_ROLE, owner);\n\n        _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n    }\n\n    function getInitializedVersion() public view virtual returns (uint256) {\n        return _getInitializedVersion();\n    }\n\n    function pause() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/ICrowdSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ICrowdSale} from '../protocol/note-sale/crowdsale/ICrowdSale.sol';\n"
    },
    "contracts/interfaces/IDistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IDistributionAssessor} from '../protocol/pool/IDistributionAssessor.sol';\n"
    },
    "contracts/interfaces/IDistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IDistributionOperator} from '../protocol/pool/IDistributionOperator.sol';\n"
    },
    "contracts/interfaces/IDistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../protocol/pool/IDistributionTranche.sol';"
    },
    "contracts/interfaces/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IGo} from '../protocol/IGo.sol';\n"
    },
    "contracts/interfaces/ILoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanAssetToken} from '../tokens/ERC721/ILoanAssetToken.sol';\n"
    },
    "contracts/interfaces/ILoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanInterestTermsContract} from '../protocol/loan/ILoanInterestTermsContract.sol';\n"
    },
    "contracts/interfaces/ILoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanKernel} from '../protocol/loan/ILoanKernel.sol';\n"
    },
    "contracts/interfaces/ILoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanRegistry} from '../protocol/loan/ILoanRegistry.sol';\n"
    },
    "contracts/interfaces/ILoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../protocol/loan/ILoanRepaymentRouter.sol';"
    },
    "contracts/interfaces/INoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {INoteToken} from '../tokens/ERC20/INoteToken.sol';\n"
    },
    "contracts/interfaces/INoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {INoteTokenFactory} from './../protocol/note-sale/fab/INoteTokenFactory.sol';\n"
    },
    "contracts/interfaces/ISecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ISecuritizationManager} from '../protocol/pool/ISecuritizationManager.sol';\n"
    },
    "contracts/interfaces/ISecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport {ISecuritizationPool} from '../protocol/pool/ISecuritizationPool.sol';\n"
    },
    "contracts/interfaces/ISecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ISecuritizationPoolValueService} from '../protocol/pool/ISecuritizationPoolValueService.sol';\n"
    },
    "contracts/interfaces/ITokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ITokenGenerationEventFactory} from '../protocol/note-sale/fab/ITokenGenerationEventFactory.sol';\n"
    },
    "contracts/interfaces/IUntangledERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IUntangledERC721} from '../tokens/ERC721/IUntangledERC721.sol';\n"
    },
    "contracts/libraries/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../storage/Registry.sol';\nimport {Configuration} from './Configuration.sol';\n\nimport {ISecuritizationManager} from '../interfaces/ISecuritizationManager.sol';\nimport {ISecuritizationPool} from '../interfaces/ISecuritizationPool.sol';\nimport {INoteTokenFactory} from '../interfaces/INoteTokenFactory.sol';\nimport {INoteToken} from '../interfaces/INoteToken.sol';\nimport {ITokenGenerationEventFactory} from '../interfaces/ITokenGenerationEventFactory.sol';\nimport {IUntangledERC721} from '../interfaces/IUntangledERC721.sol';\nimport {IDistributionOperator} from '../interfaces/IDistributionOperator.sol';\nimport {IDistributionTranche} from '../interfaces/IDistributionTranche.sol';\nimport {ILoanRegistry} from '../interfaces/ILoanRegistry.sol';\nimport {ILoanInterestTermsContract} from '../interfaces/ILoanInterestTermsContract.sol';\nimport {ILoanRepaymentRouter} from '../interfaces/ILoanRepaymentRouter.sol';\nimport {ILoanKernel} from '../interfaces/ILoanKernel.sol';\nimport {ILoanAssetToken} from '../interfaces/ILoanAssetToken.sol';\nimport {IDistributionAssessor} from '../interfaces/IDistributionAssessor.sol';\nimport {ISecuritizationPoolValueService} from '../interfaces/ISecuritizationPoolValueService.sol';\n\nimport {MintedIncreasingInterestTGE} from '../protocol/note-sale/MintedIncreasingInterestTGE.sol';\nimport {MintedNormalTGE} from '../protocol/note-sale/MintedNormalTGE.sol';\nimport {IGo} from '../interfaces/IGo.sol';\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the Registry contract\n * @author Untangled Team\n */\nlibrary ConfigHelper {\n    function getAddress(Registry registry, Configuration.CONTRACT_TYPE contractType) internal view returns (address) {\n        return registry.getAddress(uint8(contractType));\n    }\n\n    function getSecuritizationManager(Registry registry) internal view returns (ISecuritizationManager) {\n        return ISecuritizationManager(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER));\n    }\n\n    function getSecuritizationPool(Registry registry) internal view returns (ISecuritizationPool) {\n        return ISecuritizationPool(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL));\n    }\n\n    function getNoteTokenFactory(Registry registry) internal view returns (INoteTokenFactory) {\n        return INoteTokenFactory(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY));\n    }\n\n    // function getNoteToken(Registry registry) internal view returns (INoteToken) {\n    //     return INoteToken(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN));\n    // }\n\n    function getTokenGenerationEventFactory(Registry registry) internal view returns (ITokenGenerationEventFactory) {\n        return\n            ITokenGenerationEventFactory(\n                getAddress(registry, Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY)\n            );\n    }\n\n    function getDistributionOperator(Registry registry) internal view returns (IDistributionOperator) {\n        return IDistributionOperator(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR));\n    }\n\n    function getLoanAssetToken(Registry registry) internal view returns (ILoanAssetToken) {\n        return ILoanAssetToken(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN));\n    }\n\n    function getLoanRegistry(Registry registry) internal view returns (ILoanRegistry) {\n        return ILoanRegistry(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REGISTRY));\n    }\n\n    function getLoanInterestTermsContract(Registry registry) internal view returns (ILoanInterestTermsContract) {\n        return\n            ILoanInterestTermsContract(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT));\n    }\n\n    function getLoanRepaymentRouter(Registry registry) internal view returns (ILoanRepaymentRouter) {\n        return ILoanRepaymentRouter(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER));\n    }\n\n    function getLoanKernel(Registry registry) internal view returns (ILoanKernel) {\n        return ILoanKernel(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_KERNEL));\n    }\n\n    function getDistributionTranche(Registry registry) internal view returns (IDistributionTranche) {\n        return IDistributionTranche(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE));\n    }\n\n    function getSecuritizationPoolValueService(\n        Registry registry\n    ) internal view returns (ISecuritizationPoolValueService) {\n        return\n            ISecuritizationPoolValueService(\n                getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE)\n            );\n    }\n\n    function getDistributionAssessor(Registry registry) internal view returns (IDistributionAssessor) {\n        return IDistributionAssessor(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR));\n    }\n\n    // function getMintedIncreasingInterestTGE(Registry registry) internal view returns (MintedIncreasingInterestTGE) {\n    //     return\n    //         MintedIncreasingInterestTGE(\n    //             getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE)\n    //         );\n    // }\n\n    // function getMintedNormalTGE(Registry registry) internal view returns (MintedNormalTGE) {\n    //     return MintedNormalTGE(getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE));\n    // }\n\n    function getGo(Registry registry) internal view returns (IGo) {\n        return IGo(getAddress(registry, Configuration.CONTRACT_TYPE.GO));\n    }\n}\n"
    },
    "contracts/libraries/Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Configuration\n/// @author Untangled Team\nlibrary Configuration {\n    uint256 public constant PRICE_SCALING_FACTOR = 10 ** 4;\n\n    // NEVER EVER CHANGE THE ORDER OF THESE!\n    // You can rename or append. But NEVER change the order.\n    enum CONTRACT_TYPE {\n        SECURITIZATION_MANAGER,\n        SECURITIZATION_POOL,\n        NOTE_TOKEN_FACTORY,\n        NOTE_TOKEN, // deprecated\n        TOKEN_GENERATION_EVENT_FACTORY,\n        DISTRIBUTION_OPERATOR,\n        DISTRIBUTION_ASSESSOR,\n        DISTRIBUTION_TRANCHE,\n        LOAN_ASSET_TOKEN,\n        ACCEPTED_INVOICE_TOKEN,\n        LOAN_REGISTRY,\n        LOAN_INTEREST_TERMS_CONTRACT,\n        LOAN_REPAYMENT_ROUTER,\n        LOAN_KERNEL,\n        ERC20_TOKEN_REGISTRY,\n        ERC20_TOKEN_TRANSFER_PROXY,\n        SECURITIZATION_MANAGEMENT_PROJECT,\n        SECURITIZATION_POOL_VALUE_SERVICE,\n        MINTED_INCREASING_INTEREST_TGE, // depreacated\n        MINTED_NORMAL_TGE, // depreacated\n        INVOICE_COLLATERALIZER,\n        INVOICE_DEBT_REGISTRY,\n        INVOICE_FINANCE_INTEREST_TERMS_CONTRACT,\n        INVOICE_LOAN_KERNEL,\n        INVOICE_LOAN_REPAYMENT_ROUTER,\n        GO\n    }\n\n    enum NOTE_TOKEN_TYPE {\n        SENIOR,\n        JUNIOR\n    }\n\n    enum ASSET_PURPOSE {\n        LOAN,\n        INVOICE\n    }\n}\n"
    },
    "contracts/libraries/UntangledMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title UntangledMath\n/// @author Untangled Team\nlibrary UntangledMath {\n    uint256 public constant ONE = 10**27;\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    function uncheckedInc(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + 1;\n        }\n    }\n}\n"
    },
    "contracts/protocol/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IUniqueIdentity} from \"../uid/IUniqueIdentity.sol\";\n\nabstract contract IGo {\n  uint256 public constant ID_TYPE_0 = 0; // non-US individual\n  uint256 public constant ID_TYPE_1 = 1; // US accredited individual\n  uint256 public constant ID_TYPE_2 = 2; // US non accredited individual\n  uint256 public constant ID_TYPE_3 = 3; // US entity\n  uint256 public constant ID_TYPE_4 = 4; // non-US entity\n  uint256 public constant ID_TYPE_5 = 5;\n  uint256 public constant ID_TYPE_6 = 6;\n  uint256 public constant ID_TYPE_7 = 7;\n  uint256 public constant ID_TYPE_8 = 8;\n  uint256 public constant ID_TYPE_9 = 9;\n  uint256 public constant ID_TYPE_10 = 10;\n\n  /// @notice Returns the address of the UniqueIdentity contract.\n  function uniqueIdentity() external virtual returns (IUniqueIdentity);\n\n  function go(address account) public view virtual returns (bool);\n\n  function goOnlyIdTypes(\n    address account,\n    uint256[] memory onlyIdTypes\n  ) public view virtual returns (bool);\n}\n"
    },
    "contracts/protocol/loan/ILoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\n\nabstract contract ILoanInterestTermsContract {\n    Registry public registry;\n\n    mapping(bytes32 => bool) public startedLoan;\n\n    mapping(bytes32 => uint256) public repaidPrincipalAmounts;\n    mapping(bytes32 => uint256) public repaidInterestAmounts;\n\n    mapping(bytes32 => bool) public completedRepayment;\n\n    /// @notice register the start of a loan term\n    function registerTermStart(bytes32 agreementId) public virtual returns (bool);\n\n    /// @notice the total amount of principal and interest repaid for a given loan agreement\n    function getValueRepaidToDate(bytes32 agreementId) public view virtual returns (uint256, uint256);\n\n    /// @notice checks whether the repayments for a batch of loan agreements have been completed\n    function isCompletedRepayments(bytes32[] memory agreementIds) public view virtual returns (bool[] memory);\n\n    /**\n     * Expected repayment value with Amortization of Interest and Principal\n     * (AMORTIZATION) - will be used for repayment from Debtor\n     */\n    /// @notice calculates the expected repayment values (principal and interest) for a given loan agreement and timestamp\n    /// @param agreementId loan asset token in bytes32 format\n    /// @param timestamp unix timestamp\n    /// @return expectedPrincipal value of loan at a specific time\n    /// @return expectedInterest interest value at a specific time\n    function getExpectedRepaymentValues(\n        bytes32 agreementId,\n        uint256 timestamp\n    ) public view virtual returns (uint256 expectedPrincipal, uint256 expectedInterest);\n\n    /// @notice calculates the expected repayment values (principal and interest) for a batch of loan agreements and a given timestamp\n    function getMultiExpectedRepaymentValues(\n        bytes32[] memory agreementIds,\n        uint256 timestamp\n    ) public view virtual returns (uint256[] memory, uint256[] memory);\n\n    /// @dev set loan as repaid\n    function registerConcludeLoan(bytes32 agreementId) external virtual returns (bool);\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @notice register a loan repayment\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  payer address. The address of the payer.\n    /// @param  beneficiary address. The address of the payment's beneficiary.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    function registerRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public virtual returns (uint256 remains);\n\n    /// @notice the interest rate for a given loan agreement\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    function getInterestRate(bytes32 agreementId) public view virtual returns (uint256);\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/protocol/loan/ILoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport '../../tokens/ERC721/types.sol';\n\nabstract contract ILoanKernel {\n    Registry public registry;\n\n    /****************** */\n    // CONSTANTS\n    /****************** */\n    enum Errors {\n        // Debt has been already been issued\n        DEBT_ISSUED, // 0\n        // Order has already expired\n        ORDER_EXPIRED, // 1\n        // Debt issuance associated with order has been cancelled\n        ISSUANCE_CANCELLED, // 2\n        // Order has been cancelled\n        ORDER_CANCELLED, // 3\n        // Order parameters specify amount of creditor / debtor fees\n        // that is not equivalent to the amount of underwriter / relayer fees\n        ORDER_INVALID_INSUFFICIENT_OR_EXCESSIVE_FEES, // 4\n        // Order parameters specify insufficient principal amount for\n        // debtor to at least be able to meet his fees\n        ORDER_INVALID_INSUFFICIENT_PRINCIPAL, // 5\n        // Order parameters specify non zero fee for an unspecified recipient\n        ORDER_INVALID_UNSPECIFIED_FEE_RECIPIENT, // 6\n        // Order signatures are mismatched / malformed\n        ORDER_INVALID_NON_CONSENSUAL, // 7\n        // Insufficient balance or allowance for principal token transfer\n        CREDITOR_BALANCE_OR_ALLOWANCE_INSUFFICIENT, // 8\n        // Debt doesn't exists\n        DEBT_NOT_EXISTS, // 9\n        // Debtor it not completed repayment yet\n        NOT_COMPLETED_REPAYMENT // 10\n    }\n\n    enum FillingAddressesIndex {\n        SECURITIZATION_POOL,\n        PRINCIPAL_TOKEN_ADDRESS,\n        REPAYMENT_ROUTER,\n        TERM_CONTRACT,\n        RELAYER\n    }\n\n    enum FillingNumbersIndex {\n        CREDITOR_FEE,\n        ASSET_PURPOSE\n    }\n\n    bytes32 public constant NULL_ISSUANCE_HASH = bytes32(0);\n    bytes16 public constant NULL_COLLATERAL_INFO_HASH = bytes16(0);\n    address public constant NULL_ADDRESS = address(0x0);\n    //********************************************************* */\n\n    //****** */\n    // EVENTS\n    //****** */\n    event LogDebtKernelError(uint8 indexed _errorId, bytes32 indexed _orderHash, string desc);\n\n    event LogFeeTransfer(address indexed payer, address token, uint256 amount, address indexed beneficiary);\n\n    event IssuedNewInputLoans(address[] debtor, uint256[] loanTokenIds);\n\n    event LogDebtOrderFilled(bytes32 _agreementId, uint256 _principal, address _principalToken, address _relayer);\n\n    //********************************************************* */\n\n    /*********** */\n    // STRUCTURES\n    /*********** */\n\n    struct LoanIssuance {\n        address version;\n        address termsContract;\n        address[] debtors;\n        bytes32[] termsContractParameters; // for different loans\n        bytes32[] agreementIds;\n        uint256[] salts;\n    }\n\n    struct LoanOrder {\n        LoanIssuance issuance;\n        address principalTokenAddress;\n        uint256[] principalAmounts;\n        uint256 creditorFee;\n        address relayer;\n        uint256[] expirationTimestampInSecs;\n        bytes32[] debtOrderHashes;\n        uint8[] riskScores;\n        uint8 assetPurpose;\n    }\n\n    struct FillDebtOrderParam {\n        address[] orderAddresses; // 0-pool, 1-principal token address, 2-repayment router, 3-term contract, 4-relayer,...\n        uint256[] orderValues; //  0-creditorFee, 1-asset purpose,..., [x] principalAmounts, [x] expirationTimestampInSecs, [x] - salts, [x] - riskScores\n        bytes32[] termsContractParameters; // Term contract parameters from different farmers, encoded as hash strings\n        LoanAssetInfo[] latInfo;\n    }\n\n    /*********** */\n    // VARIABLES\n    /*********** */\n    mapping(bytes32 => bool) public issuanceCancelled;\n    mapping(bytes32 => bool) public debtOrderCancelled;\n    mapping(bytes32 => bool) public debtOrderCompleted;\n\n    /// @notice conclude a loan by stopping lending/loan terms or allowing the loan loss. It takes the creditor, agreement ID, and term contract as input\n    function concludeLoan(address creditor, bytes32 agreementId, address termContract) public virtual;\n}\n"
    },
    "contracts/protocol/loan/ILoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\n\nabstract contract ILoanRegistry {\n    Registry public registry;\n\n    // loan -> debtors\n    struct LoanEntry {\n        address loanTermContract;\n        address debtor;\n        address principalTokenAddress;\n        bytes32 termsParam; // actually inside this param was already included P token address\n        uint256 salt;\n        uint256 issuanceBlockTimestamp;\n        uint256 lastRepayTimestamp;\n        uint256 expirationTimestamp;\n        uint8 riskScore;\n        Configuration.ASSET_PURPOSE assetPurpose;\n    }\n\n    event UpdateLoanEntry(bytes32 indexed tokenId, LoanEntry entry);\n    event UpdateCompleteLoan(bytes32 indexed tokenId, bool status);\n\n    mapping(bytes32 => LoanEntry) public entries;\n\n    mapping(bytes32 => bool) public manualInterestLoan;\n    mapping(bytes32 => uint256) public manualInterestAmountLoan;\n\n    mapping(bytes32 => bool) public completedLoans;\n\n    function initialize(Registry _registry) public virtual;\n\n    /**\n     * Record new External Loan to blockchain\n     */\n    function insert(\n        bytes32 tokenId,\n        address termContract,\n        address debtor,\n        bytes32 termsContractParameter,\n        address pTokenAddress,\n        uint256 _salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] calldata assetPurposeAndRiskScore\n    ) external virtual returns (bool);\n\n    /// @notice retrieves loan information\n    function getEntry(bytes32 agreementId) public view virtual returns (LoanEntry memory);\n\n    /// @notice retrieves the debtor's address for a given loan\n    function getLoanDebtor(bytes32 tokenId) public view virtual returns (address);\n\n    /// @notice retrieves the term contract parameters for a given loan\n    function getLoanTermParams(bytes32 tokenId) public view virtual returns (bytes32);\n\n    /// @notice retrieves the principal token address for a given loan agreement ID\n    function getPrincipalTokenAddress(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the debtor's address for a given loan agreement ID\n    function getDebtor(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the term contract address for a given loan agreement ID\n    function getTermContract(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the risk score for a given loan agreement ID\n    function getRiskScore(bytes32 agreementId) public view virtual returns (uint8);\n\n    /// @notice retrieves the asset purpose for a given loan agreement ID\n    function getAssetPurpose(bytes32 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n\n    /// @notice retrieves the timestamp of the block at which a debt agreement was issued\n    function getIssuanceBlockTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    /// @notice retrieves the timestamp of the last repayment made for a given loan agreement ID\n    function getLastRepaymentTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    /// @notice retrieves the terms contract parameters for a given loan agreement ID\n    function getTermsContractParameters(bytes32 agreementId) public view virtual returns (bytes32);\n\n    /// @notice retrieves the expiration timestamp for a given loan agreement ID\n    function getExpirationTimestamp(bytes32 agreementId) public view virtual returns (uint256);\n\n    /// @notice updates the timestamp of the last repayment made for a given loan agreement ID\n    function updateLastRepaymentTimestamp(bytes32 agreementId, uint256 newTimestamp) public virtual;\n\n    /// @notice retrieves information about the principal payment for a given loan agreement ID\n    /// @dev Get principal payment info before start doing repayment\n    function principalPaymentInfo(\n        bytes32 agreementId\n    ) public view virtual returns (address pTokenAddress, uint256 pAmount);\n\n    /// @notice marks a loan agreement as completed by setting the completedLoans mapping entry to true for a given agreement ID\n    function setCompletedLoan(bytes32 agreementId) public virtual;\n}\n"
    },
    "contracts/protocol/loan/ILoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {UntangledBase} from '../../base/UntangledBase.sol';\nimport {Registry} from '../../storage/Registry.sol';\n\nabstract contract ILoanRepaymentRouter is UntangledBase {\n    Registry public registry;\n\n    enum Errors {\n        DEBT_AGREEMENT_NONEXISTENT,\n        PAYER_BALANCE_OR_ALLOWANCE_INSUFFICIENT,\n        REPAYMENT_REJECTED_BY_TERMS_CONTRACT\n    }\n\n    event LogOutputSubmit(bytes32 indexed _agreementId, uint256 indexed _tokenIndex, uint256 _totalAmount);\n\n    function initialize(Registry _registry) public virtual;\n\n    event LogRepayment(\n        bytes32 indexed _agreementId,\n        address indexed _payer,\n        address indexed _beneficiary,\n        uint256 _amount,\n        address _token\n    );\n\n    event LogRepayments(bytes32[] _agreementIds, address _payer, uint256[] _amounts);\n\n    event LogError(uint8 indexed _errorId, bytes32 indexed _agreementId);\n\n    /// @notice allows batch repayment of multiple loans by iterating over the given agreement IDs and amounts\n    /// @dev calls _assertRepaymentRequest and _doRepay for each repayment, and emits the LogRepayments event to indicate the successful batch repayment\n    function repayInBatch(\n        bytes32[] calldata agreementIds,\n        uint256[] calldata amounts,\n        address tokenAddress\n    ) external virtual returns (bool);\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/base/LongSaleInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../libraries/UntangledMath.sol';\n\n/// @title LongSaleInterest\n/// @author Untangled Team\n/// @dev Define some constant for interest calculation\ncontract LongSaleInterest {\n    /// @dev represents the number of days in a year\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    /// @dev represents the number of seconds in a minute\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    /// @dev represents the number of seconds in an hour\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    /// @dev represents the number of seconds in a day\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    /// @dev represents the number of seconds in a year\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    /// @dev A constant used to convert an encoded interest rate into its equivalent in percentage.\n    /// To convert an encoded interest rate to a percentage, divide it by this scaling factor\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n    /// @dev represents the scaling factor for the purchase price calculation\n    uint256 public constant PURCHASE_PRICE_SCALING_FACTOR = 10**4;\n\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/Crowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../base/UntangledBase.sol';\nimport '../../pool/ISecuritizationPool.sol';\n\nimport {ConfigHelper} from '../../../libraries/ConfigHelper.sol';\nimport '../../../interfaces/INoteToken.sol';\nimport '../../../interfaces/ICrowdSale.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nabstract contract Crowdsale is UntangledBase, ICrowdSale {\n    using ConfigHelper for Registry;\n\n    event UpdateTotalCap(uint256 totalCap);\n\n    Registry public registry;\n\n    // decimal calculating for rate\n    uint256 public constant RATE_SCALING_FACTOR = 10 ** 4;\n\n    /// @dev Pool address which this sale belongs to\n    address public override pool;\n\n    /// @dev The token being sold\n    address public override token;\n\n    /// @dev The token being sold\n    address public currency;\n\n    // How many token units a buyer gets per currency.\n    uint256 public rate; // support by RATE_SCALING_FACTOR decimal numbers\n    bool public hasStarted;\n    uint64 public firstNoteTokenMintedTimestamp; // Timestamp at which the first asset is collected to pool\n\n    /// @dev Amount of currency raised\n    uint256 internal _currencyRaised;\n\n    /// @dev Amount of token raised\n    uint256 public tokenRaised;\n\n    /// @dev Target raised currency amount\n    uint256 public totalCap;\n\n    mapping(address => uint256) public _currencyRaisedByInvestor;\n\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    function __Crowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __UntangledBase__init_unchained(_msgSender());\n        registry = _registry;\n        pool = _pool;\n        token = _token;\n        currency = _currency;\n    }\n\n    modifier securitizationPoolRestricted() {\n        require(_msgSender() == pool, 'Crowdsale: Caller must be pool');\n        _;\n    }\n\n    modifier smpRestricted() {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: Caller must be securitization manager'\n        );\n        _;\n    }\n\n    function currencyRaisedByInvestor(address investor) public view returns (uint256) {\n        return _currencyRaisedByInvestor[investor];\n    }\n\n    /// @notice add funding amount to be added to the total cap\n    function addFunding(uint256 additionalCap) public nonReentrant whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: caller must be owner or pool'\n        );\n        require(additionalCap > 0, 'Crowdsale: total cap is 0');\n\n        totalCap = additionalCap + totalCap;\n\n        emit UpdateTotalCap(totalCap);\n    }\n\n    /// @notice Set hasStarted variable\n    function setHasStarted(bool _hasStarted) public {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: caller must be owner or manager'\n        );\n        hasStarted = _hasStarted;\n\n        emit SetHasStarted(hasStarted);\n    }\n\n    /// @notice Sets the rate variable to the new rate\n    function _newSaleRound(uint256 newRate) internal {\n        require(!hasStarted, 'Crowdsale: Sale round overflow');\n\n        rate = newRate;\n    }\n\n    /// @notice  Allows users to buy note token\n    /// @param payee pay for purchase\n    /// @param beneficiary wallet receives note token\n    /// @param currencyAmount amount of currency used for purchase\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public virtual whenNotPaused nonReentrant smpRestricted returns (uint256) {\n        uint256 tokenAmount = getTokenAmount(currencyAmount);\n\n        _preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n\n        // update state\n        _currencyRaised += currencyAmount;\n        _currencyRaisedByInvestor[beneficiary] += currencyAmount;\n\n        tokenRaised += tokenAmount;\n\n        _claimPayment(payee, currencyAmount);\n        _processPurchase(beneficiary, tokenAmount);\n        emit TokensPurchased(_msgSender(), beneficiary, currencyAmount, tokenAmount);\n\n        _forwardFunds(ISecuritizationPool(pool).pot(), currencyAmount);\n\n        return tokenAmount;\n    }\n\n    /// @notice Check if the total amount of currency raised is equal to the total cap\n    function isDistributedFully() public view returns (bool) {\n        return _currencyRaised == totalCap;\n    }\n\n    /// @notice Catch event redeem token\n    /// @param currencyAmount amount of currency investor want to redeem\n    function onRedeem(uint256 currencyAmount) public virtual override {\n        require(\n            _msgSender() == address(registry.getDistributionOperator()),\n            'Crowdsale: Caller must be distribution operator'\n        );\n        _currencyRaised -= currencyAmount;\n    }\n\n    /// @notice Retrieves the remaining token balance held by the crowdsale contract\n    function getTokenRemainAmount() public view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    /// @notice Calculates the remaining amount of currency available for purchase\n    function getCurrencyRemainAmount() public view virtual returns (uint256) {\n        return totalCap - _currencyRaised;\n    }\n\n    /// @notice Determines whether the current sale round is a long sale\n    /// @dev This is an abstract function that needs to be implemented in derived contracts\n    function isLongSale() public view virtual returns (bool);\n\n    /// @notice Calculates the corresponding token amount based on the currency amount and the current rate\n    /// @dev This is an abstract function that needs to be implemented in derived contracts\n    function getTokenAmount(uint256 currencyAmount) public view virtual returns (uint256);\n\n    /// @notice Requires that the currency amount does not exceed the total cap\n    function _defaultPreValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view {\n        require(beneficiary != address(0), 'Crowdsale: beneficiary is zero address');\n        //        require(currencyAmount != 0, \"currency amount is 0\");\n        require(tokenAmount != 0, 'Crowdsale: token amount is 0');\n        require(hasStarted, 'Crowdsale: sale not started');\n        require(isUnderTotalCap(currencyAmount), 'Crowdsale: cap exceeded');\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view virtual {\n        _defaultPreValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n    }\n\n    /// @dev Mints and delivers tokens to the beneficiary\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\n        INoteToken noteToken = INoteToken(token);\n        if (noteToken.noteTokenType() == uint8(Configuration.NOTE_TOKEN_TYPE.SENIOR) && noteToken.totalSupply() == 0) {\n            firstNoteTokenMintedTimestamp = uint64(block.timestamp);\n            ISecuritizationPool(pool).setUpOpeningBlockTimestamp();\n        }\n        noteToken.mint(beneficiary, tokenAmount);\n    }\n\n    /// @dev Burns and delivers tokens to the beneficiary\n    function _ejectTokens(uint256 tokenAmount) internal {\n        INoteToken(token).burn(tokenAmount);\n    }\n\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\n        _deliverTokens(beneficiary, tokenAmount);\n    }\n\n    /// @dev Transfers the currency from the payer to the crowdsale contract\n    function _claimPayment(address payee, uint256 currencyAmount) internal {\n        require(\n            IERC20(currency).transferFrom(payee, address(this), currencyAmount),\n            'Fail to transfer currency from payee to contract'\n        );\n    }\n\n    // function getTokenAmount(uint256 currencyAmount) public view returns (uint256) {\n    //     require(rate > 0, 'Crowdsale: rate is 0');\n    //     uint256 TEN = 10;\n    //     return\n    //         (currencyAmount * rate * TEN**ERC20(token).decimals()) /\n    //         (RATE_SCALING_FACTOR * TEN**ERC20(currency).decimals());\n    // }\n\n    /// @dev Transfers the currency funds from the crowdsale contract to the specified beneficiary\n    function _forwardFunds(address beneficiary, uint256 currencyAmount) internal {\n        require(IERC20(currency).transfer(beneficiary, currencyAmount), 'Fail to transfer currency to Beneficiary');\n    }\n\n    /// @dev Sets the total cap to the specified amount\n    function _setTotalCap(uint256 cap) internal {\n        require(cap > 0, 'Crowdsale: cap is 0');\n        require(cap >= _currencyRaised, 'Crowdsale: cap is bellow currency raised');\n\n        totalCap = cap;\n\n        emit UpdateTotalCap(totalCap);\n    }\n\n    /// @notice Checks if the total amount of currency raised is greater than or equal to the total cap\n    function totalCapReached() public view returns (bool) {\n        return _currencyRaised >= totalCap;\n    }\n\n    /// @notice Checks if the sum of the current currency raised and the specified currency amount is less than or equal to the total cap\n    function isUnderTotalCap(uint256 currencyAmount) public view returns (bool) {\n        return _currencyRaised + currencyAmount <= totalCap;\n    }\n\n    function currencyRaised() public view virtual override returns (uint256) {\n        return _currencyRaised;\n    }\n\n    uint256[40] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/FinalizableCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './IFinalizableCrowdsale.sol';\nimport './TimedCrowdsale.sol';\n\n/// @title FinalizableCrowdsale\n/// @author Untangled Team\n/// @dev An abstract contract define finalize function for sale\nabstract contract FinalizableCrowdsale is IFinalizableCrowdsale, TimedCrowdsale {\n    bool internal _finalized;\n\n    function finalized() public view virtual override returns (bool) {\n        return _finalized;\n    }\n\n    /// @dev Validates that the crowdsale has not already been finalized and that it has either closed or reached the total cap\n    /// @param claimRemainToken claim remaining token or not\n    /// @param remainTokenRecipient Wallet will receive remaining token\n    function finalize(bool claimRemainToken, address remainTokenRecipient) public whenNotPaused {\n        require(_msgSender() == pool, 'FinalizableCrowdsale: Only pool contract can finalize');\n        require(!finalized(), 'FinalizableCrowdsale: already finalized');\n        require(hasClosed() || totalCapReached(), 'FinalizableCrowdsale: not closed');\n        _finalized = true;\n\n        if (!isDistributedFully() && !isLongSale()) {\n            uint256 tokenRemain = 0;\n            tokenRemain = getTokenAmount(getCurrencyRemainAmount());\n\n            if (claimRemainToken) {\n                _processPurchase(remainTokenRecipient, tokenRemain);\n            } else {\n                _ejectTokens(tokenRemain);\n            }\n        }\n\n        _finalization();\n        emit CrowdsaleFinalized();\n    }\n\n    /// @dev This function is meant to be overridden in derived contracts to implement specific finalization logic\n    function _finalization() internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/ICrowdSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ICrowdSale {\n    event SetHasStarted(bool hasStarted);\n\n    function pool() external view returns (address);\n\n    function token() external view returns (address);\n\n    function currencyRaisedByInvestor(address investor) external view returns (uint256);\n\n    function currencyRaised() external view returns (uint256);\n\n    function firstNoteTokenMintedTimestamp() external view returns (uint64);\n\n    function buyTokens(address payee, address beneficiary, uint256 currencyAmount) external returns (uint256);\n\n    function onRedeem(uint256 currencyAmount) external;\n\n    function setHasStarted(bool _hasStarted) external;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/IFinalizableCrowdsale.sol": {
      "content": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IFinalizableCrowdsale {\n    event CrowdsaleFinalized();\n\n    function finalized() external view returns (bool);\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/IncreasingInterestCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './FinalizableCrowdsale.sol';\n\n/// @title IncreasingInterestCrowdsale\n/// @author Untangled Team\nabstract contract IncreasingInterestCrowdsale is FinalizableCrowdsale {\n    using ConfigHelper for Registry;\n\n    event UpdateInterestRange(uint32 initialInterest, uint32 finalInterest, uint32 timeInterval, uint32 amountChangeEachInterval);\n\n    uint32 public initialInterest;\n    uint32 public finalInterest;\n    uint32 public timeInterval;\n    uint32 public amountChangeEachInterval;\n\n    uint32 public pickedInterest;\n\n    function setInterestRange(\n        uint32 _initialInterest,\n        uint32 _finalInterest,\n        uint32 _timeInterval,\n        uint32 _amountChangeEachInterval\n    ) public whenNotPaused {\n        require(hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()), \"IncreasingInterestCrowdsale: Caller must be owner or pool\");\n        require(!hasStarted, 'IncreasingInterestCrowdsale: sale already started');\n        require(\n            _initialInterest <= _finalInterest,\n            'IncreasingInterestCrowdsale: initial interest is not less than final interest'\n        );\n        require(_timeInterval > 0, 'IncreasingInterestCrowdsale: time interval is 0');\n\n        initialInterest = _initialInterest;\n        finalInterest = _finalInterest;\n        timeInterval = _timeInterval;\n        amountChangeEachInterval = _amountChangeEachInterval;\n\n        emit UpdateInterestRange(\n            initialInterest,\n            finalInterest,\n            timeInterval,\n            amountChangeEachInterval\n        );\n    }\n\n    function getCurrentInterest() public view returns (uint32) {\n        if (block.timestamp < openingTime) {\n            return 0;\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint256 elapsedTime = block.timestamp - openingTime;\n        // uint256 numberInterval = elapsedTime / timeInterval;\n        // uint32 currentInterest = uint32(amountChangeEachInterval * numberInterval + initialInterest);\n        uint32 currentInterest = uint32(amountChangeEachInterval * elapsedTime / timeInterval + initialInterest);\n\n        if (currentInterest > finalInterest) {\n            return finalInterest;\n        } else {\n            return currentInterest;\n        }\n    }\n\n    /// @dev Override _finalization function. In Auction note sale, interest of token determined when the auction ends\n    function _finalization() internal override {\n        super._finalization();\n\n        pickedInterest = getCurrentInterest();\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view override {\n        super._preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n        require(timeInterval > 0, 'IncreasingInterestCrowdsale: time interval not set');\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/TimedCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './Crowdsale.sol';\n\n/// @title TimedCrowdsale\n/// @author Untangled Team\n/// @dev Note sale that has open time and close time\nabstract contract TimedCrowdsale is Crowdsale {\n    using ConfigHelper for Registry;\n    uint256 public openingTime;\n    uint256 public closingTime;\n\n    bool public isEnableTimeLimit;\n\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\n    event UpdateUsingTimeLimit(bool isEnableTimeLimit);\n    event UpdateSaleRoundTime(uint256 newOpeningTime, uint256 newClosingTime);\n\n    function __TimedCrowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        isEnableTimeLimit = true;\n    }\n\n    modifier onlyWhileOpen() {\n        require(isOpen() || isLongSale(), 'TimedCrowdsale: not open');\n        _;\n    }\n\n    function isOpen() public view returns (bool) {\n        if (!isEnableTimeLimit) {\n            return true;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp >= openingTime && block.timestamp <= closingTime;\n    }\n\n    function hasClosed() public view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > closingTime;\n    }\n\n    /// @notice Updates the closing time with the new closing time\n    function extendTime(uint256 newClosingTime) external whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        require(newClosingTime > closingTime, 'TimedCrowdsale: new closing time is before current closing time');\n\n        emit TimedCrowdsaleExtended(closingTime, newClosingTime);\n        closingTime = newClosingTime;\n    }\n\n    /// @notice Updates the opening time and closing time accordingly\n    function newSaleRoundTime(uint256 newOpeningTime, uint256 newClosingTime) public whenNotPaused {\n        require(hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()), \"Crowdsale: Caller must be owner or pool\");\n        require(newClosingTime >= newOpeningTime, 'TimedCrowdsale: opening time is not before closing time');\n        // not accept opening time in the past\n        if (newOpeningTime < block.timestamp) {\n            newOpeningTime = block.timestamp;\n        }\n\n        if (newClosingTime <= newOpeningTime) {\n            newClosingTime = newOpeningTime + 1;\n        }\n\n        openingTime = newOpeningTime;\n        closingTime = newClosingTime;\n\n        emit UpdateSaleRoundTime(newOpeningTime, newClosingTime);\n    }\n\n    /// @dev Sets the isEnableTimeLimit variable to the specified value\n    function setUsingTimeLimit(bool usingTimeLimit) public whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        isEnableTimeLimit = usingTimeLimit;\n        emit UpdateUsingTimeLimit(usingTimeLimit);\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/fab/INoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../storage/Registry.sol';\nimport '../../../interfaces/INoteToken.sol';\n\ninterface INoteTokenFactory {\n    event TokenCreated(\n        address indexed token,\n        address indexed poolAddress,\n        Configuration.NOTE_TOKEN_TYPE indexed tokenType,\n        uint8 decimals,\n        string ticker\n    );\n\n    event UpdateNoteTokenImplementation(address indexed newAddress);\n\n    function tokens(uint256 idx) external view returns (INoteToken);\n\n    function isExistingTokens(address tokenAddress) external view returns (bool);\n\n    function changeMinterRole(address token, address newController) external;\n\n    function setNoteTokenImplementation(address newAddress) external;\n\n    function noteTokenImplementation() external view returns (address);\n\n    /// @notice Creates a new NoteToken contract instance with the specified parameters\n    /// Initializes the token with the provided parameters, including the pool address and note token type\n    function createToken(\n        address poolAddress,\n        Configuration.NOTE_TOKEN_TYPE noteTokenType,\n        uint8 _nDecimals,\n        string calldata ticker\n    ) external returns (address);\n}\n"
    },
    "contracts/protocol/note-sale/fab/ITokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../storage/Registry.sol';\nimport '../../../interfaces/INoteToken.sol';\n\nabstract contract ITokenGenerationEventFactory {\n    enum SaleType {\n        MINTED_INCREASING_INTEREST_SOT,\n        NORMAL_SALE_JOT,\n        NORMAL_SALE_SOT\n    }\n\n    event UpdateTGEImplAddress(SaleType indexed tgeType, address newImpl);\n    event TokenGenerationEventCreated(address indexed tgeInstance);\n\n    Registry public registry;\n    address[] public tgeAddresses;\n    mapping(address => bool) public isExistingTge;\n    mapping(SaleType => address) public TGEImplAddress;\n\n    /// @notice creates a new TGE instance based on the provided parameters and the sale type\n    function createNewSaleInstance(\n        address issuerTokenController,\n        address pool,\n        address token,\n        address currency,\n        uint8 saleType,\n        bool longSale\n    ) external virtual returns (address);\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/IMintedTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\n\ninterface IMintedTGE {\n    event YieldUpdated(uint256 newYield);\n    event SetupLongSale(uint256 interestRate, uint256 termLengthInSeconds, uint256 timeStartEarningInterest);\n    event UpdateInitialAmount(uint256 initialAmount);\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _isLongSale\n    ) external;\n\n    /// @notice initialize long sale settings\n    function setupLongSale(\n        uint256 interestRate,\n        uint256 termLengthInSeconds,\n        uint256 timeStartEarningInterest\n    ) external;\n\n    ///@notice investor bids for SOT/JOT token. Paid by pool's currency\n    function buyTokens(address payee, address beneficiary, uint256 currencyAmount) external returns (uint256);\n\n    function startNewRoundSale(uint256 openingTime_, uint256 closingTime_, uint256 rate_, uint256 cap_) external;\n}\n"
    },
    "contracts/protocol/note-sale/MintedIncreasingInterestTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../base/UntangledBase.sol';\nimport './crowdsale/IncreasingInterestCrowdsale.sol';\nimport './IMintedTGE.sol';\nimport './base/LongSaleInterest.sol';\n\n/// @title MintedIncreasingInterestTGE\n/// @author Untangled Team\n/// @dev Note sale for SOT - auction\ncontract MintedIncreasingInterestTGE is IMintedTGE, UntangledBase, IncreasingInterestCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n    }\n\n    /// @inheritdoc Crowdsale\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    /// @dev Sets the yield variable to the specified value\n    function setYield(uint256 _yield) public whenNotPaused onlyRole(OWNER_ROLE) {\n        yield = _yield;\n        emit YieldUpdated(_yield);\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n\n            emit SetupLongSale(interestRate, termLengthInSeconds, timeStartEarningInterest);\n            emit YieldUpdated(yield);\n        }\n    }\n\n    /// @notice Calculate token price\n    /// @dev This sale is for SOT. So the function return SOT token price\n    function getTokenPrice() public view returns (uint256) {\n        return registry.getDistributionAssessor().getSOTTokenPrice(ISecuritizationPool(pool));\n    }\n\n    /// @notice Get amount of token can receive from an amount of currency\n    function getTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return currencyAmount / getTokenPrice();\n    }\n\n    /// @notice Setup a new round sale for note token\n    /// @param openingTime_ Define when the sale should start\n    /// @param closingTime_ Define when the sale should end\n    /// @param cap_ Target amount of raised currency\n    function startNewRoundSale(\n        uint256 openingTime_,\n        uint256 closingTime_,\n        uint256 rate_,\n        uint256 cap_\n    ) external whenNotPaused override {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedIncreasingInterestTGE: Caller must be owner or pool'\n        );\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate_);\n        newSaleRoundTime(openingTime_, closingTime_);\n        _setTotalCap(cap_);\n    }\n\n    /// @dev Validates that the previous sale round is closed and the time interval for increasing interest is greater than zero\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n        require(timeInterval > 0, 'MintedIncreasingInterestTGE: Time interval increasing interest is 0');\n    }\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public override(IMintedTGE, Crowdsale) returns (uint256 tokenAmount) {\n        tokenAmount = Crowdsale.buyTokens(payee, beneficiary, currencyAmount);\n        if (_currencyRaised >= totalCap) {\n            if (!this.finalized()) {\n                this.finalize(false, pool);\n            }\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/MintedNormalTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {Crowdsale} from './crowdsale/Crowdsale.sol';\nimport {FinalizableCrowdsale} from './crowdsale/FinalizableCrowdsale.sol';\nimport {ISecuritizationPool} from '../pool/ISecuritizationPool.sol';\nimport {IMintedTGE} from './IMintedTGE.sol';\nimport {LongSaleInterest} from './base/LongSaleInterest.sol';\n\n/// @title MintedNormalTGE\n/// @author Untangled Team\n/// @dev Note sale for JOT\ncontract MintedNormalTGE is IMintedTGE, FinalizableCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n    uint256 public initialAmount;\n\n    uint32 public pickedInterest;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n    }\n\n    /// @inheritdoc Crowdsale\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    /// @dev Sets the yield variable to the specified value\n    function setYield(uint256 _yield) public whenNotPaused onlyRole(OWNER_ROLE) {\n        yield = _yield;\n        emit YieldUpdated(_yield);\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n            emit SetupLongSale(interestRate, termLengthInSeconds, timeStartEarningInterest);\n            emit YieldUpdated(yield);\n        }\n    }\n\n    function getTokenPrice() public view returns (uint256) {\n        return registry.getDistributionAssessor().getJOTTokenPrice(ISecuritizationPool(pool));\n    }\n\n    function getTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return currencyAmount / getTokenPrice();\n    }\n\n    /// @notice Setup a new round sale for note token\n    /// @param openingTime_ Define when the sale should start\n    /// @param closingTime_ Define when the sale should end\n    /// @param cap_ Target amount of raised currency\n    function startNewRoundSale(\n        uint256 openingTime_,\n        uint256 closingTime_,\n        uint256 rate_,\n        uint256 cap_\n    ) external override whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or pool'\n        );\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate_);\n        newSaleRoundTime(openingTime_, closingTime_);\n        _setTotalCap(cap_);\n    }\n\n    /// @notice Setup initial amount currency raised for JOT condition\n    /// @param _initialAmount Expected minimum amount of JOT before SOT start\n    function setInitialAmount(uint256 _initialAmount) external whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or pool'\n        );\n        require(initialAmount < totalCap, 'MintedNormalTGE: Initial JOT amount must be less than total cap');\n        initialAmount = _initialAmount;\n        emit UpdateInitialAmount(_initialAmount);\n    }\n\n    /// @dev Validates that the previous sale round is closed and the time interval for increasing interest is greater than zero\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n    }\n\n    function _finalization() internal override {\n        super._finalization();\n\n        pickedInterest = uint32(interestRate);\n    }\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public override(IMintedTGE, Crowdsale) returns (uint256) {\n        return Crowdsale.buyTokens(payee, beneficiary, currencyAmount);\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/pool/IDistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"./ISecuritizationPool.sol\";\n\ninterface IDistributionAssessor {\n    /// @notice current individual asset price for the \"SOT\" tranche at the current timestamp\n    function getSOTTokenPrice(ISecuritizationPool securitizationPool) external view returns (uint256);\n\n    /// @notice calculates the token price for the \"JOT\" tranche at the current timestamp\n    function getJOTTokenPrice(ISecuritizationPool securitizationPool) external view returns (uint256);\n\n    /// @notice calculates the token price for a specific token address in the securitization pool\n    function calcTokenPrice(address pool, address tokenAddress) external view returns (uint256);\n\n    /// @notice the available cash balance in the securitization pool\n    function getCashBalance(address pool) external view returns (uint256);\n\n    /// @notice calculates the corresponding total asset value for a specific token address, investor, and end time\n    function calcCorrespondingTotalAssetValue(\n        address tokenAddress,\n        address investor\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/IDistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IDistributionOperator {}\n"
    },
    "contracts/protocol/pool/IDistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IDistributionTranche {\n    /// @notice allows the redemption of tokens for a specific redeemer from a specified pool and tokenAddress\n    function redeem(\n        address usr,\n        address pool,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external;\n\n    /// @notice allows the distribution operator to redeem tokenAmount tokens of a specific noteToken from a given usr\n    function redeemToken(address noteToken, address usr, uint256 tokenAmount) external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport './ISecuritizationPool.sol';\n\nabstract contract ISecuritizationManager {\n    Registry public registry;\n\n    event NewTGECreated(address indexed instanceAddress);\n    event NewNotesTokenCreated(address indexed instanceAddress);\n    event NewPoolCreated(address indexed instanceAddress);\n    event UpdatePotToPool(address indexed pot, address indexed pool);\n    event SotDeployed(address indexed sotAddress, address tgeAddress, address poolAddress);\n    event JotDeployed(address indexed jotAddress, address tgeAddress, address poolAddress);\n\n    mapping(address => bool) public isExistingPools;\n    ISecuritizationPool[] public pools;\n\n    mapping(address => address) public poolToSOT;\n    mapping(address => address) public poolToJOT;\n    mapping(address => address) public potToPool;\n\n    mapping(address => bool) public isExistingTGEs;\n\n    /// @dev Register pot to pool instance\n    /// @param pot Pool linked wallet\n    function registerPot(address pot) external virtual;\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../libraries/Configuration.sol';\n\nabstract contract ISecuritizationPool is UntangledBase {\n    event SecuritizationPoolWithdraw(address originatorAddress, uint256 amount);\n    event CollectAsset(address from, uint256 value);\n    event UpdateOpeningBlockTimestamp(uint256 newTimestamp);\n    event AddTokenAssetAddress(address token);\n    event InsertNFTAsset(address token, uint256 tokenId);\n    event RemoveNFTAsset(address token, uint256 tokenId);\n    event UpdateTGEAddress(address tge, address token, Configuration.NOTE_TOKEN_TYPE noteType);\n    event UpdateInterestRateSOT(uint32 _interestRateSOT);\n    event UpdateLockedDistributeBalance(\n        address indexed tokenAddress,\n        address indexed investor,\n        uint256 lockedDistributeBalance,\n        uint256 lockedRedeemBalances,\n        uint256 totalLockedRedeemBalances,\n        uint256 totalLockedDistributeBalance\n    );\n    event UpdateReserve(uint256 currencyAmount);\n    event UpdatePaidPrincipalAmountSOTByInvestor(address indexed user, uint256 currencyAmount);\n\n    struct NewPoolParams {\n        address currency;\n        uint32 minFirstLossCushion;\n        bool validatorRequired;\n    }\n\n    Registry public registry;\n\n    bytes32 public constant ORIGINATOR_ROLE = keccak256('ORIGINATOR_ROLE');\n    uint256 public constant RATE_SCALING_FACTOR = 10 ** 4;\n\n    address public tgeAddress;\n    address public secondTGEAddress;\n    address public sotToken;\n    address public jotToken;\n    address public underlyingCurrency;\n\n    //CycleState\n    CycleState public state;\n\n    uint64 public firstAssetTimestamp; // Timestamp at which the first asset is collected to pool\n    uint64 public openingBlockTimestamp;\n    uint64 public termLengthInSeconds;\n\n    uint256 public reserve; // Money in pool\n    uint256 public amountOwedToOriginator; // Money owed to originator\n    uint256 public totalRedeemedCurrency; // Total $ (cUSD) has been redeemed\n    // for lending operation\n    uint256 public totalLockedDistributeBalance;\n    // token address -> total locked\n    mapping(address => uint256) public totalLockedRedeemBalances;\n    // token address -> user -> locked\n    mapping(address => mapping(address => uint256)) public lockedDistributeBalances;\n    mapping(address => mapping(address => uint256)) public lockedRedeemBalances;\n\n    uint256 public totalAssetRepaidCurrency; // Total $ (cUSD) paid for Asset repayment - repayInBatch\n\n    // user -> amount\n    mapping(address => uint256) public paidInterestAmountSOT;\n    mapping(address => uint256) public lastRepayTimestampSOT;\n\n    // for base (sell-loan) operation\n    uint256 public principalAmountSOT;\n    uint256 public paidPrincipalAmountSOT;\n    uint32 public interestRateSOT; // Annually, support 4 decimals num\n\n    uint32 public minFirstLossCushion;\n\n    //RiskScores\n    RiskScore[] public riskScores;\n\n    //ERC721 Assets\n    NFTAsset[] public nftAssets;\n\n    address[] public tokenAssetAddresses;\n    mapping(address => bool) public existsTokenAssetAddress;\n\n    mapping(address => uint256) public paidPrincipalAmountSOTByInvestor;\n\n    // by default it is address(this)\n    address public pot;\n\n    bool public validatorRequired;\n\n    /** ENUM & STRUCT */\n    enum CycleState {\n        INITIATED,\n        CROWDSALE,\n        OPEN,\n        CLOSED\n    }\n\n    struct NFTAsset {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    struct RiskScore {\n        uint32 daysPastDue;\n        uint32 advanceRate;\n        uint32 penaltyRate;\n        uint32 interestRate;\n        uint32 probabilityOfDefault;\n        uint32 lossGivenDefault;\n        uint32 gracePeriod;\n        uint32 collectionPeriod;\n        uint32 writeOffAfterGracePeriod;\n        uint32 writeOffAfterCollectionPeriod;\n        uint32 discountRate;\n    }\n\n    function initialize(Registry _registry, bytes memory params) public virtual;\n\n    /// @notice A view function that returns the length of the NFT (non-fungible token) assets array\n    function getNFTAssetsLength() public view virtual returns (uint256);\n\n    /// @notice A view function that returns an array of token asset addresses\n    function getTokenAssetAddresses() public view virtual returns (address[] memory);\n\n    /// @notice A view function that returns the length of the token asset addresses array\n    function getTokenAssetAddressesLength() public view virtual returns (uint256);\n\n    /// @notice Riks scores length\n    /// @return the length of the risk scores array\n    function getRiskScoresLength() public view virtual returns (uint256);\n\n    /// @notice checks if the contract is in a closed state\n    function isClosedState() public view virtual returns (bool);\n\n    /// @notice checks if the redemption process has finished\n    function hasFinishedRedemption() public view virtual returns (bool);\n\n    /// @notice sets the pot address for the contract\n    function setPot(address _pot) external virtual;\n\n    /// @notice sets up the risk scores for the contract for pool\n    function setupRiskScores(\n        uint32[] calldata _daysPastDues,\n        uint32[] calldata _ratesAndDefaults,\n        uint32[] calldata _periodsAndWriteOffs\n    ) external virtual;\n\n    /// @notice exports NFT assets to another pool address\n    function exportAssets(address tokenAddress, address toPoolAddress, uint256[] calldata tokenIds) external virtual;\n\n    /// @notice withdraws NFT assets from the contract and transfers them to recipients\n    function withdrawAssets(\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        address[] calldata recipients\n    ) external virtual;\n\n    /// @notice start collects NFT assets\n    function setStartCollectAsset() external virtual;\n\n    /// @notice collects ERC20 assets from specified senders\n    function collectERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata senders,\n        uint256[] calldata amounts\n    ) external virtual;\n\n    /// @notice withdraws ERC20 assets from the contract and transfers them to recipients\\\n    function withdrawERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external virtual;\n\n    /// @notice transfers the remaining cash to a specified recipient wallet\n    function claimCashRemain(address recipientWallet) external virtual;\n\n    /// @notice injects the address of the Token Generation Event (TGE) and the associated token address\n    function injectTGEAddress(\n        address _tgeAddress,\n        address _tokenAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteToken\n    ) external virtual;\n\n    /// @notice starts a new cycle and sets various parameters for the contract\n    function startCycle(\n        uint64 _termLengthInSeconds,\n        uint256 _principalAmountForSOT,\n        uint32 _interestRateForSOT,\n        uint64 _timeStartEarningInterest\n    ) external virtual;\n\n    /// @notice sets the interest rate for the senior tranche of tokens\n    function setInterestRateForSOT(uint32 _interestRateSOT) external virtual;\n\n    /// @notice increases the locked distribution balance for a specific investor\n    function increaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external virtual;\n\n    /// @dev trigger update asset value repaid\n    function increaseTotalAssetRepaidCurrency(uint256 amount) external virtual;\n\n    /// @notice decreases the locked distribution balance for a specific investor\n    function decreaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external virtual;\n\n    /// @notice allows the redemption of tokens\n    function redeem(address usr, address notesToken, uint256 currencyAmount, uint256 tokenAmount) external virtual;\n\n    /// @notice allows the originator to withdraw from reserve\n    function withdraw(address to, uint256 amount) public virtual;\n\n    /// @dev trigger update reserve when buy note token action happens\n    function increaseReserve(uint256 currencyAmount) external virtual;\n\n    /// @dev trigger update reserve\n    function decreaseReserve(uint256 currencyAmount) external virtual;\n\n    /// @dev Trigger set up opening block timestamp\n    function setUpOpeningBlockTimestamp() external virtual;\n\n    uint256[21] private __gap;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ISecuritizationPoolValueService {\n    /// @notice calculates the outstanding principal in currency amount for a given investor address.\n    /// It takes the investor address as a parameter and returns the outstanding principal\n    function getOutstandingPrincipalCurrencyByInvestor(address pool, address investor) external view returns (uint256);\n\n    /// @notice calculates the total expected value of all assets in the securitization pool at a given timestamp\n    /// @dev iterates over the NFT assets and token assets in the pool, calling getExpectedAssetValue\n    /// or getExpectedERC20AssetValue for each asset and summing up the values\n    function getExpectedAssetsValue(address poolAddress, uint256 timestamp)\n        external\n        view\n        returns (uint256 expectedAssetsValue);\n\n    /// @notice the amount which belongs to the senior investor (SOT) in a pool\n    /// @dev  calculates  the amount which accrues interest for the senior tranche in the securitization pool at a given timestamp\n    function getSeniorAsset(address poolAddress) external view returns (uint256);\n\n    /// @notice calculates  the amount of Junior Debt at the current time\n    function getJuniorAsset(address poolAddress) external view returns (uint256);\n\n    /// @notice returns the rate that belongs to Junior investors at the current time\n    function getJuniorRatio(address poolAddress) external view returns (uint256);\n\n    /// @notice calculates the expected value of an asset in the securitization pool at a given timestamp\n    function getExpectedAssetValue(\n        address poolAddress,\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /// @notice calculates the expected value of an ERC20 asset in the securitization pool at a given timestamp\n    function getExpectedERC20AssetValue(\n        address poolAddress,\n        address assetPoolAddress,\n        address tokenAddress,\n        uint256 interestRate,\n        uint256 timestamp\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\nimport {ERC20BurnableUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol';\nimport {IERC721ReceiverUpgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol';\nimport {IAccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol';\n\nimport {IUntangledERC721} from '../../interfaces/IUntangledERC721.sol';\nimport {INoteToken} from '../../interfaces/INoteToken.sol';\nimport {ICrowdSale} from '../note-sale/crowdsale/ICrowdSale.sol';\n\nimport {ISecuritizationPool} from './ISecuritizationPool.sol';\nimport {ISecuritizationPoolValueService} from './ISecuritizationPoolValueService.sol';\n\nimport {MintedIncreasingInterestTGE} from '../note-sale/MintedIncreasingInterestTGE.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {FinalizableCrowdsale} from './../note-sale/crowdsale/FinalizableCrowdsale.sol';\nimport {POOL_ADMIN} from './types.sol';\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Main entry point for senior LPs (a.k.a. capital providers)\n *  Automatically invests across borrower pools using an adjustable strategy.\n * @author Untangled Team\n */\ncontract SecuritizationPool is ISecuritizationPool, IERC721ReceiverUpgradeable {\n    using ConfigHelper for Registry;\n\n    modifier onlyIssuingTokenStage() {\n        require(state != CycleState.OPEN && state != CycleState.CLOSED, 'Not in issuing token stage');\n        _;\n    }\n\n    modifier notClosingStage() {\n        require(!isClosedState(), 'SecuritizationPool: Pool in closed state');\n        _;\n    }\n\n    modifier finishRedemptionValidator() {\n        require(hasFinishedRedemption(), 'SecuritizationPool: Redemption has not finished');\n        _;\n    }\n\n    modifier onlyPoolAdmin() {\n        require(\n            IAccessControlUpgradeable(address(registry.getSecuritizationManager())).hasRole(POOL_ADMIN, _msgSender()),\n            'SecuritizationPool: Not an pool admin'\n        );\n        _;\n    }\n\n    modifier onlyPoolAdminOrOwner() {\n        require(\n            IAccessControlUpgradeable(address(registry.getSecuritizationManager())).hasRole(POOL_ADMIN, _msgSender()) ||\n                hasRole(OWNER_ROLE, _msgSender()),\n            'SecuritizationPool: Not an pool admin or pool owner'\n        );\n        _;\n    }\n\n    modifier onlySecuritizationManager() {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()),\n            'SecuritizationPool: Only SecuritizationManager'\n        );\n        _;\n    }\n\n    modifier onlyDistributionOperator() {\n        require(\n            _msgSender() == address(registry.getDistributionOperator()),\n            'SecuritizationPool: Only DistributionOperator'\n        );\n        _;\n    }\n\n    modifier onlyLoanRepaymentRouter() {\n        require(\n            _msgSender() == address(registry.getLoanRepaymentRouter()),\n            'SecuritizationPool: Only LoanRepaymentRouter'\n        );\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /** CONSTRUCTOR */\n    function initialize(\n        Registry _registry,\n        bytes memory params\n    )\n        public\n        override\n        initializer\n    {\n        ISecuritizationPool.NewPoolParams memory newPoolParams = abi.decode(\n            params,\n            (ISecuritizationPool.NewPoolParams)\n        );\n\n        require(\n            newPoolParams.minFirstLossCushion <= 100 * RATE_SCALING_FACTOR,\n            'minFirstLossCushion is greater than 100'\n        );\n        require(newPoolParams.currency != address(0), 'SecuritizationPool: Invalid currency');\n        __UntangledBase__init(_msgSender());\n\n        _setRoleAdmin(ORIGINATOR_ROLE, OWNER_ROLE);\n        registry = _registry;\n\n        state = CycleState.INITIATED;\n        underlyingCurrency = newPoolParams.currency;\n        minFirstLossCushion = newPoolParams.minFirstLossCushion;\n\n        pot = address(this);\n        validatorRequired = newPoolParams.validatorRequired;\n\n        require(\n            IERC20Upgradeable(newPoolParams.currency).approve(pot, type(uint256).max),\n            'SecuritizationPool: Currency approval failed'\n        );\n        registry.getLoanAssetToken().setApprovalForAll(address(registry.getLoanKernel()), true);\n    }\n\n    /** GETTER */\n    function getNFTAssetsLength() public view override returns (uint256) {\n        return nftAssets.length;\n    }\n\n    function getTokenAssetAddresses() public view override returns (address[] memory) {\n        return tokenAssetAddresses;\n    }\n\n    function getTokenAssetAddressesLength() public view override returns (uint256) {\n        return tokenAssetAddresses.length;\n    }\n\n    function getRiskScoresLength() public view override returns (uint256) {\n        return riskScores.length;\n    }\n\n    function isClosedState() public view override returns (bool) {\n        return state == CycleState.CLOSED;\n    }\n\n    function hasFinishedRedemption() public view override returns (bool) {\n        if (sotToken != address(0)) {\n            require(IERC20Upgradeable(sotToken).totalSupply() == 0, 'SecuritizationPool: SOT still remain');\n        }\n        if (jotToken != address(0)) {\n            require(IERC20Upgradeable(jotToken).totalSupply() == 0, 'SecuritizationPool: JOT still remain');\n        }\n\n        return true;\n    }\n\n    /** UTILITY FUNCTION */\n    function _removeNFTAsset(address tokenAddress, uint256 tokenId) private returns (bool) {\n        uint256 nftAssetsLength = nftAssets.length;\n        for (uint256 i = 0; i < nftAssetsLength; i = UntangledMath.uncheckedInc(i)) {\n            if (nftAssets[i].tokenAddress == tokenAddress && nftAssets[i].tokenId == tokenId) {\n                // Remove i element from nftAssets\n                _removeNFTAssetIndex(i);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _removeNFTAssetIndex(uint256 indexToRemove) private {\n        nftAssets[indexToRemove] = nftAssets[nftAssets.length - 1];\n\n        NFTAsset storage nft = nftAssets[nftAssets.length - 1];\n        emit RemoveNFTAsset(nft.tokenAddress, nft.tokenId);\n        nftAssets.pop();\n    }\n\n    function _pushTokenAssetAddress(address tokenAddress) private {\n        if (!existsTokenAssetAddress[tokenAddress]) tokenAssetAddresses.push(tokenAddress);\n        existsTokenAssetAddress[tokenAddress] = true;\n        emit AddTokenAssetAddress(tokenAddress);\n    }\n\n    function onERC721Received(address, address, uint256 tokenId, bytes memory) external returns (bytes4) {\n        address token = _msgSender();\n        require(\n            token == address(registry.getLoanAssetToken()),\n            'SecuritizationPool: Must be token issued by Untangled'\n        );\n        nftAssets.push(NFTAsset({tokenAddress: token, tokenId: tokenId}));\n        emit InsertNFTAsset(token, tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function setPot(address _pot) external override whenNotPaused nonReentrant notClosingStage onlyPoolAdminOrOwner {\n        require(!hasRole(OWNER_ROLE, _pot));\n\n        require(pot != _pot, 'SecuritizationPool: Same address with current pot');\n        pot = _pot;\n        if (_pot == address(this)) {\n            require(\n                IERC20Upgradeable(underlyingCurrency).approve(pot, type(uint256).max),\n                'SecuritizationPool: Pot not approved'\n            );\n        }\n        registry.getSecuritizationManager().registerPot(pot);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function setupRiskScores(\n        uint32[] calldata _daysPastDues,\n        uint32[] calldata _ratesAndDefaults,\n        uint32[] calldata _periodsAndWriteOffs\n    ) external override whenNotPaused notClosingStage onlyPoolAdmin {\n        uint256 _daysPastDuesLength = _daysPastDues.length;\n        require(\n            _daysPastDuesLength * 6 == _ratesAndDefaults.length &&\n                _daysPastDuesLength * 4 == _periodsAndWriteOffs.length,\n            'SecuritizationPool: Riskscore params length is not equal'\n        );\n        delete riskScores;\n\n        for (uint256 i = 0; i < _daysPastDuesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(\n                i == 0 || _daysPastDues[i] > _daysPastDues[i - 1],\n                'SecuritizationPool: Risk scores must be sorted'\n            );\n            riskScores.push(\n                RiskScore({\n                    daysPastDue: _daysPastDues[i],\n                    advanceRate: _ratesAndDefaults[i],\n                    penaltyRate: _ratesAndDefaults[i + _daysPastDuesLength],\n                    interestRate: _ratesAndDefaults[i + _daysPastDuesLength * 2],\n                    probabilityOfDefault: _ratesAndDefaults[i + _daysPastDuesLength * 3],\n                    lossGivenDefault: _ratesAndDefaults[i + _daysPastDuesLength * 4],\n                    discountRate: _ratesAndDefaults[i + _daysPastDuesLength * 5],\n                    gracePeriod: _periodsAndWriteOffs[i],\n                    collectionPeriod: _periodsAndWriteOffs[i + _daysPastDuesLength],\n                    writeOffAfterGracePeriod: _periodsAndWriteOffs[i + _daysPastDuesLength * 2],\n                    writeOffAfterCollectionPeriod: _periodsAndWriteOffs[i + _daysPastDuesLength * 3]\n                })\n            );\n        }\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function exportAssets(\n        address tokenAddress,\n        address toPoolAddress,\n        uint256[] calldata tokenIds\n    ) external override whenNotPaused nonReentrant notClosingStage onlyPoolAdminOrOwner {\n        uint256 tokenIdsLength = tokenIds.length;\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            require(_removeNFTAsset(tokenAddress, tokenIds[i]), 'SecuritizationPool: Asset does not exist');\n        }\n\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            IUntangledERC721(tokenAddress).safeTransferFrom(address(this), toPoolAddress, tokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function withdrawAssets(\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        address[] calldata recipients\n    ) external override whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        uint256 tokenIdsLength = tokenIds.length;\n        require(tokenAddresses.length == tokenIdsLength, 'tokenAddresses length and tokenIds length are not equal');\n        require(\n            tokenAddresses.length == recipients.length,\n            'tokenAddresses length and recipients length are not equal'\n        );\n\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            require(_removeNFTAsset(tokenAddresses[i], tokenIds[i]), 'SecuritizationPool: Asset does not exist');\n        }\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            IUntangledERC721(tokenAddresses[i]).safeTransferFrom(address(this), recipients[i], tokenIds[i]);\n        }\n    }\n\n    function setStartCollectAsset() external override whenNotPaused {\n        require(_msgSender() == address(registry.getLoanKernel()), 'SecuritizationPool: Only LoanKernel');\n\n        if (firstAssetTimestamp == 0) {\n            firstAssetTimestamp = uint64(block.timestamp);\n            _setUpOpeningBlockTimestamp();\n        }\n        if (openingBlockTimestamp == 0) {\n            // If openingBlockTimestamp is not set\n            openingBlockTimestamp = uint64(block.timestamp);\n        }\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function withdraw(address to, uint256 amount) public override whenNotPaused {\n        require(_msgSender() == address(registry.getLoanKernel()), 'SecuritizationPool: Only LoanKernel');\n        require(hasRole(ORIGINATOR_ROLE, to), 'SecuritizationPool: Only Originator can drawdown');\n\n        require(reserve >= amount, 'SecuritizationPool: not enough reserve');\n        reserve = reserve - amount;\n\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n        require(\n            IERC20Upgradeable(underlyingCurrency).transferFrom(pot, to, amount),\n            'SecuritizationPool: Transfer failed'\n        );\n        emit SecuritizationPoolWithdraw(to, amount);\n    }\n\n    function checkMinFirstLost() public view returns (bool) {\n        ISecuritizationPoolValueService poolService = registry.getSecuritizationPoolValueService();\n        return minFirstLossCushion <= poolService.getJuniorRatio(address(this));\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function collectERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata senders,\n        uint256[] calldata amounts\n    ) external override whenNotPaused notClosingStage onlyRole(ORIGINATOR_ROLE) {\n        uint256 tokenAddressesLength = tokenAddresses.length;\n        require(\n            tokenAddressesLength == senders.length && senders.length == amounts.length,\n            'SecuritizationPool: Params length are not equal'\n        );\n\n        // check\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(\n                registry.getNoteTokenFactory().isExistingTokens(tokenAddresses[i]),\n                'SecuritizationPool: unknown-token-address'\n            );\n        }\n\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            _pushTokenAssetAddress(tokenAddresses[i]);\n        }\n\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(\n                IERC20Upgradeable(tokenAddresses[i]).transferFrom(senders[i], address(this), amounts[i]),\n                'SecuritizationPool: Transfer failed'\n            );\n        }\n\n        if (openingBlockTimestamp == 0) {\n            // If openingBlockTimestamp is not set\n            openingBlockTimestamp = uint64(block.timestamp);\n        }\n\n        emit UpdateOpeningBlockTimestamp(openingBlockTimestamp);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function withdrawERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external override whenNotPaused nonReentrant onlyPoolAdminOrOwner {\n        uint256 tokenAddressesLength = tokenAddresses.length;\n        require(tokenAddressesLength == recipients.length, 'tokenAddresses length and tokenIds length are not equal');\n        require(tokenAddressesLength == amounts.length, 'tokenAddresses length and recipients length are not equal');\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(existsTokenAssetAddress[tokenAddresses[i]], 'SecuritizationPool: note token asset does not exist');\n            require(\n                IERC20Upgradeable(tokenAddresses[i]).transfer(recipients[i], amounts[i]),\n                'SecuritizationPool: Transfer failed'\n            );\n        }\n    }\n\n    // After closed pool and redeem all not -> get remain cash to recipient wallet\n    /// @inheritdoc ISecuritizationPool\n    function claimCashRemain(\n        address recipientWallet\n    ) external override whenNotPaused onlyRole(OWNER_ROLE) finishRedemptionValidator {\n        IERC20Upgradeable currency = IERC20Upgradeable(underlyingCurrency);\n        require(\n            currency.transferFrom(pot, recipientWallet, currency.balanceOf(pot)),\n            'SecuritizationPool: Transfer failed'\n        );\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function injectTGEAddress(\n        address _tgeAddress,\n        address _tokenAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteType\n    ) external override whenNotPaused onlySecuritizationManager onlyIssuingTokenStage {\n        require(_tgeAddress != address(0x0) && _tokenAddress != address(0x0), 'SecuritizationPool: Address zero');\n\n        if (_noteType == Configuration.NOTE_TOKEN_TYPE.SENIOR) {\n            tgeAddress = _tgeAddress;\n            sotToken = _tokenAddress;\n        } else {\n            secondTGEAddress = _tgeAddress;\n            jotToken = _tokenAddress;\n        }\n        state = CycleState.CROWDSALE;\n\n        emit UpdateTGEAddress(_tgeAddress, _tokenAddress, _noteType);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function startCycle(\n        uint64 _termLengthInSeconds,\n        uint256 _principalAmountForSOT,\n        uint32 _interestRateForSOT,\n        uint64 _timeStartEarningInterest\n    ) external override whenNotPaused nonReentrant onlyRole(OWNER_ROLE) onlyIssuingTokenStage {\n        require(_termLengthInSeconds > 0, 'SecuritizationPool: Term length is 0');\n\n        termLengthInSeconds = _termLengthInSeconds;\n\n        principalAmountSOT = _principalAmountForSOT;\n\n        state = CycleState.OPEN;\n\n        if (tgeAddress != address(0)) {\n            MintedIncreasingInterestTGE mintedTokenGenrationEvent = MintedIncreasingInterestTGE(tgeAddress);\n            mintedTokenGenrationEvent.setupLongSale(\n                _interestRateForSOT,\n                _termLengthInSeconds,\n                _timeStartEarningInterest\n            );\n            if (!mintedTokenGenrationEvent.finalized()) {\n                mintedTokenGenrationEvent.finalize(false, pot);\n            }\n            interestRateSOT = mintedTokenGenrationEvent.pickedInterest();\n        }\n        if (secondTGEAddress != address(0)) {\n            FinalizableCrowdsale(secondTGEAddress).finalize(false, pot);\n            require(\n                MintedIncreasingInterestTGE(secondTGEAddress).finalized(),\n                'SecuritizationPool: second sale is still on going'\n            );\n        }\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function setInterestRateForSOT(uint32 _interestRateSOT) external override whenNotPaused {\n        require(_msgSender() == tgeAddress, 'SecuritizationPool: Only tge can update interest');\n        interestRateSOT = _interestRateSOT;\n        emit UpdateInterestRateSOT(_interestRateSOT);\n    }\n\n    // Increase by value\n    /// @inheritdoc ISecuritizationPool\n    function increaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external override whenNotPaused onlyDistributionOperator {\n        lockedDistributeBalances[tokenAddress][investor] = lockedDistributeBalances[tokenAddress][investor] + currency;\n        lockedRedeemBalances[tokenAddress][investor] = lockedRedeemBalances[tokenAddress][investor] + token;\n\n        totalLockedDistributeBalance = totalLockedDistributeBalance + currency;\n        totalLockedRedeemBalances[tokenAddress] = totalLockedRedeemBalances[tokenAddress] + token;\n\n        emit UpdateLockedDistributeBalance(\n            tokenAddress,\n            investor,\n            lockedDistributeBalances[tokenAddress][investor],\n            lockedRedeemBalances[tokenAddress][investor],\n            totalLockedRedeemBalances[tokenAddress],\n            totalLockedDistributeBalance\n        );\n    }\n\n    // Decrease by value\n\n    /// @inheritdoc ISecuritizationPool\n    function decreaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external override whenNotPaused onlyDistributionOperator {\n        lockedDistributeBalances[tokenAddress][investor] = lockedDistributeBalances[tokenAddress][investor] - currency;\n        lockedRedeemBalances[tokenAddress][investor] = lockedRedeemBalances[tokenAddress][investor] - token;\n\n        totalLockedDistributeBalance = totalLockedDistributeBalance - currency;\n        totalRedeemedCurrency = totalRedeemedCurrency + currency;\n        totalLockedRedeemBalances[tokenAddress] = totalLockedRedeemBalances[tokenAddress] - token;\n\n        emit UpdateLockedDistributeBalance(\n            tokenAddress,\n            investor,\n            lockedDistributeBalances[tokenAddress][investor],\n            lockedRedeemBalances[tokenAddress][investor],\n            totalLockedRedeemBalances[tokenAddress],\n            totalLockedDistributeBalance\n        );\n    }\n\n    // Increase by value\n    /// @inheritdoc ISecuritizationPool\n    function increaseTotalAssetRepaidCurrency(uint256 amount) external override whenNotPaused onlyLoanRepaymentRouter {\n        reserve = reserve + amount;\n        totalAssetRepaidCurrency = totalAssetRepaidCurrency + amount;\n\n        emit UpdateReserve(reserve);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function redeem(\n        address usr,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external override whenNotPaused nonReentrant {\n        require(\n            _msgSender() == address(registry.getDistributionTranche()),\n            'SecuritizationPool: Caller must be DistributionTranche'\n        );\n        if (sotToken == notesToken) {\n            paidPrincipalAmountSOTByInvestor[usr] += currencyAmount;\n            emit UpdatePaidPrincipalAmountSOTByInvestor(usr, currencyAmount);\n        }\n\n        reserve = reserve - currencyAmount;\n\n        if (tokenAmount > 0) {\n            ERC20BurnableUpgradeable(notesToken).burn(tokenAmount);\n        }\n\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n        require(\n            IERC20Upgradeable(underlyingCurrency).transferFrom(pot, usr, currencyAmount),\n            'SecuritizationPool: currency-transfer-failed'\n        );\n\n        emit UpdateReserve(reserve);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function increaseReserve(uint256 currencyAmount) external override whenNotPaused {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()) ||\n                _msgSender() == address(registry.getDistributionOperator()),\n            'SecuritizationPool: Caller must be SecuritizationManager or DistributionOperator'\n        );\n        reserve = reserve + currencyAmount;\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n\n        emit UpdateReserve(reserve);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function decreaseReserve(uint256 currencyAmount) external override whenNotPaused {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()) ||\n                _msgSender() == address(registry.getDistributionOperator()),\n            'SecuritizationPool: Caller must be SecuritizationManager or DistributionOperator'\n        );\n        reserve = reserve - currencyAmount;\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n\n        emit UpdateReserve(reserve);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function setUpOpeningBlockTimestamp() public override whenNotPaused {\n        require(_msgSender() == tgeAddress, 'SecuritizationPool: Only tge address');\n        _setUpOpeningBlockTimestamp();\n    }\n\n    /// @dev Set the opening block timestamp\n    function _setUpOpeningBlockTimestamp() private {\n        if (tgeAddress == address(0)) return;\n        uint64 _firstNoteTokenMintedTimestamp = ICrowdSale(tgeAddress).firstNoteTokenMintedTimestamp();\n        uint64 _firstAssetTimestamp = firstAssetTimestamp;\n        if (_firstNoteTokenMintedTimestamp > 0 && _firstAssetTimestamp > 0) {\n            // Pick the later\n            if (_firstAssetTimestamp > _firstNoteTokenMintedTimestamp) {\n                openingBlockTimestamp = _firstAssetTimestamp;\n            } else {\n                openingBlockTimestamp = _firstNoteTokenMintedTimestamp;\n            }\n        }\n\n        emit UpdateOpeningBlockTimestamp(openingBlockTimestamp);\n    }\n\n    function pause() public virtual override onlyPoolAdminOrOwner {\n        _pause();\n    }\n\n    function unpause() public virtual override onlyPoolAdminOrOwner {\n        _unpause();\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return type(ISecuritizationPool).interfaceId == interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pool/types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nbytes32 constant POOL_ADMIN = keccak256('POOL_CREATOR');"
    },
    "contracts/storage/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {UntangledBase} from '../base/UntangledBase.sol';\nimport {Configuration} from '../libraries/Configuration.sol';\n\n/**\n * @title Registry\n * @notice This contract stores mappings of useful \"protocol config state\", giving a central place\n *  for all other contracts to access it. These config vars\n *  are enumerated in the `Configuration` library, and can only be changed by admins of the protocol.\n * @author Untangled Team\n */\ncontract Registry is UntangledBase {\n    mapping(uint8 => address) public contractAddresses;\n\n    event AddressUpdated(address owner, uint8 index, address oldValue, address newValue);\n\n    function initialize() public initializer {\n        __UntangledBase__init(_msgSender());\n    }\n\n    function _setAddress(uint8 addressIndex, address newAddress) private {\n        emit AddressUpdated(_msgSender(), addressIndex, contractAddresses[addressIndex], newAddress);\n        contractAddresses[addressIndex] = newAddress;\n    }\n\n    function getAddress(uint8 index) public view returns (address) {\n        return contractAddresses[index];\n    }\n\n    function setSecuritizationManager(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER), newAddress);\n    }\n\n    function setSecuritizationPool(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL), newAddress);\n    }\n\n    function setNoteTokenFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY), newAddress);\n    }\n\n    // function setNoteToken(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN), newAddress);\n    // }\n\n    function setTokenGenerationEventFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY), newAddress);\n    }\n\n    // function setMintedIncreasingInterestTGE(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE), newAddress);\n    // }\n\n    // function setMintedNormalTGE(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE), newAddress);\n    // }\n\n    function setDistributionOperator(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR), newAddress);\n    }\n\n    function setDistributionAssessor(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR), newAddress);\n    }\n\n    function setLoanAssetToken(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN), newAddress);\n    }\n\n    function setDistributionTranche(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE), newAddress);\n    }\n\n    function setSecuritizationPoolValueService(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE), newAddress);\n    }\n\n    function setLoanRegistry(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REGISTRY), newAddress);\n    }\n\n    function setLoanInterestTermsContract(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT), newAddress);\n    }\n\n    function setLoanRepaymentRouter(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER), newAddress);\n    }\n\n    function setLoanKernel(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_KERNEL), newAddress);\n    }\n\n    function setGo(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.GO), newAddress);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/ERC20/INoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {IERC20MetadataUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol';\nimport {IPauseable} from '../../base/IPauseable.sol';\n\ninterface INoteToken is IERC20Upgradeable, IERC20MetadataUpgradeable, IPauseable {\n    // address public poolAddress;\n    // uint8 public noteTokenType;\n\n    // uint8 internal immutable _d;\n    function poolAddress() external view returns (address);\n\n    function noteTokenType() external view returns (uint8);\n\n    function mint(address receiver, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n}\n"
    },
    "contracts/tokens/ERC721/ILoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../interfaces/IUntangledERC721.sol';\nimport './types.sol';\n\nabstract contract ILoanAssetToken is IUntangledERC721 {\n  \n  function safeMint(address creditor, LoanAssetInfo calldata latInfo) external virtual;\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/IUntangledERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol';\nimport '../../storage/Registry.sol';\n\nabstract contract IUntangledERC721 is ERC721PresetMinterPauserAutoIdUpgradeable {\n    Registry public registry;\n\n    function __UntangledERC721__init(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __UntangledERC721__init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __UntangledERC721__init_unchained(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _safeMint(to, tokenId);\n    }\n\n    /// @notice calculates the total expected repayment value (principal + interest) for a loan asset token at a given timestamp\n    function getTotalExpectedRepaymentValue(\n        uint256 agreementId,\n        uint256 timestamp\n    ) external view virtual returns (uint256);\n\n    /// @notice the expected principal and interest for an asset\n    function getExpectedRepaymentValues(\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view virtual returns (uint256 expectedPrincipal, uint256 expectedInterest);\n\n    /// @notice the expiration timestamp of an invoice/loan token\n    function getExpirationTimestamp(uint256 agreementId) external view virtual returns (uint256);\n\n    /// @notice  the interest rate associated with an token\n    function getInterestRate(uint256 agreementId) external view virtual returns (uint256);\n\n    /// @notice the risk score associated with a token\n    function getRiskScore(uint256 agreementId) external view virtual returns (uint8);\n\n    /// @notice retrieves the asset purpose for a given loan agreement ID\n    function getAssetPurpose(uint256 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/types.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nstruct LoanAssetInfo {\n    uint256[] tokenIds;\n    uint256[] nonces;\n    address validator;\n    bytes validateSignature;\n}\n\nbytes32 constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\nbytes32 constant VALIDATOR_ADMIN_ROLE = keccak256(\"VALIDATOR_ADMIN_ROLE\");"
    },
    "contracts/uid/IUniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface IUniqueIdentity is IERC1155Upgradeable {\n    /// @notice Mint a new UniqueIdentity token to the msgSender\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding mint params:\n    ///                  account, id, expiresAt, address(this), nonces[account], block.chainid\n    ///                  from an address with the SIGNER_ROLE.\n    function mint(uint256 id, uint256 expiresAt, bytes calldata signature) external payable;\n\n    /// @notice Mint a new UniqueIdentity token to the `recipient`\n    /// @param recipient The recipient address to be minted to.\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding mintTo params:\n    ///                  (account, recipient, id, expiresAt, address(this), nonces[account], block.chainid)\n    ///                  from an address with the SIGNER_ROLE.\n    function mintTo(\n        address recipient,\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) external payable;\n\n    /// @notice Burn a UniqueIdentity token of `id` from the `account`\n    /// @param account The account which currently owns the UID\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding burn params:\n    ///                  (account, id, expiresAt, address(this), nonces[account], block.chainid)\n    ///                  from an address with the SIGNER_ROLE.\n    function burn(address account, uint256 id, uint256 expiresAt, bytes calldata signature) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
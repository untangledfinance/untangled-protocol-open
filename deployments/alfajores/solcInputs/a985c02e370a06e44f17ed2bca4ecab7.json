{
  "language": "Solidity",
  "sources": {
    "contracts/base/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Factory {\n    // https://github.com/OpenZeppelin/openzeppelin-sdk/blob/master/packages/lib/contracts/upgradeability/ProxyFactory.sol\n    function deployMinimal(address _logic) internal returns (address proxy) {\n        bytes20 targetBytes = bytes20(_logic);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n        return proxy;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../note-sale/MintedIncreasingInterestTGE.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../base/Factory.sol';\nimport '../../libraries/ConfigHelper.sol';\n\ncontract SecuritizationManager is UntangledBase, Factory, ISecuritizationManager {\n    using ConfigHelper for Registry;\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init(_msgSender());\n\n        registry = _registry;\n    }\n\n    event NewTGECreated(address instanceAddress);\n    event NewNotesTokenCreated(address instanceAddress);\n    event NewPoolCreated(address instanceAddress);\n\n    //noteSaleAddress, investor, amount, tokenAmount\n    event TokensPurchased(address indexed investor, address indexed tgeAddress, uint256 amount, uint256 tokenAmount);\n\n    modifier onlyPoolExisted(ISecuritizationPool pool) {\n        require(isExistingPools[address(pool)], 'SecuritizationManager: Pool does not exist');\n        _;\n    }\n\n    modifier onlyManager(ISecuritizationPool pool) {\n        require(\n            pool.hasRole(pool.OWNER_ROLE(), _msgSender()),\n            'SecuritizationManager: Not the controller of the project'\n        );\n        _;\n    }\n\n    modifier doesSOTExist(ISecuritizationPool pool) {\n        require(poolToSOT[address(pool)] == address(0), 'SecuritizationManager: Already exists SOT token');\n        _;\n    }\n    modifier doesJOTExist(ISecuritizationPool pool) {\n        require(poolToJOT[address(pool)] == address(0), 'SecuritizationManager: Already exists JOT token');\n        _;\n    }\n\n    function getPoolsLength() public view returns (uint256) {\n        return pools.length;\n    }\n\n    function newPoolInstance(address currency, uint32 minFirstLossCushion)\n        external\n        whenNotPaused\n        nonReentrant\n        onlyRole(POOL_CREATOR)\n        returns (address)\n    {\n        address poolImplAddress = address(registry.getSecuritizationPool());\n        address poolAddress = deployMinimal(poolImplAddress);\n\n        ISecuritizationPool poolInstance = ISecuritizationPool(poolAddress);\n        poolInstance.initialize(registry, currency, minFirstLossCushion);\n        poolInstance.grantRole(poolInstance.OWNER_ROLE(), _msgSender());\n        poolInstance.renounceRole(poolInstance.OWNER_ROLE(), address(this));\n\n        isExistingPools[poolAddress] = true;\n        pools.push(poolInstance);\n\n        emit NewPoolCreated(poolAddress);\n\n        return poolAddress;\n    }\n\n    function initialTGEForSOT(\n        address issuerTokenController,\n        ISecuritizationPool pool,\n        uint8 saleType,\n        uint8 decimalToken,\n        bool longSale\n    ) external whenNotPaused nonReentrant onlyManager(pool) onlyPoolExisted(pool) doesSOTExist(pool) {\n        INoteTokenFactory noteTokenFactory = registry.getNoteTokenFactory();\n        address sotToken = noteTokenFactory.createToken(\n            address(pool),\n            Configuration.NOTE_TOKEN_TYPE.SENIOR,\n            decimalToken\n        );\n        address tgeAddress = registry.getTokenGenerationEventFactory().createNewSaleInstance(\n            issuerTokenController,\n            address(pool),\n            sotToken,\n            pool.underlyingCurrency(),\n            saleType,\n            longSale\n        );\n        noteTokenFactory.changeMinterRole(sotToken, tgeAddress);\n\n        pool.injectTGEAddress(tgeAddress, sotToken, Configuration.NOTE_TOKEN_TYPE.SENIOR);\n\n        poolToSOT[address(pool)] = sotToken;\n        isExistingTGEs[tgeAddress] = true;\n\n        emit NewTGECreated(tgeAddress);\n        emit NewNotesTokenCreated(sotToken);\n    }\n\n    function initialTGEForJOT(\n        address issuerTokenController,\n        ISecuritizationPool pool,\n        uint8 saleType,\n        uint8 decimalToken,\n        bool longSale\n    ) external whenNotPaused nonReentrant onlyManager(pool) onlyPoolExisted(pool) doesJOTExist(pool) {\n        INoteTokenFactory noteTokenFactory = registry.getNoteTokenFactory();\n        address jotToken = noteTokenFactory.createToken(\n            address(pool),\n            Configuration.NOTE_TOKEN_TYPE.JUNIOR,\n            decimalToken\n        );\n        address tgeAddress = registry.getTokenGenerationEventFactory().createNewSaleInstance(\n            issuerTokenController,\n            address(pool),\n            jotToken,\n            pool.underlyingCurrency(),\n            saleType,\n            longSale\n        );\n        noteTokenFactory.changeMinterRole(jotToken, tgeAddress);\n\n        pool.injectTGEAddress(tgeAddress, jotToken, Configuration.NOTE_TOKEN_TYPE.JUNIOR);\n\n        poolToJOT[address(pool)] = jotToken;\n        isExistingTGEs[tgeAddress] = true;\n\n        emit NewTGECreated(tgeAddress);\n        emit NewNotesTokenCreated(jotToken);\n    }\n\n    function buyTokens(address tgeAddress, uint256 currencyAmount) external whenNotPaused nonReentrant {\n        require(isExistingTGEs[tgeAddress], 'SMP: Note sale does not exist');\n\n        uint256 tokenAmount = MintedIncreasingInterestTGE(tgeAddress).buyTokens(\n            _msgSender(),\n            _msgSender(),\n            currencyAmount\n        );\n\n        emit TokensPurchased(_msgSender(), tgeAddress, currencyAmount, tokenAmount);\n    }\n\n    function pausePool(address poolAddress) external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(isExistingPools[poolAddress], 'SecuritizationManager: pool does not exist');\n        ISecuritizationPool pool = ISecuritizationPool(poolAddress);\n        pool.pause();\n    }\n\n    function unpausePool(address poolAddress) external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(isExistingPools[poolAddress], 'SecuritizationManager: pool does not exist');\n        ISecuritizationPool pool = ISecuritizationPool(poolAddress);\n        pool.unpause();\n    }\n\n    function pauseAllPools() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < pools.length; i++) {\n            pools[i].pause();\n        }\n    }\n\n    function unpauseAllPools() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < pools.length; i++) {\n            pools[i].unpause();\n        }\n    }\n}\n"
    },
    "contracts/protocol/note-sale/MintedIncreasingInterestTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './crowdsale/IncreasingInterestCrowdsale.sol';\nimport './base/LongSaleInterest.sol';\n\ncontract MintedIncreasingInterestTGE is IncreasingInterestCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n    }\n\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    function setYield(uint256 _yield) public whenNotPaused onlyRole(OWNER_ROLE) {\n        yield = _yield;\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused nonReentrant securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n        }\n    }\n\n    function getLongSaleTokenPrice(uint256 timestamp) public view returns (uint256) {\n        if (!finalized) return (RATE_SCALING_FACTOR**2) / rate;\n        else if (\n            Configuration.NOTE_TOKEN_TYPE(INoteToken(token).noteTokenType()) == Configuration.NOTE_TOKEN_TYPE.JUNIOR\n        ) {\n            address sotTgeAddress = ISecuritizationPool(pool).tgeAddress();\n            if (sotTgeAddress != address(0) && !FinalizableCrowdsale(sotTgeAddress).finalized())\n                return (RATE_SCALING_FACTOR**2) / rate;\n            return registry.getDistributionAssessor().calcTokenPrice(pool, token);\n        } else {\n            require(\n                timeStartEarningInterest != 0,\n                'MintedIncreasingInterestTGE: timeStartEarningInterest need to be setup'\n            );\n            return getPurchasePrice(interestRate, yield, timestamp - timeStartEarningInterest, termLengthInSeconds);\n        }\n    }\n\n    function getLongSaleTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return\n            _getTokenAmount((currencyAmount * PURCHASE_PRICE_SCALING_FACTOR) / getLongSaleTokenPrice(block.timestamp));\n    }\n\n    function startNewRoundSale(\n        uint256 openingTime,\n        uint256 closingTime,\n        uint256 rate,\n        uint256 cap\n    ) external whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate);\n        newSaleRoundTime(openingTime, closingTime);\n        _setTotalCap(cap);\n    }\n\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n        require(timeInterval > 0, 'MintedIncreasingInterestTGE: Time interval increasing interest is 0');\n    }\n}\n"
    },
    "contracts/base/UntangledBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\n\nimport '../libraries/Configuration.sol';\n\nabstract contract UntangledBase is\n    Initializable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\n\n    function __UntangledBase__init(address owner) internal onlyInitializing {\n        __UntangledBase__init_unchained(owner);\n    }\n\n    function __UntangledBase__init_unchained(address owner) internal onlyInitializing {\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n\n        if (owner == address(0)) owner = _msgSender();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(OWNER_ROLE, owner);\n\n        _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n    }\n\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n}\n"
    },
    "contracts/libraries/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\nimport './Configuration.sol';\n\nimport '../interfaces/ISecuritizationManager.sol';\nimport '../interfaces/ISecuritizationPool.sol';\nimport '../interfaces/INoteTokenFactory.sol';\nimport '../interfaces/ITokenGenerationEventFactory.sol';\nimport '../interfaces/IUntangledERC721.sol';\nimport '../interfaces/IDistributionOperator.sol';\nimport '../interfaces/IDistributionTranche.sol';\nimport '../interfaces/ILoanRegistry.sol';\nimport '../interfaces/ILoanInterestTermsContract.sol';\nimport '../interfaces/ILoanRepaymentRouter.sol';\nimport '../interfaces/ILoanKernel.sol';\nimport '../interfaces/IDistributionAssessor.sol';\nimport '../interfaces/ISecuritizationPoolValueService.sol';\nimport '../protocol/note-sale/MintedIncreasingInterestTGE.sol';\nimport '../protocol/note-sale/MintedNormalTGE.sol';\nimport '../tokens/ERC1155/CollateralManagementToken.sol';\nimport '../protocol/cma/SupplyChainManagementProgram.sol';\nimport '../protocol/loan/inventory/InventoryCollateralizer.sol';\nimport '../protocol/loan/inventory/InventoryInterestTermsContract.sol';\nimport '../protocol/loan/inventory/InventoryLoanKernel.sol';\nimport '../protocol/loan/inventory/InventoryLoanRegistry.sol';\nimport '../protocol/loan/inventory/InventoryLoanRepaymentRouter.sol';\nimport '../protocol/loan/invoice/InvoiceCollateralizer.sol';\nimport '../protocol/loan/invoice/InvoiceDebtRegistry.sol';\nimport '../protocol/loan/invoice/InvoiceFinanceInterestTermsContract.sol';\nimport '../protocol/loan/invoice/InvoiceLoanKernel.sol';\nimport '../protocol/loan/invoice/InvoiceLoanRepaymentRouter.sol';\n\nlibrary ConfigHelper {\n    function getAddress(Registry registry, Configuration.CONTRACT_TYPE contractType) internal view returns (address) {\n        return registry.getAddress(uint8(contractType));\n    }\n\n    function getSecuritizationManager(Registry registry) internal view returns (ISecuritizationManager) {\n        return ISecuritizationManager(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER));\n    }\n\n    function getSecuritizationPool(Registry registry) internal view returns (ISecuritizationPool) {\n        return ISecuritizationPool(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL));\n    }\n\n    function getNoteTokenFactory(Registry registry) internal view returns (INoteTokenFactory) {\n        return INoteTokenFactory(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY));\n    }\n\n    function getTokenGenerationEventFactory(Registry registry) internal view returns (ITokenGenerationEventFactory) {\n        return\n            ITokenGenerationEventFactory(\n                getAddress(registry, Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY)\n            );\n    }\n\n    function getDistributionOperator(Registry registry) internal view returns (IDistributionOperator) {\n        return IDistributionOperator(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR));\n    }\n\n    function getLoanAssetToken(Registry registry) internal view returns (IUntangledERC721) {\n        return IUntangledERC721(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN));\n    }\n\n    function getAcceptedInvoiceToken(Registry registry) internal view returns (AcceptedInvoiceToken) {\n        return AcceptedInvoiceToken(getAddress(registry, Configuration.CONTRACT_TYPE.ACCEPTED_INVOICE_TOKEN));\n    }\n\n    function getLoanRegistry(Registry registry) internal view returns (ILoanRegistry) {\n        return ILoanRegistry(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REGISTRY));\n    }\n\n    function getLoanInterestTermsContract(Registry registry) internal view returns (ILoanInterestTermsContract) {\n        return\n            ILoanInterestTermsContract(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT));\n    }\n\n    function getLoanRepaymentRouter(Registry registry) internal view returns (ILoanRepaymentRouter) {\n        return ILoanRepaymentRouter(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER));\n    }\n\n    function getLoanKernel(Registry registry) internal view returns (ILoanKernel) {\n        return ILoanKernel(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_KERNEL));\n    }\n\n    function getDistributionTranche(Registry registry) internal view returns (IDistributionTranche) {\n        return IDistributionTranche(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE));\n    }\n\n    function getSecuritizationPoolValueService(Registry registry)\n        internal\n        view\n        returns (ISecuritizationPoolValueService)\n    {\n        return\n            ISecuritizationPoolValueService(\n                getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE)\n            );\n    }\n\n    function getDistributionAssessor(Registry registry) internal view returns (IDistributionAssessor) {\n        return IDistributionAssessor(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR));\n    }\n\n    function getMintedIncreasingInterestTGE(Registry registry) internal view returns (MintedIncreasingInterestTGE) {\n        return\n            MintedIncreasingInterestTGE(\n                getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE)\n            );\n    }\n\n    function getMintedNormalTGE(Registry registry) internal view returns (MintedNormalTGE) {\n        return\n        MintedNormalTGE(\n            getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE)\n        );\n    }\n\n    function getCollateralManagementToken(Registry registry) internal view returns (CollateralManagementToken) {\n        return CollateralManagementToken(getAddress(registry, Configuration.CONTRACT_TYPE.COLLATERAL_MANAGEMENT_TOKEN));\n    }\n\n    function getSupplyChainManagementProgram(Registry registry) internal view returns (SupplyChainManagementProgram) {\n        return SupplyChainManagementProgram(getAddress(registry, Configuration.CONTRACT_TYPE.SUPPLY_CHAIN_MANAGEMENT_PROGRAM));\n    }\n\n    function getInventoryLoanRegistry(Registry registry) internal view returns (InventoryLoanRegistry) {\n        return InventoryLoanRegistry(getAddress(registry, Configuration.CONTRACT_TYPE.INVENTORY_LOAN_REGISTRY));\n    }\n\n    function getInventoryCollateralizer(Registry registry) internal view returns (InventoryCollateralizer) {\n        return InventoryCollateralizer(getAddress(registry, Configuration.CONTRACT_TYPE.INVENTORY_COLLATERALIZER));\n    }\n\n    function getInventoryInterestTermsContract(Registry registry) internal view returns (InventoryInterestTermsContract) {\n        return InventoryInterestTermsContract(getAddress(registry, Configuration.CONTRACT_TYPE.INVENTORY_INTEREST_TERMS_CONTRACT));\n    }\n\n    function getInventoryLoanKernel(Registry registry) internal view returns (InventoryLoanKernel) {\n        return InventoryLoanKernel(getAddress(registry, Configuration.CONTRACT_TYPE.INVENTORY_LOAN_KERNEL));\n    }\n\n    function getInventoryLoanRepaymentRouter(Registry registry) internal view returns (InventoryLoanRepaymentRouter) {\n        return InventoryLoanRepaymentRouter(getAddress(registry, Configuration.CONTRACT_TYPE.INVENTORY_LOAN_REPAYMENT_ROUTER));\n    }\n\n    function getInvoiceDebtRegistry(Registry registry) internal view returns (InvoiceDebtRegistry) {\n        return InvoiceDebtRegistry(getAddress(registry, Configuration.CONTRACT_TYPE.INVOICE_DEBT_REGISTRY));\n    }\n\n    function getInvoiceCollateralizer(Registry registry) internal view returns (InvoiceCollateralizer) {\n        return InvoiceCollateralizer(getAddress(registry, Configuration.CONTRACT_TYPE.INVOICE_COLLATERALIZER));\n    }\n\n    function getInvoiceFinanceInterestTermsContract(Registry registry) internal view returns (InvoiceFinanceInterestTermsContract) {\n        return InvoiceFinanceInterestTermsContract(getAddress(registry, Configuration.CONTRACT_TYPE.INVOICE_FINANCE_INTEREST_TERMS_CONTRACT));\n    }\n\n    function getInvoiceLoanKernel(Registry registry) internal view returns (InvoiceLoanKernel) {\n        return InvoiceLoanKernel(getAddress(registry, Configuration.CONTRACT_TYPE.INVOICE_LOAN_KERNEL));\n    }\n\n    function getInvoiceLoanRepaymentRouter(Registry registry) internal view returns (InvoiceLoanRepaymentRouter) {\n        return InvoiceLoanRepaymentRouter(getAddress(registry, Configuration.CONTRACT_TYPE.INVOICE_LOAN_REPAYMENT_ROUTER));\n    }\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/IncreasingInterestCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './FinalizableCrowdsale.sol';\n\nabstract contract IncreasingInterestCrowdsale is FinalizableCrowdsale {\n    uint32 public initialInterest;\n    uint32 public finalInterest;\n    uint32 public timeInterval;\n    uint32 public amountChangeEachInterval;\n\n    uint32 public pickedInterest;\n\n    function setInterestRange(\n        uint32 _initialInterest,\n        uint32 _finalInterest,\n        uint32 _timeInterval,\n        uint32 _amountChangeEachInterval\n    ) public whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        require(!hasStarted, 'IncreasingInterestCrowdsale: sale already started');\n        require(\n            _initialInterest <= _finalInterest,\n            'IncreasingInterestCrowdsale: initial interest is not less than final interest'\n        );\n        require(_timeInterval > 0, 'IncreasingInterestCrowdsale: time interval is 0');\n\n        initialInterest = _initialInterest;\n        finalInterest = _finalInterest;\n        timeInterval = _timeInterval;\n        amountChangeEachInterval = _amountChangeEachInterval;\n    }\n\n    function getCurrentInterest() public view returns (uint32) {\n        if (block.timestamp < openingTime) {\n            return 0;\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint256 elapsedTime = block.timestamp - openingTime;\n        uint256 numberInterval = elapsedTime / timeInterval;\n\n        uint32 currentInterest = uint32(amountChangeEachInterval * numberInterval + initialInterest);\n\n        if (currentInterest > finalInterest) {\n            return finalInterest;\n        } else {\n            return currentInterest;\n        }\n    }\n\n    function _finalization() internal override {\n        super._finalization();\n\n        pickedInterest = getCurrentInterest();\n        ISecuritizationPool(pool).setInterestRateForSOT(pickedInterest);\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view override {\n        super._preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n        require(timeInterval > 0, 'IncreasingInterestCrowdsale: time interval not set');\n    }\n}\n"
    },
    "contracts/protocol/note-sale/base/LongSaleInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../../libraries/UntangledMath.sol';\n\ncontract LongSaleInterest {\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n    uint256 public constant PURCHASE_PRICE_SCALING_FACTOR = 10**4;\n\n    function getPurchasePrice(\n        uint256 _interestRate,\n        uint256 _yield,\n        uint256 _durationLengthInSec,\n        uint256 _termLengthInSeconds\n    ) public pure returns (uint256) {\n        require(_termLengthInSeconds > _durationLengthInSec, \"LongSaleInterest: _termLength must be greater than durationLength\");\n        uint256 moreDecimal = UntangledMath.ONE / INTEREST_RATE_SCALING_FACTOR_PERCENT / 100;\n        _interestRate = _interestRate * moreDecimal;\n        _yield = _yield * moreDecimal;\n\n        uint256 pricipalWithInterestInPercent = UntangledMath.ONE + _interestRate / YEAR_LENGTH_IN_SECONDS;\n\n        uint256 pricipalWithYieldInPercent = UntangledMath.ONE + _yield / YEAR_LENGTH_IN_SECONDS;\n\n        uint256 durationToEndTerm = _termLengthInSeconds - _durationLengthInSec;\n        return\n            (UntangledMath.rpow(pricipalWithInterestInPercent, _termLengthInSeconds, UntangledMath.ONE) *\n                PURCHASE_PRICE_SCALING_FACTOR) /\n            UntangledMath.rpow(pricipalWithYieldInPercent, durationToEndTerm, UntangledMath.ONE);\n    }\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/FinalizableCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TimedCrowdsale.sol';\n\nabstract contract FinalizableCrowdsale is TimedCrowdsale {\n    bool public finalized;\n\n    event CrowdsaleFinalized();\n\n    function finalize(bool claimRemainToken, address remainTokenRecipient)\n        public\n        whenNotPaused\n        nonReentrant\n        onlyRole(OWNER_ROLE)\n    {\n        require(!finalized, 'FinalizableCrowdsale: already finalized');\n        require(hasClosed() || totalCapReached(), 'FinalizableCrowdsale: not closed');\n\n        if (!isDistributedFully() && !isLongSale()) {\n            uint256 tokenRemain = 0;\n            tokenRemain = _getTokenAmount(getCurrencyRemainAmount());\n\n            if (claimRemainToken) {\n                _processPurchase(remainTokenRecipient, tokenRemain);\n            } else {\n                _ejectTokens(tokenRemain);\n            }\n        }\n\n        finalized = true;\n\n        _finalization();\n        emit CrowdsaleFinalized();\n    }\n\n    function _finalization() internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/TimedCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './Crowdsale.sol';\n\nabstract contract TimedCrowdsale is Crowdsale {\n    uint256 public openingTime;\n    uint256 public closingTime;\n\n    bool public isEnableTimeLimit;\n\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\n\n    function __TimedCrowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        isEnableTimeLimit = true;\n    }\n\n    modifier onlyWhileOpen() {\n        require(isOpen() || isLongSale(), 'TimedCrowdsale: not open');\n        _;\n    }\n\n    function isOpen() public view returns (bool) {\n        if (!isEnableTimeLimit) {\n            return true;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp >= openingTime && block.timestamp <= closingTime;\n    }\n\n    function hasClosed() public view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > closingTime;\n    }\n\n    function extendTime(uint256 newClosingTime) external whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        require(newClosingTime > closingTime, 'TimedCrowdsale: new closing time is before current closing time');\n\n        emit TimedCrowdsaleExtended(closingTime, newClosingTime);\n        closingTime = newClosingTime;\n    }\n\n    function newSaleRoundTime(uint256 newOpeningTime, uint256 newClosingTime) public whenNotPaused onlyRole(OWNER_ROLE) {\n        require(newClosingTime >= newOpeningTime, 'TimedCrowdsale: opening time is not before closing time');\n        // not accept opening time in the past\n        if (newOpeningTime < block.timestamp) {\n            newOpeningTime = block.timestamp;\n        }\n\n        if (newClosingTime <= newOpeningTime) {\n            newClosingTime = newOpeningTime + 1;\n        }\n\n        openingTime = newOpeningTime;\n        closingTime = newClosingTime;\n    }\n\n    function setUsingTimeLimit(bool usingTimeLimit) public whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        isEnableTimeLimit = usingTimeLimit;\n    }\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/Crowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../../base/UntangledBase.sol';\nimport '../../../interfaces/ISecuritizationPool.sol';\nimport '../../../libraries/ConfigHelper.sol';\nimport '../../../interfaces/INoteToken.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nabstract contract Crowdsale is UntangledBase {\n    using ConfigHelper for Registry;\n\n    Registry public registry;\n\n    // decimal calculating for rate\n    uint256 public constant RATE_SCALING_FACTOR = 10**4;\n\n    address public pool;\n\n    // The token being sold\n    address public token;\n    // The token for pay\n    address public currency;\n\n    // How many token units a buyer gets per currency.\n    uint256 public rate; // support by RATE_SCALING_FACTOR decimal numbers\n    bool public hasStarted;\n\n    // Amount of currency raised\n    uint256 public currencyRaised;\n    uint256 public tokenRaised;\n\n    uint256 public totalCap;\n\n    mapping(address => uint256) public currencyRaisedByInvestor;\n\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    function __Crowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __UntangledBase__init_unchained(_msgSender());\n        registry = _registry;\n        pool = _pool;\n        token = _token;\n        currency = _currency;\n    }\n\n    modifier securitizationPoolRestricted() {\n        require(_msgSender() == pool, 'Crowdsale: Caller must be pool');\n        _;\n    }\n\n    modifier smpRestricted() {\n        require(_msgSender() == address(registry.getSecuritizationManager()), 'Crowdsale: Caller must be pool');\n        _;\n    }\n\n    function addFunding(uint256 additionalCap) public whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        require(additionalCap > 0, 'Crowdsale: total cap is 0');\n\n        totalCap = additionalCap + totalCap;\n    }\n\n    function _newSaleRound(uint256 newRate) internal {\n        require(!hasStarted, 'Crowdsale: Sale round overflow');\n\n        hasStarted = true;\n        rate = newRate;\n    }\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) external whenNotPaused nonReentrant smpRestricted returns (uint256) {\n        uint256 tokenAmount = isLongSale() ? getLongSaleTokenAmount(currencyAmount) : _getTokenAmount(currencyAmount);\n\n        _preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n\n        // update state\n        currencyRaised += currencyAmount;\n        currencyRaisedByInvestor[beneficiary] += currencyAmount;\n\n        tokenRaised += tokenAmount;\n\n        _claimPayment(payee, currencyAmount);\n        _processPurchase(beneficiary, tokenAmount);\n        emit TokensPurchased(_msgSender(), beneficiary, currencyAmount, tokenAmount);\n\n        _forwardFunds(ISecuritizationPool(pool).pot(), currencyAmount);\n\n        return tokenAmount;\n    }\n\n    function isDistributedFully() public view returns (bool) {\n        return currencyRaised == totalCap;\n    }\n\n    function getTokenRemainAmount() public view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    function getCurrencyRemainAmount() public view virtual returns (uint256) {\n        return totalCap - currencyRaised;\n    }\n\n    function isLongSale() public view virtual returns (bool);\n\n    function getLongSaleTokenAmount(uint256 currencyAmount) public view virtual returns (uint256);\n\n    function _defaultPreValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view {\n        require(beneficiary != address(0), 'Crowdsale: beneficiary is zero address');\n        //        require(currencyAmount != 0, \"currency amount is 0\");\n        require(tokenAmount != 0, 'Crowdsale: token amount is 0');\n        require(isUnderTotalCap(currencyAmount), 'Crowdsale: cap exceeded');\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view virtual {\n        _defaultPreValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n    }\n\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\n        INoteToken(token).mint(beneficiary, tokenAmount);\n    }\n\n    function _ejectTokens(uint256 tokenAmount) internal {\n        INoteToken(token).burn(tokenAmount);\n    }\n\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\n        _deliverTokens(beneficiary, tokenAmount);\n    }\n\n    function _claimPayment(address payee, uint256 currencyAmount) internal {\n        IERC20(currency).transferFrom(payee, address(this), currencyAmount);\n    }\n\n    function _getTokenAmount(uint256 currencyAmount) public view returns (uint256) {\n        require(rate > 0, 'Crowdsale: rate is 0');\n        uint256 TEN = 10;\n        return\n            (currencyAmount * rate * TEN**ERC20(token).decimals()) /\n            (RATE_SCALING_FACTOR * TEN**ERC20(currency).decimals());\n    }\n\n    function _getCurrencyAmount(uint256 tokenAmount) internal view returns (uint256) {\n        if (rate == 0) return 0;\n        uint256 TEN = 10;\n        return\n            (tokenAmount * RATE_SCALING_FACTOR * TEN**ERC20(currency).decimals()) /\n            (rate * TEN**ERC20(token).decimals());\n    }\n\n    function _forwardFunds(address beneficiary, uint256 currencyAmount) internal {\n        IERC20(currency).transfer(beneficiary, currencyAmount);\n    }\n\n    function _setTotalCap(uint256 cap) internal {\n        require(cap > 0, 'Crowdsale: cap is 0');\n        require(cap >= currencyRaised, 'Crowdsale: cap is bellow currency raised');\n\n        totalCap = cap;\n    }\n\n    function totalCapReached() public view returns (bool) {\n        return currencyRaised >= totalCap;\n    }\n\n    function isUnderTotalCap(uint256 currencyAmount) public view returns (bool) {\n        return currencyRaised + currencyAmount <= totalCap;\n    }\n}\n"
    },
    "contracts/interfaces/ISecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\nimport '../base/UntangledBase.sol';\n\nabstract contract ISecuritizationPool is UntangledBase {\n    Registry public registry;\n\n    bytes32 public constant ORIGINATOR_ROLE = keccak256('ORIGINATOR_ROLE');\n\n    address public tgeAddress;\n    address public secondTGEAddress;\n    address public sotToken;\n    address public jotToken;\n    address public underlyingCurrency;\n\n    //CycleState\n    CycleState public state;\n\n    uint64 public openingBlockTimestamp;\n    uint64 public termLengthInSeconds;\n\n    // for lending operation\n    uint256 public totalLockedDistributeBalance;\n    // token address -> total locked\n    mapping(address => uint256) public totalLockedRedeemBalances;\n    // token address -> user -> locked\n    mapping(address => mapping(address => uint256)) public lockedDistributeBalances;\n    mapping(address => mapping(address => uint256)) public lockedRedeemBalances;\n\n    // user -> amount\n    mapping(address => uint256) public paidInterestAmountSOT;\n    mapping(address => uint256) public lastRepayTimestampSOT;\n\n    // for base (sell-loan) operation\n    uint256 public principalAmountSOT;\n    uint256 public paidPrincipalAmountSOT;\n    uint32 public interestRateSOT; // Annually, support 4 decimals num\n\n    uint32 public minFirstLossCushion;\n\n    //RiskScores\n    RiskScore[] public riskScores;\n\n    //ERC721 Assets\n    NFTAsset[] public nftAssets;\n\n    address[] public tokenAssetAddresses;\n    mapping(address => bool) public existsTokenAssetAddress;\n\n    mapping(address => uint256) public paidPrincipalAmountSOTByInvestor;\n\n    // by default it is address(this)\n    address public pot;\n\n    /** ENUM & STRUCT */\n    enum CycleState {\n        INITIATED,\n        CROWDSALE,\n        OPEN,\n        CLOSED\n    }\n\n    struct NFTAsset {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    struct RiskScore {\n        uint32 daysPastDue;\n        uint32 advanceRate;\n        uint32 penaltyRate;\n        uint32 interestRate;\n        uint32 probabilityOfDefault;\n        uint32 lossGivenDefault;\n        uint32 gracePeriod;\n        uint32 collectionPeriod;\n        uint32 writeOffAfterGracePeriod;\n        uint32 writeOffAfterCollectionPeriod;\n    }\n\n    function initialize(\n        Registry _registry,\n        address _currency,\n        uint32 _minFirstLossCushion\n    ) public virtual;\n\n    /** GETTER */\n    function getNFTAssetsLength() public view virtual returns (uint256);\n\n    function getTokenAssetAddresses() public view virtual returns (address[] memory);\n\n    function getTokenAssetAddressesLength() public view virtual returns (uint256);\n\n    function getRiskScoresLength() public view virtual returns (uint256);\n\n    function isClosedState() public view virtual returns (bool);\n\n    function hasFinishedRedemption() public view virtual returns (bool);\n\n    /** EXTERNAL */\n    function setPot(address _pot) external virtual;\n\n    function setupRiskScores(\n        uint32[] calldata _daysPastDues,\n        uint32[] calldata _ratesAndDefaults,\n        uint32[] calldata _periodsAndWriteOffs\n    ) external virtual;\n\n    function exportAssets(\n        address tokenAddress,\n        address toPoolAddress,\n        uint256[] calldata tokenIds\n    ) external virtual;\n\n    function withdrawAssets(\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        address[] calldata recipients\n    ) external virtual;\n\n    function collectAssets(\n        address tokenAddress,\n        address from,\n        uint256[] calldata tokenIds\n    ) external virtual;\n\n    function collectERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata senders,\n        uint256[] calldata amounts\n    ) external virtual;\n\n    function withdrawERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external virtual;\n\n    function claimERC20Assets(address[] calldata tokenAddresses) external virtual;\n\n    function claimCashRemain(address recipientWallet) external virtual;\n\n    function injectTGEAddress(\n        address _tgeAddress,\n        address _tokenAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteToken\n    ) external virtual;\n\n    function startCycle(\n        uint64 _termLengthInSeconds,\n        uint256 _principalAmountForSOT,\n        uint32 _interestRateForSOT,\n        uint64 _timeStartEarningInterest\n    ) external virtual;\n\n    function setInterestRateForSOT(uint32 _interestRateSOT) external virtual;\n\n    function increaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external virtual;\n\n    function decreaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external virtual;\n\n    function redeem(\n        address usr,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external virtual;\n}\n"
    },
    "contracts/interfaces/INoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol';\n\nabstract contract INoteToken is ERC20PresetMinterPauser {\n    address public poolAddress;\n    uint8 public noteTokenType;\n\n    uint8 internal _d;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/libraries/Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Configuration {\n    uint256 public constant PRICE_SCALING_FACTOR = 10**4;\n\n    // NEVER EVER CHANGE THE ORDER OF THESE!\n    // You can rename or append. But NEVER change the order.\n    enum CONTRACT_TYPE {\n        SECURITIZATION_MANAGER,\n        SECURITIZATION_POOL,\n        NOTE_TOKEN_FACTORY,\n        TOKEN_GENERATION_EVENT_FACTORY,\n        DISTRIBUTION_OPERATOR,\n        DISTRIBUTION_ASSESSOR,\n        DISTRIBUTION_TRANCHE,\n        LOAN_ASSET_TOKEN,\n        ACCEPTED_INVOICE_TOKEN,\n        LOAN_REGISTRY,\n        LOAN_INTEREST_TERMS_CONTRACT,\n        LOAN_REPAYMENT_ROUTER,\n        LOAN_KERNEL,\n        ERC20_TOKEN_REGISTRY,\n        ERC20_TOKEN_TRANSFER_PROXY,\n        SECURITIZATION_MANAGEMENT_PROJECT,\n        SECURITIZATION_POOL_VALUE_SERVICE,\n        MINTED_INCREASING_INTEREST_TGE,\n        MINTED_NORMAL_TGE,\n        COLLATERAL_MANAGEMENT_TOKEN,\n        SUPPLY_CHAIN_MANAGEMENT_PROGRAM,\n        INVENTORY_LOAN_REGISTRY,\n        INVENTORY_COLLATERALIZER,\n        INVENTORY_INTEREST_TERMS_CONTRACT,\n        INVENTORY_LOAN_KERNEL,\n        INVENTORY_LOAN_REPAYMENT_ROUTER,\n        INVOICE_COLLATERALIZER,\n        INVOICE_DEBT_REGISTRY,\n        INVOICE_FINANCE_INTEREST_TERMS_CONTRACT,\n        INVOICE_LOAN_KERNEL,\n        INVOICE_LOAN_REPAYMENT_ROUTER\n    }\n\n    enum NOTE_TOKEN_TYPE {\n        SENIOR,\n        JUNIOR\n    }\n\n    enum ASSET_PURPOSE {\n        SALE,\n        PLEDGE\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/storage/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../base/UntangledBase.sol';\n\ncontract Registry is UntangledBase {\n    mapping(uint8 => address) public contractAddresses;\n\n    event AddressUpdated(address owner, uint8 index, address oldValue, address newValue);\n\n    function initialize() public initializer {\n        __UntangledBase__init(_msgSender());\n    }\n\n    function _setAddress(uint8 addressIndex, address newAddress) private {\n        emit AddressUpdated(_msgSender(), addressIndex, contractAddresses[addressIndex], newAddress);\n        contractAddresses[addressIndex] = newAddress;\n    }\n\n    function getAddress(uint8 index) public view returns (address) {\n        return contractAddresses[index];\n    }\n\n    function setSecuritizationManager(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER), newAddress);\n    }\n\n    function setSecuritizationPool(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL), newAddress);\n    }\n\n    function setNoteTokenFactory(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY), newAddress);\n    }\n\n    function setTokenGenerationEventFactory(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY), newAddress);\n    }\n\n    function setMintedIncreasingInterestTGE(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE), newAddress);\n    }\n\n    function setMintedNormalTGE(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE), newAddress);\n    }\n\n    function setDistributionOperator(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR), newAddress);\n    }\n\n    function setDistributionAssessor(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR), newAddress);\n    }\n\n    function setLoanAssetToken(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN), newAddress);\n    }\n\n    function setAcceptedInvoiceToken(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.ACCEPTED_INVOICE_TOKEN), newAddress);\n    }\n\n    function setDistributionTranche(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE), newAddress);\n    }\n\n    function setSecuritizationPoolValueService(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE), newAddress);\n    }\n\n    function setLoanRegistry(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REGISTRY), newAddress);\n    }\n\n    function setLoanInterestTermsContract(address newAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        whenNotPaused\n        nonReentrant\n    {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT), newAddress);\n    }\n\n    function setLoanRepaymentRouter(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER), newAddress);\n    }\n\n    function setLoanKernel(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_KERNEL), newAddress);\n    }\n\n    function setCollateralManagementToken(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.COLLATERAL_MANAGEMENT_TOKEN), newAddress);\n    }\n\n    function setSupplyChainManagementProgram(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SUPPLY_CHAIN_MANAGEMENT_PROGRAM), newAddress);\n    }\n\n    function setInventoryLoanKernel(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVENTORY_LOAN_KERNEL), newAddress);\n    }\n\n    function setInventoryLoanRegistry(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVENTORY_LOAN_REGISTRY), newAddress);\n    }\n\n    function setInventoryLoanRepaymentRouter(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVENTORY_LOAN_REPAYMENT_ROUTER), newAddress);\n    }\n\n    function setInventoryInterestTermsContract(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVENTORY_INTEREST_TERMS_CONTRACT), newAddress);\n    }\n\n    function setInventoryCollateralizer(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVENTORY_COLLATERALIZER), newAddress);\n    }\n\n    function setInvoiceLoanKernel(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVOICE_LOAN_KERNEL), newAddress);\n    }\n\n    function setInvoiceDebtRegistry(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVOICE_DEBT_REGISTRY), newAddress);\n    }\n\n    function setInvoiceLoanRepaymentRouter(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVOICE_LOAN_REPAYMENT_ROUTER), newAddress);\n    }\n\n    function setInvoiceFinanceInterestTermsContract(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVOICE_FINANCE_INTEREST_TERMS_CONTRACT), newAddress);\n    }\n\n    function setInvoiceCollateralizer(address newAddress) public onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused nonReentrant {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.INVOICE_COLLATERALIZER), newAddress);\n    }\n}\n"
    },
    "contracts/interfaces/ISecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\nimport './ISecuritizationPool.sol';\n\nabstract contract ISecuritizationManager {\n    Registry public registry;\n\n    mapping(address => bool) public isExistingPools;\n    ISecuritizationPool[] public pools;\n\n    mapping(address => address) public poolToSOT;\n    mapping(address => address) public poolToJOT;\n\n    mapping(address => bool) public isExistingTGEs;\n\n    bytes32 public constant POOL_CREATOR = keccak256('POOL_CREATOR');\n}\n"
    },
    "contracts/interfaces/INoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\nimport '../tokens/ERC20/NoteToken.sol';\n\nabstract contract INoteTokenFactory {\n    Registry public registry;\n\n    NoteToken[] public tokens;\n\n    mapping(address => bool) public isExistingTokens;\n\n    function changeMinterRole(address token, address newController) external virtual;\n\n    function createToken(\n        address poolAddress,\n        Configuration.NOTE_TOKEN_TYPE noteTokenType,\n        uint8 _nDecimals\n    ) external virtual returns (address);\n}\n"
    },
    "contracts/interfaces/ITokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\n\nabstract contract ITokenGenerationEventFactory {\n    Registry public registry;\n\n    address[] public tgeAddresses;\n\n    mapping(address => bool) public isExistingTge;\n\n    function createNewSaleInstance(\n        address issuerTokenController,\n        address pool,\n        address token,\n        address currency,\n        uint8 saleType,\n        bool longSale\n    ) external virtual returns (address);\n}\n"
    },
    "contracts/interfaces/IUntangledERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol';\nimport '../storage/Registry.sol';\n\nabstract contract IUntangledERC721 is ERC721PresetMinterPauserAutoIdUpgradeable {\n    Registry public registry;\n\n    function __UntangledERC721__init(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __UntangledERC721__init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __UntangledERC721__init_unchained(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _mint(to, tokenId);\n    }\n\n    function getTotalExpectedRepaymentValue(uint256 agreementId, uint256 timestamp)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function getExpirationTimestamp(uint256 agreementId) external view virtual returns (uint256);\n\n    function getInterestRate(uint256 agreementId) external view virtual returns (uint256);\n\n    function getRiskScore(uint256 agreementId) external view virtual returns (uint8);\n\n    function getAssetPurpose(uint256 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n}\n"
    },
    "contracts/interfaces/IDistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDistributionOperator {}\n"
    },
    "contracts/interfaces/IDistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDistributionTranche {\n    function redeem(\n        address usr,\n        address pool,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external;\n\n    function redeemToken(\n        address noteToken,\n        address usr,\n        uint256 tokenAmount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ILoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\n\nabstract contract ILoanRegistry {\n    Registry public registry;\n\n    // loan -> debtors\n    struct LoanEntry {\n        address loanTermContract;\n        address debtor;\n        address principalTokenAddress;\n        bytes32 termsParam; // actually inside this param was already included P token address\n        uint256 salt;\n        uint256 issuanceBlockTimestamp;\n        uint256 lastRepayTimestamp;\n        uint256 expirationTimestamp;\n        uint8 riskScore;\n        Configuration.ASSET_PURPOSE assetPurpose;\n    }\n\n    mapping(bytes32 => LoanEntry) public entries;\n\n    mapping(bytes32 => bool) public manualInterestLoan;\n    mapping(bytes32 => uint256) public manualInterestAmountLoan;\n\n    mapping(bytes32 => bool) public completedLoans;\n\n    function initialize(Registry _registry) public virtual;\n\n    /**\n     * Record new External Loan to blockchain\n     */\n    function insert(\n        bytes32 tokenId,\n        address termContract,\n        address debtor,\n        bytes32 termsContractParameter,\n        address pTokenAddress,\n        uint256 _salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] calldata assetPurposeAndRiskScore\n    ) external virtual returns (bool);\n\n    function getLoanDebtor(bytes32 tokenId) public view virtual returns (address);\n\n    function getLoanTermParams(bytes32 tokenId) public view virtual returns (bytes32);\n\n    function getPrincipalTokenAddress(bytes32 agreementId) public view virtual returns (address);\n\n    function getDebtor(bytes32 agreementId) public view virtual returns (address);\n\n    function getTermContract(bytes32 agreementId) public view virtual returns (address);\n\n    function getRiskScore(bytes32 agreementId) public view virtual returns (uint8);\n\n    function getAssetPurpose(bytes32 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n\n    /**\n     * Returns the timestamp of the block at which a debt agreement was issued.\n     */\n    function getIssuanceBlockTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    function getLastRepaymentTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    /**\n     * Returns the terms contract parameters of a given issuance\n     */\n    function getTermsContractParameters(bytes32 agreementId) public view virtual returns (bytes32);\n\n    function getExpirationTimestamp(bytes32 agreementId) public view virtual returns (uint256);\n\n    // Update timestamp of the last repayment from Debtor\n    function updateLastRepaymentTimestamp(bytes32 agreementId, uint256 newTimestamp) public virtual;\n\n    /// @dev Get principal payment info before start doing repayment\n    function principalPaymentInfo(bytes32 agreementId)\n        public\n        view\n        virtual\n        returns (address pTokenAddress, uint256 pAmount);\n\n    function setCompletedLoan(bytes32 agreementId) public virtual;\n}\n"
    },
    "contracts/interfaces/ILoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\n\nabstract contract ILoanInterestTermsContract {\n    Registry public registry;\n\n    mapping(bytes32 => bool) public startedLoan;\n\n    mapping(bytes32 => uint256) public repaidPrincipalAmounts;\n    mapping(bytes32 => uint256) public repaidInterestAmounts;\n\n    mapping(bytes32 => bool) public completedRepayment;\n\n    // Register to start Loan term for batch of agreement Ids\n    function registerTermStart(bytes32 agreementId) public virtual returns (bool);\n\n    function getValueRepaidToDate(bytes32 agreementId) public view virtual returns (uint256, uint256);\n\n    function isCompletedRepayments(bytes32[] memory agreementIds) public view virtual returns (bool[] memory);\n\n    /**\n     * Expected repayment value with Amortization of Interest and Principal\n     * (AMORTIZATION) - will be used for repayment from Debtor\n     */\n    function getExpectedRepaymentValues(bytes32 agreementId, uint256 timestamp)\n        public\n        view\n        virtual\n        returns (uint256 expectedPrincipal, uint256 expectedInterest);\n\n    function getMultiExpectedRepaymentValues(bytes32[] memory agreementIds, uint256 timestamp)\n        public\n        view\n        virtual\n        returns (uint256[] memory, uint256[] memory);\n\n    function registerConcludeLoan(bytes32 agreementId) external virtual returns (bool);\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  payer address. The address of the payer.\n    /// @param  beneficiary address. The address of the payment's beneficiary.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    function registerRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public virtual returns (uint256 remains);\n\n    function getInterestRate(bytes32 agreementId) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../base/UntangledBase.sol';\nimport '../storage/Registry.sol';\n\nabstract contract ILoanRepaymentRouter is UntangledBase {\n    Registry public registry;\n\n    enum Errors {\n        DEBT_AGREEMENT_NONEXISTENT,\n        PAYER_BALANCE_OR_ALLOWANCE_INSUFFICIENT,\n        REPAYMENT_REJECTED_BY_TERMS_CONTRACT\n    }\n\n    event LogOutputSubmit(bytes32 indexed _agreementId, uint256 indexed _tokenIndex, uint256 _totalAmount);\n\n    function initialize(Registry _registry) public virtual;\n\n    event LogRepayment(\n        bytes32 indexed _agreementId,\n        address indexed _payer,\n        address indexed _beneficiary,\n        uint256 _amount,\n        address _token\n    );\n\n    event LogRepayments(bytes32[] _agreementIds, address _payer, uint256[] _amounts);\n\n    event LogError(uint8 indexed _errorId, bytes32 indexed _agreementId);\n\n    function repayInBatch(\n        bytes32[] calldata agreementIds,\n        uint256[] calldata amounts,\n        address tokenAddress\n    ) external virtual returns (bool);\n}\n"
    },
    "contracts/interfaces/ILoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\n\nabstract contract ILoanKernel {\n    Registry public registry;\n\n    /****************** */\n    // CONSTANTS\n    /****************** */\n    enum Errors {\n        // Debt has been already been issued\n        DEBT_ISSUED, // 0\n        // Order has already expired\n        ORDER_EXPIRED, // 1\n        // Debt issuance associated with order has been cancelled\n        ISSUANCE_CANCELLED, // 2\n        // Order has been cancelled\n        ORDER_CANCELLED, // 3\n        // Order parameters specify amount of creditor / debtor fees\n        // that is not equivalent to the amount of underwriter / relayer fees\n        ORDER_INVALID_INSUFFICIENT_OR_EXCESSIVE_FEES, // 4\n        // Order parameters specify insufficient principal amount for\n        // debtor to at least be able to meet his fees\n        ORDER_INVALID_INSUFFICIENT_PRINCIPAL, // 5\n        // Order parameters specify non zero fee for an unspecified recipient\n        ORDER_INVALID_UNSPECIFIED_FEE_RECIPIENT, // 6\n        // Order signatures are mismatched / malformed\n        ORDER_INVALID_NON_CONSENSUAL, // 7\n        // Insufficient balance or allowance for principal token transfer\n        CREDITOR_BALANCE_OR_ALLOWANCE_INSUFFICIENT, // 8\n        // Debt doesn't exists\n        DEBT_NOT_EXISTS, // 9\n        // Debtor it not completed repayment yet\n        NOT_COMPLETED_REPAYMENT // 10\n    }\n\n    enum FillingAddressesIndex {\n        CREDITOR,\n        PRINCIPAL_TOKEN_ADDRESS,\n        REPAYMENT_ROUTER,\n        TERM_CONTRACT,\n        RELAYER\n    }\n\n    enum FillingNumbersIndex {\n        CREDITOR_FEE,\n        ASSET_PURPOSE\n    }\n\n    bytes32 public constant NULL_ISSUANCE_HASH = bytes32(0);\n    bytes16 public constant NULL_COLLATERAL_INFO_HASH = bytes16(0);\n    address public constant NULL_ADDRESS = address(0x0);\n    //********************************************************* */\n\n    //****** */\n    // EVENTS\n    //****** */\n    event LogDebtKernelError(uint8 indexed _errorId, bytes32 indexed _orderHash, string desc);\n\n    event LogFeeTransfer(address indexed payer, address token, uint256 amount, address indexed beneficiary);\n    event LogDebtOrderFilled(\n        bytes32 agreementId,\n        uint256[] principalAmounts,\n        address principalTokenAddress,\n        address relayer\n    );\n\n    event IssuedNewInputLoans(address[] debtor, uint256[] loanTokenIds);\n\n    event LogDebtOrderFilled(bytes32 _agreementId, uint256 _principal, address _principalToken, address _relayer);\n\n    //********************************************************* */\n\n    /*********** */\n    // STRUCTURES\n    /*********** */\n\n    struct LoanIssuance {\n        address version;\n        address termsContract;\n        address[] debtors;\n        bytes32[] termsContractParameters; // for different loans\n        bytes32[] agreementIds;\n        uint256[] salts;\n    }\n\n    struct LoanOrder {\n        LoanIssuance issuance;\n        address principalTokenAddress;\n        uint256[] principalAmounts;\n        uint256 creditorFee;\n        address relayer;\n        uint256[] expirationTimestampInSecs;\n        bytes32[] debtOrderHashes;\n        uint8[] riskScores;\n        uint8 assetPurpose;\n    }\n\n    /*********** */\n    // VARIABLES\n    /*********** */\n    mapping(bytes32 => bool) public issuanceCancelled;\n    mapping(bytes32 => bool) public debtOrderCancelled;\n    mapping(bytes32 => bool) public debtOrderCompleted;\n}\n"
    },
    "contracts/interfaces/IDistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract IDistributionAssessor {\n    function getSOTTokenPrice(address securitizationPool, uint256 timestamp) public view virtual returns (uint256);\n\n    function calcTokenPrice(address pool, address tokenAddress) external view virtual returns (uint256);\n\n    function getCashBalance(address pool) public view virtual returns (uint256);\n\n    function calcAssetValue(\n        address pool,\n        address tokenAddress,\n        address investor\n    ) external view virtual returns (uint256 principal, uint256 interest);\n\n    function calcCorrespondingTotalAssetValue(\n        address tokenAddress,\n        address investor,\n        uint256 timestamp\n    ) external view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISecuritizationPoolValueService {\n    function getOutstandingPrincipalCurrencyByInvestor(address pool, address investor) external view returns (uint256);\n\n    function getExpectedAssetsValue(address poolAddress, uint256 timestamp)\n        external\n        view\n        returns (uint256 expectedAssetsValue);\n}\n"
    },
    "contracts/protocol/note-sale/MintedNormalTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './base/LongSaleInterest.sol';\nimport \"../../libraries/ConfigHelper.sol\";\nimport './crowdsale/FinalizableCrowdsale.sol';\n\ncontract MintedNormalTGE is FinalizableCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n    }\n\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    function setYield(uint256 _yield) public whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        yield = _yield;\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused nonReentrant securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n        }\n    }\n\n    function getLongSaleTokenPrice(uint256 timestamp) public view returns (uint256) {\n        if (!finalized) return (RATE_SCALING_FACTOR**2) / rate;\n        else if (\n            Configuration.NOTE_TOKEN_TYPE(INoteToken(token).noteTokenType()) == Configuration.NOTE_TOKEN_TYPE.JUNIOR\n        ) {\n            address sotTgeAddress = ISecuritizationPool(pool).tgeAddress();\n            if (sotTgeAddress != address(0) && !FinalizableCrowdsale(sotTgeAddress).finalized())\n                return (RATE_SCALING_FACTOR**2) / rate;\n            return registry.getDistributionAssessor().calcTokenPrice(pool, token);\n        } else {\n            require(\n                timeStartEarningInterest != 0,\n                'MintedIncreasingInterestTGE: timeStartEarningInterest need to be setup'\n            );\n            return getPurchasePrice(interestRate, yield, timestamp - timeStartEarningInterest, termLengthInSeconds);\n        }\n    }\n\n    function getLongSaleTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return\n            _getTokenAmount((currencyAmount * PURCHASE_PRICE_SCALING_FACTOR) / getLongSaleTokenPrice(block.timestamp));\n    }\n\n    function startNewRoundSale(\n        uint256 openingTime,\n        uint256 closingTime,\n        uint256 rate,\n        uint256 cap\n    ) external whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate);\n        newSaleRoundTime(openingTime, closingTime);\n        _setTotalCap(cap);\n    }\n\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n    }\n}\n"
    },
    "contracts/tokens/ERC1155/CollateralManagementToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol\";\n\ncontract CollateralManagementToken is ERC1155PresetMinterPauserUpgradeable, ERC1155SupplyUpgradeable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    function initialize(\n        address minter,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        string memory uri\n    ) public initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        __ERC1155PresetMinterPauser_init(uri);\n        __ERC1155Supply_init();\n\n        _setupRole(MINTER_ROLE, minter);\n        renounceRole(MINTER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155SupplyUpgradeable, ERC1155PresetMinterPauserUpgradeable){\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC1155Upgradeable, ERC1155PresetMinterPauserUpgradeable)\n    returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n    /**\n     * @notice Get total supply of liquidity tokens\n     * @param _ids ID of the Tokens\n     * @return The total supply of each liquidity token id provided in _ids\n   */\n    function totalSupplyOfBatch(uint256[] calldata _ids)\n    external view returns (uint256[] memory)\n    {\n        uint256[] memory batchTotalSupplies = new uint256[](_ids.length);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            batchTotalSupplies[i] = totalSupply(_ids[i]);\n        }\n        return batchTotalSupplies;\n    }\n\n    function balanceOfProjects(address _owner, uint256[] calldata _projectIds) external view returns (uint256[] memory) {\n        // The balance of any account can be calculated from the Transfer events history.\n        // However, since we need to keep the balances to validate transfer request,\n        // there is no extra cost to also privide a querry function.\n\n        uint256[] memory balanceOfWallets = new uint256[](_projectIds.length);\n\n        for (uint i = 0; i < _projectIds.length; i++) {\n            balanceOfWallets[i] = balanceOf(_owner, _projectIds[i]);\n        }\n\n        return balanceOfWallets;\n    }\n}\n\n"
    },
    "contracts/protocol/cma/SupplyChainManagementProgram.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/ISupplyChainManagementProgram.sol\";\nimport \"../../libraries/ConfigHelper.sol\";\nimport \"../loan/inventory/InventoryLoanRegistry.sol\";\n\ncontract SupplyChainManagementProgram is ISupplyChainManagementProgram {\n    using ConfigHelper for Registry;\n\n    /** CONSTRUCTOR */\n    function initialize(\n        Registry _registry\n    ) public override initializer {\n        __Pausable_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n\n        address owner = _msgSender();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, owner);\n        _setupRole(OWNER_ROLE, owner);\n\n        registry = _registry;\n    }\n\n    function _isMovementExisting(\n        uint256 projectId,\n        string memory movementId\n    ) internal view returns (bool) {\n        bytes32 identifyHashMovement = keccak256(abi.encodePacked(movementId));\n        return projectToExistedMovements[projectId][identifyHashMovement];\n    }\n\n    function _isMovementExisting(\n        uint256 projectId,\n        bytes32 movementHash\n    ) internal view returns (bool) {\n        return projectToExistedMovements[projectId][movementHash];\n    }\n\n    function _isCollateralManager(uint256 projectId, address manager) internal view returns (bool) {\n        return collateralProjects[projectId].managerAddress == manager;\n    }\n\n    modifier onlyCollateralManager(uint256 projectId) {\n        require(_isCollateralManager(projectId, msg.sender) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Collateral Manager: caller is not the manager of the project\");\n        _;\n    }\n\n    modifier onlyTrader(uint256 projectId) {\n        require(projectToTraders[projectId][msg.sender], \"Collateral Project: caller is not the trader of the project\");\n        _;\n    }\n\n    modifier onlyProjectExisted(uint256 projectId) {\n        require(isExistingProjects[projectId], \"Project does not exists.\");\n        _;\n    }\n\n    modifier onlyPriceFeedManager() {\n        require(\n            isExistingManager[msg.sender] || hasRole(PRICE_FEED_ROLE, msg.sender),\n            \"SupplyChainManagementProgram: Not authorized to update price\"\n        );\n        _;\n    }\n\n    //************  */\n    // EXTERNAL\n    //************  *\n    // Create new CMA project\n    function newProject(\n        uint256 projectId,\n        string memory companyId,\n        address projectWallet\n    ) public override {\n        // 1. Create new multisignature wallet as tokens recepient of this CMA project\n        // 2. Record project information to metadata of new Non-Fungile Token\n        // 3. Mint initBalance quantity of Fungible Token and credit to Multisign Wallet above\n        require(!isExistingProjects[projectId], \"Project already existed\");\n\n        collateralProjects[projectId] = CollateralProject({\n        managerAddress : msg.sender,\n        projectWallet : projectWallet,\n        companyHash : keccak256(abi.encodePacked(companyId))\n        });\n        isExistingProjects[projectId] = true;\n        isExistingManager[msg.sender] = true;\n    }\n\n    function updateCompanyId(uint256 projectId, string memory companyId) public override\n    onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId){\n\n        CollateralProject memory collateralProject = collateralProjects[projectId];\n        collateralProject.companyHash = keccak256(abi.encodePacked(companyId));\n\n        collateralProjects[projectId] = collateralProject;\n\n    }\n\n    function addCommodity (\n        uint256 projectId,\n        uint256 projectCommodityId,\n        string memory commodity,\n        uint256 initBalance\n    ) public override\n    onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId) {\n        require(!projectToExistedProjectCommodity[projectId][projectCommodityId], \"Project commodity already existed.\");\n\n        projectCommodityToCommodity[projectCommodityId] = keccak256(abi.encodePacked(commodity));\n        projectCommodityToProject[projectCommodityId] = projectId;\n        projectToExistedProjectCommodity[projectId][projectCommodityId] = true;\n\n        address walletAddress = collateralProjects[projectId].projectWallet;\n\n        bytes  memory data;\n        registry.getCollateralManagementToken().mint(walletAddress, projectCommodityId, initBalance, data);\n    }\n\n    // Add Trader for CMA project\n    function addTrader(uint256 projectId, address trader)\n    public override onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId) {\n        require(!projectToTraders[projectId][trader], \"Trader already existed.\");\n        projectToTraders[projectId][trader] = true;\n    }\n\n    // Add Lender for CMA project\n    function addLender(uint256 projectId, address lender)\n    public\n    override\n    onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId) {\n        require(!projectToLenders[projectId][lender], \"Lender already existed.\");\n        projectToLenders[projectId][lender] = true;\n    }\n\n    // Add Executor for CMA project\n    function addExecutor(uint256 projectId, address executor)\n    public override onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId) {\n        require(!projectToExecutors[projectId][executor], \"Executor already existed.\");\n        projectToExecutors[projectId][executor] = true;\n    }\n\n    // Remove Trader for CMA project\n    /** @dev NOTE: delete array element but still occupy storage space */\n    function removeTrader(uint256 projectId, address trader)\n    public override onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId) {\n        require(projectToTraders[projectId][trader], \"Trader does not exist.\");\n        delete projectToTraders[projectId][trader];\n    }\n\n    // Remove Lender for CMA project\n    function removeLender(uint256 projectId, address lender)\n    public\n    override\n    onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId) {\n        require(projectToLenders[projectId][lender], \"Lender does not exist.\");\n        delete projectToLenders[projectId][lender];\n    }\n\n    // Remove Executor for CMA project\n    function removeExecutor(uint256 projectId, address executor)\n    public override\n    onlyProjectExisted(projectId)\n    onlyCollateralManager(projectId) {\n        require(projectToExecutors[projectId][executor], \"Executor does not exist.\");\n        delete projectToExecutors[projectId][executor];\n    }\n\n    function isTrader(uint256 projectId, address account) public override view returns (bool) {\n        return projectToTraders[projectId][account];\n    }\n\n    function isLender(uint256 projectId, address account) public override view returns (bool) {\n        return projectToLenders[projectId][account];\n    }\n\n    function isExecutor(uint256 projectId, address account) public override view returns (bool) {\n        return projectToExecutors[projectId][account];\n    }\n\n    function initMovement(\n        string memory movementId,\n        uint256 projectId,\n        uint256 projectCommodityId,\n        uint8 _movementType\n    ) public override onlyProjectExisted(projectId) onlyTrader(projectId) {\n        require(!_isMovementExisting(projectId, movementId), \"Movement already existed.\");\n        require(projectToExistedProjectCommodity[projectId][projectCommodityId], \"Project commodity not existed.\");\n        require(_movementType != uint8(MovementType.UNKNOWN), \"Unknown movement type.\");\n\n        bytes32 identifyHashMovement = keccak256(abi.encodePacked(movementId));\n\n        Movement memory movement = Movement({\n        projectCommodityId: projectCommodityId,\n        movementType: MovementType.UNKNOWN,\n        state: MovementState.INITIATED,\n        quantity: 0,\n        initiator: msg.sender,\n        approver: address(0x0),\n        executor: address(0x0)\n        });\n\n        if (_movementType == uint8(MovementType.DEPOSIT)) {\n            movement.movementType = MovementType.DEPOSIT;\n\n        } else if (_movementType == uint8(MovementType.WITHDRAW)) {\n            movement.movementType = MovementType.WITHDRAW;\n        }\n\n        projectToMovements[projectId][identifyHashMovement] = movement;\n        projectToExistedMovements[projectId][identifyHashMovement] = true;\n    }\n\n    function approveMovement(\n        string memory movementId,\n        uint256 projectId\n    ) public override {\n        updateStateMovement(\n            movementId,\n            projectId,\n            MovementState.APPROVED,\n            0,\n            msg.sender\n        );\n    }\n\n    function executeMovement(\n        string memory movementId,\n        uint256 projectId,\n        uint _quantity\n    ) public override {\n        updateStateMovement(\n            movementId,\n            projectId,\n            MovementState.EXECUTED,\n            _quantity,\n            msg.sender\n        );\n    }\n\n    function updateStateMovement(\n        string memory movementId,\n        uint256 projectId,\n        MovementState _movementState,\n        uint _quantity,\n        address caller\n    ) public override onlyProjectExisted(projectId) {\n        require(_isMovementExisting(projectId, movementId), \"Movement does not exist.\");\n\n        bytes32 identifyHashMovement = keccak256(abi.encodePacked(movementId));\n\n        Movement memory movement = projectToMovements[projectId][identifyHashMovement];\n\n        if (_movementState == MovementState.EXECUTED) {\n            require(isExecutor(projectId, caller), \"Collateral Manager: caller is not the executor of the project\");\n            require(movement.state == MovementState.INITIATED, \"Execute Movement: state invalid\");\n            require(_quantity > 0, \"Invalid movement quantity.\");\n\n            if(movement.movementType == MovementType.WITHDRAW) {\n                _doWithdraw(movement.initiator, movement.projectCommodityId, _quantity);\n            } else if (movement.movementType == MovementType.DEPOSIT) {\n                _doDeposit(movement.initiator, movement.projectCommodityId, _quantity);\n            }\n\n            movement.quantity = _quantity;\n            movement.state = MovementState.EXECUTED;\n            movement.executor = caller;\n        }\n\n        projectToMovements[projectId][identifyHashMovement] = movement;\n    }\n\n    // Trader do withdraw\n    function _doWithdraw(address trader, uint256 projectCommodityId, uint quantity) internal {\n        registry.getCollateralManagementToken().burn(trader, projectCommodityId, quantity);\n    }\n\n    // Trader do Deposit\n    function _doDeposit(address trader, uint256 projectCommodityId, uint quantity) internal {\n        registry.getCollateralManagementToken().mint(trader, projectCommodityId, quantity, \"\");\n    }\n\n    function isProjectExisting(uint256 projectId) public override view returns (bool) {\n        return isExistingProjects[projectId];\n    }\n\n    /**\n    * @dev NOTE: memory & public is not recommeneded for function which have input param is arrays, calldata & external function instead\n     */\n    function bulkInsertCompletedMovement(\n        bytes32[] memory movementIdsHashes,\n        uint256[] memory projectIds,\n        uint256[] memory projectCommodityIds,\n        uint8[] memory movementTypes,\n        address[] memory traders,\n        address[] memory executors,\n        uint[] memory quantities\n    ) public override {\n        for (uint256 i = 0; i < movementIdsHashes.length; ++i) {\n            require(isExistingProjects[projectIds[i]], \"Project does not exists.\");\n            require(!_isMovementExisting(projectIds[i], movementIdsHashes[i]), \"Movement already existed.\");\n            require(projectToExistedProjectCommodity[projectIds[i]][projectCommodityIds[i]], \"Project commodity not existed.\");\n            require(movementTypes[i] != uint8(MovementType.UNKNOWN), \"Unknown movement type.\");\n            require(quantities[i] != 0, \"Invalid movement quantity.\");\n            require(_isCollateralManager(projectIds[i], msg.sender), \"Collateral Manager: caller is not the manager of the project\");\n            require(isTrader(projectIds[i], traders[i]), \"Collateral Project: not the trader of the project\");\n            require(isExecutor(projectIds[i], executors[i]), \"Collateral Manager: not the executor of the project\");\n\n            Movement memory movement = Movement({\n            projectCommodityId: projectCommodityIds[i],\n            movementType: MovementType.UNKNOWN,\n            state: MovementState.EXECUTED,\n            quantity: quantities[i],\n            initiator: traders[i],\n            approver: address(0x0),\n            executor: executors[i]\n            });\n\n            if (movementTypes[i] == uint8(MovementType.DEPOSIT)) {\n                _doDeposit(traders[i], movement.projectCommodityId, movement.quantity);\n                movement.movementType = MovementType.DEPOSIT;\n\n            } else if (movementTypes[i] == uint8(MovementType.WITHDRAW)) {\n                _doWithdraw(traders[i], movement.projectCommodityId, movement.quantity);\n                movement.movementType = MovementType.WITHDRAW;\n            }\n\n            projectToMovements[projectIds[i]][movementIdsHashes[i]] = movement;\n            projectToExistedMovements[projectIds[i]][movementIdsHashes[i]] = true;\n        }\n    }\n\n    function addExistedBalance(\n        uint256 projectId,\n        uint256 projectCommodityId,\n        address trader,\n        uint quantity\n    ) public override onlyProjectExisted(projectId) onlyCollateralManager(projectId) {\n        require(projectToExistedProjectCommodity[projectId][projectCommodityId], \"Project commodity not existed.\");\n        require(isTrader(projectId, trader), \"Collateral Project: trader is not the trader of the project\");\n        require(quantity != 0, \"Invalid quantity.\");\n\n        registry.getCollateralManagementToken().mint(trader, projectCommodityId, quantity, \"\");\n    }\n\n    function removeExistedBalance(\n        uint256 projectId,\n        uint256 projectCommodityId,\n        address trader,\n        uint quantity\n    ) public override onlyProjectExisted(projectId) onlyCollateralManager(projectId) {\n        require(projectToExistedProjectCommodity[projectId][projectCommodityId], \"Project commodity not existed.\");\n        require(isTrader(projectId, trader), \"Collateral Project: trader is not the trader of the project\");\n        require(quantity != 0, \"Invalid quantity.\");\n\n        registry.getCollateralManagementToken().burn(trader, projectCommodityId, quantity);\n    }\n\n    function getCommodityPrice(uint256 projectCommodityId) public override view returns (uint256) {\n        require(projectCommodityToCommodity[projectCommodityId] != bytes32(0), \"SupplyChainManagementProgram: project commodity not existed\");\n        return projectCommodityToPrice[projectCommodityId];\n    }\n\n    function updateCommodityPrice(uint256 projectCommodityId, uint256 price) public override onlyPriceFeedManager() {\n        require(price > 0, \"SupplyChainManagementProgram: price must greater than 0\");\n        require(projectCommodityToCommodity[projectCommodityId] != bytes32(0), \"SupplyChainManagementProgram: project commodity not existed\");\n\n        if (projectCommodityToPrice[projectCommodityId] != price) {\n            projectCommodityToPrice[projectCommodityId] = price;\n            InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n\n            if (projectCommodityToAgreements[projectCommodityId].length > 0) {\n                for (uint i = 0; i < projectCommodityToAgreements[projectCommodityId].length; ++i) {\n                    debtRegistry.selfEvaluateCollateralRatio(projectCommodityToAgreements[projectCommodityId][i]);\n                }\n            }\n        }\n    }\n\n    function insertAgreementToCommodity(uint256 projectCommodityId, bytes32 agreementId) public override {\n        require(msg.sender == address(registry.getInventoryLoanKernel()), \"SupplyChainManagementProgram: not authorized to add agreement\");\n        require(projectCommodityToCommodity[projectCommodityId] != bytes32(0), \"SupplyChainManagementProgram: project commodity not existed\");\n\n        projectCommodityToAgreements[projectCommodityId].push(agreementId);\n    }\n\n    function removeAgreementFromCommodity(uint256 projectCommodityId, bytes32 agreementId) public override onlyRole(OWNER_ROLE) {\n//        require(isOwner() || _isAuthorizedContract(msg.sender), \"SupplyChainManagementProgram: not authorized to remove agreement\");\n        require(projectCommodityToCommodity[projectCommodityId] != bytes32(0), \"SupplyChainManagementProgram: project commodity not existed\");\n\n        if (projectCommodityToAgreements[projectCommodityId].length > 0) {\n            for (uint i = 0; i < projectCommodityToAgreements[projectCommodityId].length; ++i) {\n                if (projectCommodityToAgreements[projectCommodityId][i] == agreementId) {\n\n                    // Remove i element from projectCommodityToAgreements[projectCommodityId]\n                    for (uint index = i; index<projectCommodityToAgreements[projectCommodityId].length-1; index++){\n                        projectCommodityToAgreements[projectCommodityId][index] = projectCommodityToAgreements[projectCommodityId][index+1];\n                    }\n                    projectCommodityToAgreements[projectCommodityId].pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    function getAgreementsOfProjectCommodity(uint256 projectCommodityId) public override view returns (bytes32[] memory) {\n        return projectCommodityToAgreements[projectCommodityId];\n    }\n/*\n    function getProjectDetail(uint256 projectId) public override view onlyProjectExisted(projectId)\n    returns (address managerAddress, address projectWallet, bytes32 companyHash) {\n        return (collateralProjects[projectId].managerAddress, collateralProjects[projectId].projectWallet, collateralProjects[projectId].companyHash);\n    }\n\n    function getMovementDetail(string memory movementId, uint256 projectId)\n    public\n    override\n    view\n    onlyProjectExisted(projectId)\n    returns (\n        uint256 projectCommodityId,\n        MovementType movementType,\n        MovementState state,\n        uint256 quantity,\n        address initiator,\n        address approver,\n        address executor\n    )\n    {\n        require(\n            _isMovementExisting(projectId, movementId),\n            'Movement does not exist.'\n        );\n        bytes32 identifyHashMovement = keccak256(abi.encodePacked(movementId));\n\n        Movement memory movement = projectToMovements[projectId][identifyHashMovement];\n        return (\n        movement.projectCommodityId,\n        movement.movementType,\n        movement.state,\n        movement.quantity,\n        movement.initiator,\n        movement.approver,\n        movement.executor\n        );\n    }\n*/\n\n/*\n    function getProjectCommodityDetail(uint256 projectCommodityId) public override view\n    returns (\n        uint256 projectId,\n        uint256 price,\n        bytes32 commoditySymbol\n    ) {\n        return (\n        projectCommodityToProject[projectCommodityId],\n        projectCommodityToPrice[projectCommodityId],\n        projectCommodityToCommodity[projectCommodityId]\n        );\n    }\n*/\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n}"
    },
    "contracts/protocol/loan/inventory/InventoryCollateralizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../loan/inventory/InventoryInterestTermsContract.sol\";\nimport '@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/interfaces/IERC1155ReceiverUpgradeable.sol';\nimport '@openzeppelin/contracts/interfaces/IERC1155.sol';\nimport '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol';\nimport \"../../../base/UntangledBase.sol\";\nimport \"../../../libraries/ConfigHelper.sol\";\nimport \"../../../storage/Registry.sol\";\nimport \"./InventoryLoanRegistry.sol\";\nimport \"../../../tokens/ERC721/invoice/AcceptedInvoiceToken.sol\";\n\n\n/**\n*  Escrow account that hold all callaterals for Loans\n*/\ncontract InventoryCollateralizer is IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable, UntangledBase {\n    using SafeMath for uint;\n    using ConfigHelper for Registry;\n\n    Registry public registry;\n\n    bytes32 public constant COLLATERALIZER = keccak256('COLLATERALIZER');\n\n    // Collateralizer here refers to the owner of the asset that is being collateralized.\n    mapping(bytes32 => address) public agreementToCollateralizer;\n\n    ///////////////////////////////\n    // CONSTANTS               ///\n    /////////////////////////////\n    uint public constant SECONDS_IN_DAY = 24 * 60 * 60;\n    string public constant CONTEXT = \"InventoryCollateralizer\";\n    string public constant CONTEXT_COLLATERAL_SALE = \"collateral_sale\";\n\n    ///////////////////////////////\n    // EVENTS                  ///\n    /////////////////////////////\n    event CollateralReturned(\n        bytes32 indexed agreementID,\n        address indexed collateralizer,\n        address token,\n        uint amount\n    );\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n        registry = _registry;\n    }\n\n    ///////////////////////////////\n    // MODIFIERS               ///\n    /////////////////////////////\n\n    modifier onlyPermissionedInventoryTermContract(bytes32 agreementId) {\n        require(\n            msg.sender == registry.getInventoryLoanRegistry().getTermsContract(agreementId),\n            \"InventoryCollateralizer: Sender must be Term Contract of current Debt.\"\n        );\n        _;\n    }\n\n    ///////////////////////////////\n    // INTERNAL FUNCTIONS     ////\n    /////////////////////////////\n    function _unpackLoanTermsParametersFromBytes(bytes32 parameters)\n    internal\n    pure\n    returns (\n        uint _principalTokenIndex,\n        uint _principalAmount,\n        uint _interestRate,\n        uint _amortizationUnitType,\n        uint _termLengthInAmortizationUnits,\n        uint _gracePeriodInDays\n    )\n    {\n        // The first byte of the parameters encodes the principal token's index in the\n        // token registry.\n        bytes32 principalTokenIndexShifted = parameters & 0xff00000000000000000000000000000000000000000000000000000000000000;\n        // The subsequent 12 bytes of the parameters encode the PRINCIPAL AMOUNT.\n        bytes32 principalAmountShifted = parameters & 0x00ffffffffffffffffffffffff00000000000000000000000000000000000000;\n        // The subsequent 3 bytes of the parameters encode the INTEREST RATE.\n        bytes32 interestRateShifted = parameters & 0x00000000000000000000000000ffffff00000000000000000000000000000000;\n        // The subsequent 4 bits (half byte) encode the AMORTIZATION UNIT TYPE code.\n        bytes32 amortizationUnitTypeShifted = parameters & 0x00000000000000000000000000000000f0000000000000000000000000000000;\n        // The subsequent 12 bytes encode the term length, as denominated in\n        // the encoded amortization unit.\n        bytes32 termLengthInAmortizationUnitsShifted = parameters & 0x000000000000000000000000000000000ffffffffffffffffffffffff0000000;\n\n        bytes32 gracePeriodInDaysShifted = parameters & 0x000000000000000000000000000000000000000000000000000000000ff00000;\n\n        return (\n        uint(principalTokenIndexShifted >> 248),\n        uint(principalAmountShifted >> 152),\n        uint(interestRateShifted >> 128),\n        uint(amortizationUnitTypeShifted >> 124),\n        uint(termLengthInAmortizationUnitsShifted >> 28),\n        uint(gracePeriodInDaysShifted >> 20)\n        );\n    }\n\n    function _unpackInventoryCollateralParametersFromBytes(bytes16 collateralParams)\n    internal\n    pure\n    returns (uint, uint)\n    {\n        bytes16 collateralTokenIdShifted = collateralParams & 0xffffffff000000000000000000000000;\n        bytes16 collateralAmountShifted = collateralParams & 0x00000000ffffffffffffffffffffffff;\n\n        return (\n        uint256(uint128(collateralTokenIdShifted) >> 96),\n        uint256(uint128(collateralAmountShifted))\n        );\n    }\n\n    // Parameters from Loan which have collateral is Inventory\n    function retrieveInventoryCollateralParameters(bytes32 agreementId)\n    internal\n    view\n    returns (\n        address collateralToken,\n        uint _collateralAmount,\n        uint256 _collateralTokenId,\n        uint gracePeriodInDays,\n        InventoryInterestTermsContract termsContract\n    )\n    {\n        address termsContractAddress;\n        bytes32 termsContractParameters;\n        bytes16 collateralInfoParameters;\n\n        // Pull the terms contract and associated parameters for the agreement\n        (\n        termsContractAddress,\n        termsContractParameters,\n        collateralInfoParameters\n        ) = registry.getInventoryLoanRegistry().getTerms(agreementId);\n\n        // Unpack terms contract parameters in order to get inventory collateralization-specific params\n        (_collateralTokenId, _collateralAmount) = _unpackInventoryCollateralParametersFromBytes(collateralInfoParameters);\n        (,,,,, gracePeriodInDays) = _unpackLoanTermsParametersFromBytes(termsContractParameters);\n\n        // Resolve address of token associated with this agreement in token registry\n        collateralToken = address(registry.getCollateralManagementToken());\n        termsContract = InventoryInterestTermsContract(termsContractAddress);\n    }\n\n    ///////////////////////////////\n    // EXTERNAL FUNCTIONS     ///\n    /////////////////////////////\n\n    /**\n     * Transfers collateral from the debtor to the current contract, as custodian.\n     *\n     * @param agreementId bytes32 The debt agreement's ID\n     * @param collateralizer address The owner of the asset being collateralized\n     */\n    function collateralizeERC1155(\n        bytes32 agreementId,\n        address debtor,\n        address collateralizer\n    )\n    public\n    onlyRole(COLLATERALIZER)\n    whenNotPaused\n    {\n        // The token in which collateral is denominated\n        address collateralToken;\n        // The amount being put up for collateral\n        uint collateralAmount;\n        // erc1155 token id\n        uint256 collateralTokenId;\n        // The number of days a debtor has after a debt enters default\n        // before their collateral is eligible for seizure.\n        uint gracePeriodInDays;\n        // The terms contract according to which this asset is being collateralized.\n        InventoryInterestTermsContract termsContract;\n\n        // Fetch all relevant collateralization parameters\n        (\n        collateralToken,\n        collateralAmount,\n        collateralTokenId,\n        gracePeriodInDays,\n        termsContract\n        ) = retrieveInventoryCollateralParameters(agreementId);\n\n        require(\n            address(termsContract) == msg.sender,\n            \"InventoryCollateralizer: Sender must be Term Contract smart contract.\"\n        );\n        require(\n            collateralAmount > 0,\n            \"InventoryCollateralizer: Collateral amount must greater than 0.\"\n        );\n        require(\n            collateralToken != address(0),\n            \"InventoryCollateralizer: Token address must differ with address null.\"\n        );\n\n        require(\n            agreementToCollateralizer[agreementId] == address(0),\n            \"InventoryCollateralizer: This Debt must be not collateralized.\"\n        );\n\n        IERC1155 erc1155token = IERC1155(collateralToken);\n        address custodian = address(this);\n\n        // agreement is now collateralized.\n        agreementToCollateralizer[agreementId] = debtor;\n\n        IERC1155(erc1155token).safeTransferFrom(\n            collateralizer,\n            custodian,\n            collateralTokenId,\n            collateralAmount, \"\");\n    }\n\n    /**\n    * Add more collateral to increase CR\n    */\n    function additionInventoryCollateralize(\n        bytes32 agreementId,\n        address collateralizer,\n        uint amount,\n        address token\n    )\n    public\n    onlyRole(COLLATERALIZER)\n    whenNotPaused\n    {\n\n        // The token in which collateral is denominated\n        address collateralToken;\n        uint256 collateralTokenId;\n        // The terms contract according to which this asset is being collateralized.\n        InventoryInterestTermsContract termsContract;\n\n        (collateralToken,,collateralTokenId,,termsContract) = retrieveInventoryCollateralParameters(agreementId);\n\n        require(\n            address(termsContract) == msg.sender,\n            \"InventoryCollateralizer: Sender must be Term Contract smart contract.\"\n        );\n\n        require(\n            amount > 0,\n            \"InventoryCollateralizer: Collateral amount must greater than 0.\"\n        );\n        require(\n            collateralToken == token,\n            \"InventoryCollateralizer: Invalid collateral token.\"\n        );\n\n        IERC1155 erc1155token = IERC1155(collateralToken);\n        address custodian = address(this);\n\n        require(\n            erc1155token.balanceOf(collateralizer, collateralTokenId) >= amount,\n            \"InventoryCollateralizer: Balance of collateralizer must sufficient with required amount.\"\n        );\n\n        erc1155token.safeTransferFrom(\n            collateralizer,\n            custodian,\n            collateralTokenId,\n            amount, \"\");\n    }\n\n    /**\n    * withdraw more collateral to decrease CR\n    */\n    function withdrawInventoryCollateralize(\n        bytes32 agreementId,\n        address collateralizer,\n        uint amount,\n        address token\n    )\n    public\n    onlyRole(COLLATERALIZER)\n    whenNotPaused\n    {\n        require(agreementToCollateralizer[agreementId] != address(0), \"Invalid agreedmentId\");\n\n        // The token in which collateral is denominated\n        address collateralToken;\n        uint collateralAmount;\n        uint256 collateralTokenId;\n        // The terms contract according to which this asset is being collateralized.\n        InventoryInterestTermsContract termsContract;\n\n        (collateralToken,collateralAmount,collateralTokenId,,termsContract) = retrieveInventoryCollateralParameters(agreementId);\n\n        require(\n            address(termsContract) == msg.sender,\n            \"InventoryCollateralizer: Sender must be Term Contract smart contract.\"\n        );\n        require(\n            amount > 0,\n            \"InventoryCollateralizer: Withdraw amount must greater than 0.\"\n        );\n        require(\n            collateralAmount >= amount,\n            \"InventoryCollateralizer: Withdraw amount must less or equal collateral amount.\"\n        );\n        require(\n            collateralToken == token,\n            \"InventoryCollateralizer: Invalid collateral token.\"\n        );\n        require(collateralizer == agreementToCollateralizer[agreementId], \"InventoryCollateralizer: Invalid debtor of agreement\");\n\n        IERC1155(collateralToken).safeTransferFrom(\n            address(this),\n            collateralizer,\n            collateralTokenId,\n            amount,\n            \"\"\n        );\n\n        // log the return event.\n        emit CollateralReturned(\n            agreementId,\n            collateralizer,\n            collateralToken,\n            collateralAmount\n        );\n    }\n\n    function burnInventoryCollateralize(\n        bytes32 agreementId,\n        uint amount,\n        address token\n    )\n    public\n    onlyRole(COLLATERALIZER)\n    whenNotPaused\n    {\n\n        // The token in which collateral is denominated\n        address collateralToken;\n        uint256 collateralTokenId;\n        // The terms contract according to which this asset is being collateralized.\n        InventoryInterestTermsContract termsContract;\n\n        (collateralToken,,collateralTokenId,,termsContract) = retrieveInventoryCollateralParameters(agreementId);\n\n        require(\n            address(termsContract) == msg.sender,\n            \"InventoryCollateralizer: Sender must be Term Contract smart contract.\"\n        );\n\n        require(\n            amount > 0,\n            \"InventoryCollateralizer: Collateral amount must greater than 0.\"\n        );\n        require(\n            collateralToken == token,\n            \"InventoryCollateralizer: Invalid collateral token.\"\n        );\n\n        ERC1155Burnable erc1155token = ERC1155Burnable(collateralToken);\n\n        erc1155token.burn(address(this), collateralTokenId, amount);\n    }\n\n    /**\n     * Returns collateral to the debt agreement's original collateralizer\n     * if and only if the debt agreement's term has lapsed and\n     * the total expected repayment value has been repaid.\n     *\n     * @param agreementId bytes32 The debt agreement's ID\n     */\n    function returnInventoryCollateral(\n        bytes32 agreementId\n    )\n    public\n    whenNotPaused\n    onlyPermissionedInventoryTermContract(agreementId)\n    {\n        require(agreementToCollateralizer[agreementId] != address(0), \"Invalid agreementId\");\n        // The token in which collateral is denominated\n        address collateralToken;\n        // The amount being put up for collateral\n        uint collateralAmount;\n        uint256 collateralTokenId;\n\n        // The number of days a debtor has after a debt enters default\n        // before their collateral is eligible for seizure.\n        uint gracePeriodInDays;\n        // The terms contract according to which this asset is being collateralized.\n        InventoryInterestTermsContract termsContract;\n\n        // Fetch all relevant collateralization parameters.\n        (\n        collateralToken,\n        collateralAmount,\n        collateralTokenId,\n        gracePeriodInDays,\n        termsContract\n        ) = retrieveInventoryCollateralParameters(agreementId);\n\n        // Ensure a valid form of collateral is tied to this agreement id\n        require(collateralToken != address(0), \"Collateral token must different with NULL.\");\n\n        InventoryLoanRegistry inventoryLoanDebtRegistry = registry.getInventoryLoanRegistry();\n        // Ensure that the debt is not in a state of default\n        // Ensure Value Repaid to date is greater or equal expected value until this Debt expired\n        require(\n            inventoryLoanDebtRegistry.completedRepayment(agreementId),\n            \"Debtor have not completed repayment.\"\n        );\n\n        // determine collateralizer of the collateral.\n        address collateralizer = agreementToCollateralizer[agreementId];\n\n        // Mark agreement's collateral as withdrawn by setting the agreement's\n        // collateralizer to 0x0.\n        delete agreementToCollateralizer[agreementId];\n\n        if (collateralAmount > 0) {\n            ERC1155(collateralToken).safeTransferFrom(\n                address(this),\n                collateralizer,\n                collateralTokenId,\n                collateralAmount,\n                \"\"\n            );\n        }\n\n        // stop financing invoices\n        uint256[] memory invoiceTokenIds = inventoryLoanDebtRegistry.getInvoiceIds(agreementId);\n        if (invoiceTokenIds.length > 0) {\n            AcceptedInvoiceToken invoiceToken = registry.getAcceptedInvoiceToken();\n\n            for (uint i = 0; i < invoiceTokenIds.length; ++i) {\n                registry.getAcceptedInvoiceToken().transferFrom(\n                    address(this),\n                    collateralizer,\n                    invoiceTokenIds[i]\n                );\n                // stop financing\n                // TODO tanlm temporary disable\n                //                    invoiceToken.stopInventoryFinancing(bytes32(invoiceTokenIds[i]));\n            }\n        }\n\n        // log the return event.\n        emit CollateralReturned(\n            agreementId,\n            collateralizer,\n            collateralToken,\n            collateralAmount\n        );\n    }\n\n    // For receiving AIT token\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data) public returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n    external returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n    external returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n    *\n    */\n    function timestampAdjustedForGracePeriod(uint gracePeriodInDays)\n    public\n    view\n    returns (uint)\n    {\n        return block.timestamp.sub(\n            SECONDS_IN_DAY.mul(gracePeriodInDays)\n        );\n    }\n\n}\n"
    },
    "contracts/protocol/loan/inventory/InventoryInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './InventoryCollateralizer.sol';\nimport './InventoryLoanRegistry.sol';\nimport './InventoryLoanRepaymentRouter.sol';\nimport \"../../../libraries/UnpackLoanParamtersLib.sol\";\nimport \"../LoanTyping.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../../libraries/Unpack.sol\";\nimport \"../../../libraries/Unpack16.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../../protocol/loan/inventory/CRInventoryDecisionEngine.sol\";\n\ncontract InventoryInterestTermsContract is\n    CRInventoryDecisionEngine, LoanTyping, PausableUpgradeable, OwnableUpgradeable\n{\n    using SafeMath for uint;\n    using ConfigHelper for Registry;\n    using Unpack for bytes32;\n    using Unpack16 for bytes16;\n\n    Registry public registry;\n    uint256 public constant NUM_AMORTIZATION_UNIT_TYPES = 6;\n\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint256 public constant WEEK_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 7;\n    uint256 public constant MONTH_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 30;\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n\n    // To convert an encoded interest rate into its equivalent multiplier\n    // (for purposes of calculating total interest), divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 0.01 interest multiplier\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_MULTIPLIER = INTEREST_RATE_SCALING_FACTOR_PERCENT * 100;\n\n\n    enum AmortizationUnitType {\n        MINUTES, // 0 - since 1.0.13\n        HOURS, // 1\n        DAYS, // 2\n        WEEKS, // 3\n        MONTHS, // 4\n        YEARS // 5\n    }\n\n    struct InterestParams {\n        uint256 principalAmount;\n        uint256 termStartUnixTimestamp;\n        uint256 termEndUnixTimestamp;\n        AmortizationUnitType amortizationUnitType;\n        uint256 termLengthInAmortizationUnits;\n        // interest rates can, at a maximum, have 4 decimal places of precision.\n        uint256 interestRate;\n    }\n\n    modifier onlyRouter(LoanTypes loanType) {\n        require(\n            msg.sender == address(registry.getInventoryLoanRepaymentRouter()),\n            \"Only for Repayment Router.\"\n        );\n        _;\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n    modifier onlyDebtKernel() {\n        require(\n            msg.sender == address(registry.getInventoryLoanKernel()),\n            'Only for Debt Kernel.'\n        );\n        _;\n    }\n\n    function collateralize(\n        bytes32 agreementId, address[2]\n        memory addresses // 0. Debtor, 1. assetHolder\n    )\n        private\n    {\n        return registry.getInventoryCollateralizer().collateralizeERC1155(agreementId, addresses[0], addresses[1]);\n    }\n\n    /**\n    *   Start terms contract and sieze collateral tokens\n    */\n\n    function registerTermStart(bytes32 agreementId, address[2] memory addresses) // 0. Debtor, 1. assetHolder\n        public\n        returns (bool _success)\n    {\n        address termsContract;\n        bytes32 termsContractParameters;\n        bytes16 collateralInfoParameters;\n\n        (\n            termsContract,\n            termsContractParameters,\n            collateralInfoParameters\n        ) = registry.getInventoryLoanRegistry()\n            .getTerms(agreementId);\n        address principalTokenAddress = registry.getInventoryLoanRegistry().getAgreement(agreementId).principalTokenAddress;\n\n        uint256 principalAmount = termsContractParameters.unpackPrincipalAmount();\n        uint256 interestRate = termsContractParameters.unpackInterestRate();\n        uint256 amortizationUnitType= termsContractParameters.unpackAmortizationUnitType();\n        uint256 termLengthInAmortizationUnits= termsContractParameters.unpackTermLengthInAmortizationUnits();\n        uint256 gracePeriodInDays= termsContractParameters.unpackGracePeriodInDays();\n\n        collateralize(agreementId, addresses);\n\n        // Returns true (i.e. valid) if the specified principal token is valid,\n        // the specified amortization unit type is valid, and the terms contract\n        // associated with the agreement is this one.  We need not check\n        // if any of the other simple interest parameters are valid, because\n        // it is impossible to encode invalid values for them.\n        if (\n            principalTokenAddress != address(0) &&\n            amortizationUnitType < NUM_AMORTIZATION_UNIT_TYPES &&\n            termsContract == address(this)\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n   *   Get parameters by Agreement ID (commitment hash)\n   */\n    function _getAmortizationUnitLengthInSeconds(AmortizationUnitType amortizationUnitType)\n    internal\n    pure\n    returns (uint)\n    {\n        if (amortizationUnitType == AmortizationUnitType.MINUTES) {\n            return MINUTE_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.HOURS) {\n            return HOUR_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.DAYS) {\n            return DAY_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.WEEKS) {\n            return WEEK_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.MONTHS) {\n            return MONTH_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.YEARS) {\n            return YEAR_LENGTH_IN_SECONDS;\n        } else {\n            revert(\"Unknown amortization unit type.\");\n        }\n    }\n\n    function _unpackParamsForAgreementID(\n        LoanTypes loanType,\n        bytes32 agreementId\n    )\n    internal\n    view\n    returns (InterestParams memory params)\n    {\n        bytes32 parameters;\n        uint issuanceBlockTimestamp = 0;\n        address principalTokenAddress;\n        if (loanType == LoanTypes.WAREHOUSE_RECEIPT) {\n/*\n            CommodityDebtRegistry commodityDebtRegistry = CommodityDebtRegistry(contractRegistry.get(COMMODITY_DEBT_REGISTRY));\n            parameters = commodityDebtRegistry.getTermsContractParameters(agreementId);\n            issuanceBlockTimestamp = commodityDebtRegistry.getIssuanceBlockTimestamp(agreementId);\n*/\n        } else if (loanType == LoanTypes.INVENTORY_FINANCE) {\n            InventoryLoanRegistry inventoryLoanDebtRegistry = registry.getInventoryLoanRegistry();\n            parameters = inventoryLoanDebtRegistry.getTermsContractParameters(agreementId);\n            issuanceBlockTimestamp = inventoryLoanDebtRegistry.getIssuanceBlockTimestamp(agreementId);\n            principalTokenAddress = inventoryLoanDebtRegistry.getAgreement(agreementId).principalTokenAddress;\n        } else {\n/*\n            InvoiceDebtRegistry invoiceDebtRegistry = InvoiceDebtRegistry(contractRegistry.get(INVOICE_DEBT_REGISTRY));\n            issuanceBlockTimestamp = invoiceDebtRegistry.getIssuanceBlockTimestamp(agreementId);\n            parameters = invoiceDebtRegistry.getTermsContractParameters(agreementId);\n*/\n        }\n\n        // The principal amount denominated in the aforementioned token.\n        uint256 principalAmount = parameters.unpackPrincipalAmount();\n        uint256 interestRate = parameters.unpackInterestRate();\n        // The amortization unit in which the repayments installments schedule is defined.\n        uint256 rawAmortizationUnitType= parameters.unpackAmortizationUnitType();\n        // The debt's entire term's length, denominated in the aforementioned amortization units\n        uint256 termLengthInAmortizationUnits= parameters.unpackTermLengthInAmortizationUnits();\n        uint256 gracePeriodInDays= parameters.unpackGracePeriodInDays();\n\n        // Ensure that the encoded principal token address is valid\n        require(principalTokenAddress != address(0), \"Invalid principal token address.\");\n\n        // Before we cast to `AmortizationUnitType`, ensure that the raw value being stored is valid.\n        require(\n            rawAmortizationUnitType <= uint(AmortizationUnitType.YEARS),\n            \"Amortization Unit Type is invalid.\"\n        );\n\n        AmortizationUnitType amortizationUnitType = AmortizationUnitType(rawAmortizationUnitType);\n\n        // Calculate term length base on Amortization Unit and number\n        uint termLengthInSeconds = termLengthInAmortizationUnits.mul(\n            _getAmortizationUnitLengthInSeconds(amortizationUnitType)\n        );\n\n        return InterestParams({\n            principalAmount: principalAmount,\n            interestRate: interestRate,\n            termStartUnixTimestamp: issuanceBlockTimestamp,\n            termEndUnixTimestamp: termLengthInSeconds.add(issuanceBlockTimestamp),\n            amortizationUnitType: amortizationUnitType,\n            termLengthInAmortizationUnits: termLengthInAmortizationUnits\n        });\n    }\n\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    function registerRepayment(\n        bytes32 agreementId,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public onlyRouter(LoanTypes.INVENTORY_FINANCE) returns (uint256 remains) {\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n        require(\n            tokenAddress == debtRegistry.getAgreement(agreementId).principalTokenAddress,\n            'LoanTermsContract: Invalid token for repayment.'\n        );\n\n        // solium-disable-next-line\n        uint256 currentTimestamp = block.timestamp;\n\n        uint256 expectedPrincipal;\n        uint256 expectedInterest;\n        // query total outstanding amounts\n        (expectedPrincipal, expectedInterest) = getExpectedRepaymentValues(\n            agreementId,\n            currentTimestamp\n        );\n        // TODO: Currently only allow Debtor to repay with amount >= expectedInterest of that time\n        // Because, we haven't made any mechanism to manage outstanding interest amounts in the case when Debtor\n        // repaid with amount < expectedInterest (at that moment)\n        require(\n            unitsOfRepayment >= expectedInterest,\n            'LoanTermsContract: Expected interest amount is minimum.'\n        );\n\n        // exceed expectation, Debtor can pay all at once\n        if (unitsOfRepayment >= expectedPrincipal.add(expectedInterest)) {\n            debtRegistry.setCompletedRepayment(agreementId);\n            debtRegistry.addRepaidInterestAmount(agreementId, expectedInterest);\n            debtRegistry.addRepaidPrincipalAmount(\n                agreementId,\n                expectedPrincipal\n            );\n            // put the remain to interest\n            remains = unitsOfRepayment.sub(\n                expectedPrincipal.add(expectedInterest)\n            );\n        } else {\n            // if currently Debtor no need to repay for interest\n            if (expectedInterest == 0) {\n                if (unitsOfRepayment >= expectedPrincipal) {\n                    debtRegistry.addRepaidPrincipalAmount(\n                        agreementId,\n                        expectedPrincipal\n                    );\n                    // with the remains\n                    if (unitsOfRepayment.sub(expectedPrincipal) > 0) {\n                        debtRegistry.addRepaidInterestAmount(\n                            agreementId,\n                            unitsOfRepayment.sub(expectedPrincipal)\n                        );\n                    }\n                } else {\n                    debtRegistry.addRepaidPrincipalAmount(\n                        agreementId,\n                        unitsOfRepayment\n                    );\n                }\n            } else {\n                // if expectedInterest > 0 ( & unitsOfRepayment >= expectedInterest)\n                debtRegistry.addRepaidInterestAmount(\n                    agreementId,\n                    expectedInterest\n                );\n                if (unitsOfRepayment.sub(expectedInterest) > 0) {\n                    // Debtor is not able to fulfill the expectedPrincipal as we already validated from first IF statement\n                    // -> there is no remains for adding to repaidInterestAmount\n                    debtRegistry.addRepaidPrincipalAmount(\n                        agreementId,\n                        unitsOfRepayment.sub(expectedInterest)\n                    );\n                }\n            }\n        }\n\n        // Update Debt registry record\n        debtRegistry.updateLastRepaymentTimestamp(\n            agreementId,\n            currentTimestamp\n        );\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n\n        return remains;\n    }\n    function _validateNewInventoryCollateralParamsSecureLoan(\n        bytes16 _oldCollateralParams,\n        bytes16 _newCollateralParams,\n        uint _additionAmount\n    ) internal pure returns (bool) {\n        bool isCollateralTokenIdCorrect = _oldCollateralParams.unpackCollateralTokenId()\n        == _newCollateralParams.unpackCollateralTokenId();\n\n        bool isValidAmount = _newCollateralParams.unpackCollateralAmount()\n        .sub(_oldCollateralParams.unpackCollateralAmount()) == _additionAmount;\n\n        return (\n            isCollateralTokenIdCorrect &&\n            isValidAmount\n        );\n\n    }\n\n    /**\n        * Function will be called by Debt Kernel, supports Debtor to deposit more collateral\n        */\n    function registerSecureLoanWithCollateral(\n        bytes32 agreementId,\n        address debtor,\n        uint256 additionAmount,\n        address collateral,\n        bytes16 collateralInfoParameters\n    ) public {\n        // query current terms contract parameters\n        bytes16 currentTermsParameters;\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n\n        (, , currentTermsParameters) = debtRegistry.getTerms(agreementId);\n\n        // validate new paramters, compare the amounts\n        require(\n            _validateNewInventoryCollateralParamsSecureLoan(\n                currentTermsParameters,\n                collateralInfoParameters,\n                additionAmount\n            ),\n            'Terms Contract: Invalid collateral information parameters.'\n        );\n\n        // Sezie collateral tokens with addition amount\n        registry.getInventoryCollateralizer()\n            .additionInventoryCollateralize(\n                agreementId,\n                debtor,\n                additionAmount,\n                collateral\n            );\n\n        // update terms contract parameters, then re evaluate CR\n        debtRegistry.updateCollateralInfoParameters(\n            agreementId,\n            collateralInfoParameters\n        );\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n    }\n\n    /**\n    * Function will be called by Debt Kernel, supports Debtor to deposit more collateral\n    */\n    function registerInsecureLoanByWithdrawCollateral(\n        bytes32 agreementId,\n        address debtor,\n        uint256 withdrawAmount,\n        address collateral,\n        bytes16 collateralInfoParameters\n    ) public {\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n        address debtorOfAgreement = debtRegistry.getDebtor(agreementId);\n        require(debtor == debtorOfAgreement, 'Invalid debtor of agreement');\n\n        uint256 newCollateralAmount = _validateNewCollateralAmount(\n            agreementId,\n            collateralInfoParameters,\n            withdrawAmount,\n            debtRegistry\n        );\n        // Calculate CR after sell collateral by invoice\n        require(\n            _validateNewCollateralRatioWithInvoice(\n                0,\n                agreementId,\n                newCollateralAmount,\n                debtRegistry\n            ),\n            'InventoryInterest: Invalid collateral ratio, bellow min collateral ratio'\n        );\n\n        // Sezie collateral tokens with addition amount\n        registry.getInventoryCollateralizer()\n            .withdrawInventoryCollateralize(\n            agreementId,\n            debtor,\n            withdrawAmount,\n            collateral\n        );\n\n        // update terms contract parameters, then re evaluate CR\n        debtRegistry.updateCollateralInfoParameters(\n            agreementId,\n            collateralInfoParameters\n        );\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n    }\n\n    /**\n    * Function will be called by Debt Kernel, supports Debtor to sell collateral\n    */\n    function registerSellCollateral(\n        bytes32 agreementId,\n        uint256 amountCollateral,\n        uint256 price,\n        uint256 fiatTokenIndex,\n        address collateral,\n        bytes16 collateralInfoParameters\n    ) public {\n        // TODO tanlm Temporary. Fix this\n        address fiatTokenAddress = address(0);\n        require(\n            fiatTokenAddress != address(0),\n            'Token address must different with NULL.'\n        );\n        require(amountCollateral > 0, 'Amount must greater than 0.');\n        require(price > 0, 'Price must greater than 0.');\n\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n\n        uint256 _amount = _computePriceValue(amountCollateral, price);\n        _validateNewCollateralAmount(\n            agreementId,\n            collateralInfoParameters,\n            amountCollateral,\n            debtRegistry\n        );\n\n        bytes32 sellId = _getSellCollateralId(\n            agreementId,\n            _amount,\n            fiatTokenIndex\n        );\n        debtRegistry.setWaitingSellCollateral(\n            agreementId,\n            sellId,\n            _amount,\n            fiatTokenIndex\n        );\n\n        //Burn collateral\n        _burnCollateralAndUpdateInfo(\n            agreementId,\n            amountCollateral,\n            collateral,\n            collateralInfoParameters,\n            debtRegistry\n        );\n    }\n\n    /**\n    * Function will be called by Debt Kernel, supports Buyer to pay for collateral by fiat\n    */\n    function registerPayCollateralByFiat(\n        bytes32 agreementId,\n        bytes32 sellCollateralId,\n        address payer\n    ) public {\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n        require(\n            debtRegistry.isWaitingSellCollateralExisted(\n                agreementId,\n                sellCollateralId\n            ),\n            'InventoryInterestTermsContract: Sell info not existed'\n        );\n        (uint256 _amount, uint256 fiatTokenIndex) = debtRegistry\n            .getWaitingSellCollateral(agreementId, sellCollateralId);\n\n        // TODO tanlm: temporary. Fix this\n        address fiatTokenAddress = address(0);\n        require(\n            fiatTokenAddress != address(0),\n            'Token address must different with NULL.'\n        );\n\n        if (debtRegistry.liquidatedLoan(agreementId)) {\n            // Repay fully to loan\n            registry.getInventoryLoanRepaymentRouter()\n                ._doRepay(agreementId, payer, _amount, fiatTokenAddress);\n            _amount = 0;\n\n        } else {\n            (, uint256 collateralAmount) = debtRegistry\n                .getCollateralInfoParameters(agreementId);\n            uint256 currentInvoiceAmount = debtRegistry._getTotalInvoiceAmount(\n                agreementId\n            );\n            uint256 minCollateralRatio = debtRegistry.getMinCollateralRatio(\n                agreementId\n            );\n            // Calculate CR after sell collateral. If CR bellow min CR, must repay for the loan to make it equal min CR\n            _amount = _repayLoanIfNeed(\n                _amount,\n                agreementId,\n                collateralAmount,\n                currentInvoiceAmount,\n                [payer, fiatTokenAddress],\n                minCollateralRatio\n            );\n        }\n\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n\n        //Transfer fiat from payer to trader\n        if (_amount > 0) {\n            address debtor = debtRegistry.getDebtor(agreementId);\n            require(\n                    IERC20(fiatTokenAddress)\n                    .transferFrom(payer, debtor, _amount),\n                'Unsuccessfully transferred remains amount to Debtor.'\n            );\n        }\n    }\n\n    /**\n    * Function will be called by Debt Kernel, supports Buyer to pay for collateral by invoice\n    */\n    function registerPayCollateralByInvoice(\n        bytes32 agreementId,\n        bytes32 sellCollateralId,\n        address payer,\n        uint256 dueDate,\n        uint256 salt\n    ) public returns (uint256) {\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n        require(\n            debtRegistry.isWaitingSellCollateralExisted(\n                agreementId,\n                sellCollateralId\n            ),\n            'InventoryInterestTermsContract: Sell info not existed'\n        );\n        (uint256 _amount, uint256 fiatTokenIndex) = debtRegistry\n            .getWaitingSellCollateral(agreementId, sellCollateralId);\n\n        //Create AIT to trader and financed to inventory loan\n        uint256 invoiceTokenId = _createAITFinanced(\n            agreementId,\n            payer,\n            _amount,\n            fiatTokenIndex,\n            dueDate,\n            salt,\n            debtRegistry\n        );\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n\n        return invoiceTokenId;\n    }\n\n    /**\n    Calculate CR after invoice payment and repay to loan if CR bellow min CR\n    */\n    function registerPayFromInvoice(\n        bytes32 agreementId,\n        uint256 invoiceId,\n        address fiatTokenAddress,\n        address payer\n    ) public returns (uint256 remainAmount) {\n        uint256 invoiceAmount = registry.getAcceptedInvoiceToken()\n            .getFiatAmount(invoiceId);\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n\n        uint256 currentInvoiceAmount = debtRegistry._getTotalInvoiceAmount(\n            agreementId\n        );\n\n        // query current terms contract parameters\n        bytes16 currentCollateralInfoParameters;\n        (, , currentCollateralInfoParameters) = debtRegistry.getTerms(\n            agreementId\n        );\n\n        uint256 currentCollateralAmount = currentCollateralInfoParameters.unpackCollateralAmount();\n\n        if (debtRegistry.liquidatedLoan(agreementId)) {\n            // Repay fully to loan\n            registry.getInventoryLoanRepaymentRouter()\n                ._doRepay(agreementId, payer, invoiceAmount, fiatTokenAddress);\n            remainAmount = 0;\n\n        } else {\n            uint256 minCollateralRatio = debtRegistry.getMinCollateralRatio(\n                agreementId\n            );\n            // Calculate CR after pay invoice. If CR bellow min CR, must repay for the loan to make it equal min CR\n            remainAmount = _repayLoanIfNeed(\n                invoiceAmount,\n                agreementId,\n                currentCollateralAmount,\n                currentInvoiceAmount - invoiceAmount,\n                [payer, fiatTokenAddress],\n                minCollateralRatio\n            );\n        }\n\n        //Remove invoice relate to loan\n        debtRegistry.removeInvoiceId(agreementId, invoiceId);\n    }\n\n    function _validateNewInventoryTermsContractParamsDrawdown(\n        bytes32 _oldTermsContractParameters,\n        bytes32 _newTermsContractParameters,\n        uint _drawdownAmount\n    ) internal pure returns (bool) {\n        bool isValidPrincipalAmount = _newTermsContractParameters.unpackPrincipalAmount()\n        .sub(_oldTermsContractParameters.unpackPrincipalAmount()) == _drawdownAmount;\n\n        bool isInterestRateCorrect = _oldTermsContractParameters.unpackInterestRate()\n        == _newTermsContractParameters.unpackInterestRate();\n\n        bool isAmortizationUnitTypeCorrect = _oldTermsContractParameters.unpackAmortizationUnitType()\n        == _newTermsContractParameters.unpackAmortizationUnitType();\n\n        bool isTermLengthInAmortizationUnitsCorrect = _oldTermsContractParameters.unpackTermLengthInAmortizationUnits()\n        == _newTermsContractParameters.unpackTermLengthInAmortizationUnits();\n\n        bool isGracePeriodInDaysCorrect = _oldTermsContractParameters.unpackGracePeriodInDays()\n        == _newTermsContractParameters.unpackGracePeriodInDays();\n\n        return (\n            isValidPrincipalAmount &&\n            isInterestRateCorrect &&\n            isAmortizationUnitTypeCorrect &&\n            isTermLengthInAmortizationUnitsCorrect &&\n            isGracePeriodInDaysCorrect\n        );\n\n    }\n\n    /**\n    * Function will be called by Debt Kernel, supports Debtor to deposit more collateral\n    */\n    function registerDrawdownLoan(\n        bytes32 agreementId,\n        uint256 drawdownAmount,\n        bytes32 termsContractParameters\n    ) public {\n        // query current terms contract parameters\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n        require(\n            drawdownAmount > 0,\n            'Inventory Terms Contract: Drawdown amount must greater than 0.'\n        );\n\n        (, bytes32 currentTermsParameters, ) = debtRegistry.getTerms(\n            agreementId\n        );\n        // validate new paramters, compare the amounts\n        require(\n            _validateNewInventoryTermsContractParamsDrawdown(\n                currentTermsParameters,\n                termsContractParameters,\n                drawdownAmount\n            ),\n            'Inventory Terms Contract: Invalid terms contract parameters.'\n        );\n        require(\n            _validateNewCollateralRatioWhenDrawdown(\n                agreementId,\n                drawdownAmount,\n                debtRegistry\n            ),\n            'InventoryInterest: Invalid collateral ratio, bellow min collateral ratio'\n        );\n\n        // update terms contract parameters, then re evaluate CR\n        debtRegistry.updateLoanTermParameters(\n            agreementId,\n            termsContractParameters\n        );\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n\n    }\n\n    function _validateNewInventoryCollateralParamsSellCollateral(\n        bytes16 _oldCollateralParams,\n        bytes16 _newCollateralParams,\n        uint _sellAmount\n    ) internal pure returns (bool) {\n        bool isCollateralTokenIdCorrect = _oldCollateralParams & 0xffffffff000000000000000000000000\n        == _newCollateralParams & 0xffffffff000000000000000000000000;\n\n        bool isValidAmount = uint256(uint128(_oldCollateralParams) & 0x00000000ffffffffffffffffffffffff)\n        .sub(uint256(uint128(_newCollateralParams) & 0x00000000ffffffffffffffffffffffff)) == _sellAmount;\n\n        return (\n        isCollateralTokenIdCorrect &&\n        isValidAmount\n        );\n\n    }\n\n    // helper for sellCollateral\n    function _validateNewCollateralAmount(\n        bytes32 agreementId,\n        bytes16 collateralInfoParameters,\n        uint256 amountCollateral,\n        InventoryLoanRegistry debtRegistry\n    ) private view returns (uint256 newCollateralAmount) {\n        // query current terms contract parameters\n        bytes16 currentCollateralInfoParameters;\n        (, , currentCollateralInfoParameters) = debtRegistry.getTerms(\n            agreementId\n        );\n\n        // validate new paramters, compare the amounts\n        require(\n            _validateNewInventoryCollateralParamsSellCollateral(\n                currentCollateralInfoParameters,\n                collateralInfoParameters,\n                amountCollateral\n            ),\n            'Inventory Terms Contract: Invalid collateral information parameters.'\n        );\n\n        newCollateralAmount = collateralInfoParameters.unpackCollateralAmount();\n    }\n\n    /**\n    *\n    */\n    function registerForeclosureLoan(bytes32 agreementId)\n        public\n    {\n        InventoryLoanRegistry inventoryLoanDebtRegistry = registry.getInventoryLoanRegistry();\n        require(\n            !inventoryLoanDebtRegistry.completedLoans(agreementId),\n            'InventoryInterestTermsContract: Unable to foreclosure loan when Loan terms is fulfilled.'\n        );\n        require(\n            inventoryLoanDebtRegistry.isExpiredOrReadyForLiquidation(\n                agreementId\n            ),\n            'InventoryInterestTermsContract: Still not meet the requirements to foreclosure.'\n        );\n\n        inventoryLoanDebtRegistry.setLoanLiquidated(agreementId);\n    }\n\n    function _validateNewCollateralRatioWithInvoice(\n        uint256 _amountSold,\n        bytes32 agreementId,\n        uint256 newCollateralAmount,\n        InventoryLoanRegistry inventoryLoanDebtRegistry\n    ) private view returns (bool) {\n        uint256 currentInvoiceAmount = inventoryLoanDebtRegistry\n            ._getTotalInvoiceAmount(agreementId);\n        (uint256 cr, , ) = _computeExpectedCR(\n            agreementId,\n            newCollateralAmount,\n            currentInvoiceAmount + _amountSold,\n            0\n        );\n        uint256 minCollateralRatio = inventoryLoanDebtRegistry\n            .getMinCollateralRatio(agreementId);\n\n        if (cr < minCollateralRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function _validateNewCollateralRatioWhenDrawdown(\n        bytes32 agreementId,\n        uint256 _amountDrawdown,\n        InventoryLoanRegistry inventoryLoanDebtRegistry\n    ) private view returns (bool) {\n        uint256 currentInvoiceAmount = inventoryLoanDebtRegistry\n            ._getTotalInvoiceAmount(agreementId);\n        (, uint256 collateralAmount) = inventoryLoanDebtRegistry\n            .getCollateralInfoParameters(agreementId);\n\n        (uint256 cr, , ) = _computeExpectedCR(\n            agreementId,\n            collateralAmount,\n            currentInvoiceAmount,\n            _amountDrawdown\n        );\n        uint256 minCollateralRatio = inventoryLoanDebtRegistry\n            .getMinCollateralRatio(agreementId);\n\n        if (cr < minCollateralRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // Calculate CR after sell collateral. If CR bellow min CR, must repay for the loan to make it equal min CR\n    function _repayLoanIfNeed(\n        uint256 _amountSold,\n        bytes32 agreementId,\n        uint256 newCollateralAmount,\n        uint256 invoiceValue,\n        address[2] memory payerInfo, //1-payer, 2-fiatTokenAddress\n        uint256 minCollateralRatio\n    ) private returns (uint256) {\n        (uint256 cr, uint256 lastPrice, uint256 totalRemain) = _computeExpectedCR(\n            agreementId,\n            newCollateralAmount,\n            invoiceValue,\n            0\n        );\n\n        if (cr < minCollateralRatio) {\n            // repay loan until CR = min CR\n            uint256 principalValueToSatisfyMinCR = _computePrincipalValueRequire(\n                newCollateralAmount,\n                lastPrice,\n                invoiceValue,\n                minCollateralRatio\n            );\n            uint256 repayValueToSatisfyMinCR;\n\n            if (principalValueToSatisfyMinCR == 0) {\n                repayValueToSatisfyMinCR = totalRemain;\n            } else {\n                repayValueToSatisfyMinCR =\n                    totalRemain -\n                    principalValueToSatisfyMinCR;\n            }\n\n            if (repayValueToSatisfyMinCR > _amountSold) {\n                registry.getInventoryLoanRepaymentRouter()\n                    ._doRepay(\n                    agreementId,\n                    payerInfo[0],\n                    _amountSold,\n                    payerInfo[1]\n                );\n                _amountSold = 0;\n\n            } else {\n                registry.getInventoryLoanRepaymentRouter()\n                    ._doRepay(\n                    agreementId,\n                    payerInfo[0],\n                    repayValueToSatisfyMinCR,\n                    payerInfo[1]\n                );\n                _amountSold = _amountSold.sub(repayValueToSatisfyMinCR);\n            }\n        }\n\n        return _amountSold;\n    }\n\n    // Calculate CR after sell collateral\n    function _computeExpectedCR(\n        bytes32 agreementId,\n        uint256 newCollateralAmount,\n        uint256 invoiceAmount,\n        uint256 drawdownAmount\n    )\n        private\n        view\n        returns (uint256 cr, uint256 lastPrice, uint256 totalRemain)\n    {\n        lastPrice = registry.getInventoryLoanRegistry()\n            .getCollateralLastPrice(agreementId);\n\n        uint256 currentTimestamp = block.timestamp;\n        totalRemain = getTotalExpectedRepaymentValue(\n            agreementId,\n            currentTimestamp\n        );\n\n        cr = _computeCR(\n            newCollateralAmount,\n            lastPrice,\n            invoiceAmount,\n            totalRemain + drawdownAmount\n        );\n    }\n\n    function _burnCollateralAndUpdateInfo(\n        bytes32 agreementId,\n        uint256 amountCollateral,\n        address collateral,\n        bytes16 collateralInfoParameters,\n        InventoryLoanRegistry debtRegistry\n    ) private {\n        registry.getInventoryCollateralizer()\n            .burnInventoryCollateralize(\n            agreementId,\n            amountCollateral,\n            collateral\n        );\n\n        // update terms contract parameters, then re evaluate CR\n        debtRegistry.updateCollateralInfoParameters(\n            agreementId,\n            collateralInfoParameters\n        );\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n    }\n\n    function _createAITFinanced(\n        bytes32 agreementId,\n        address payer,\n        uint256 _amount,\n        uint256 fiatTokenIndex,\n        uint256 dueDate,\n        uint256 salt,\n        InventoryLoanRegistry debtRegistry\n    ) private returns (uint256 invoiceTokenId) {\n        AcceptedInvoiceToken ait = registry.getAcceptedInvoiceToken();\n\n        // TODO tanlm Temporary disable\n//        invoiceTokenId = ait.mint(\n//            [payer, address(registry.getInventoryCollateralizer())],\n//            _amount,\n//            fiatTokenIndex,\n//            dueDate,\n//            false,\n//            salt\n//        );\n//        invoiceTokenId = 0;\n/*\n        ait.beginInventoryFinancing(invoiceTokenId, agreementId);\n        ait.modifyBeneficiary(\n            invoiceTokenId,\n            debtRegistry.getDebtor(agreementId)\n        );\n*/\n        debtRegistry.insertInvoiceFinancedToInventoryLoan(\n            agreementId,\n            invoiceTokenId\n        );\n    }\n\n    /**\n     * Helper function for computing the hash of a given issuance,\n     * and, in turn, its agreementId\n     */\n    function _getSellCollateralId(\n        bytes32 agreementId,\n        uint256 amountPayment,\n        uint256 fiatTokenIndex\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(agreementId, amountPayment, fiatTokenIndex)\n            );\n    }\n\n    /**\n    *\n    */\n    function getTermEndTimestamp(bytes32 _agreementId)\n        public\n        view\n        returns (uint256)\n    {\n        InterestParams memory params = _unpackParamsForAgreementID(\n            LoanTypes.INVENTORY_FINANCE,\n            _agreementId\n        );\n        return params.termEndUnixTimestamp;\n    }\n\n    /**\n    * Term will be completed if participants met all of conditions\n    */\n    function registerConcludeTerm(bytes32 agreementId) public {\n        // validate repayment status\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n        require(\n            debtRegistry.completedRepayment(agreementId),\n            'Debtor has not completed repayment yet.'\n        );\n        registry.getInventoryCollateralizer()\n            .returnInventoryCollateral(agreementId);\n        if (debtRegistry.liquidatedLoan(agreementId)) {\n            debtRegistry.removeLiquidatedLoan(agreementId);\n        }\n\n        debtRegistry.setCompletedLoan(agreementId);\n    }\n\n    /**\n    * Expected repayment value with Amortization of Interest and Principal\n    * (AMORTIZATION) - will be used for repayment from Debtor\n    */\n    function getExpectedRepaymentValues(bytes32 agreementId, uint256 timestamp)\n        public\n        view\n        returns (uint256 expectedPrincipal, uint256 expectedInterest)\n    {\n        InterestParams memory params = _unpackParamsForAgreementID(\n            LoanTypes.INVENTORY_FINANCE,\n            agreementId\n        );\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n\n        uint256 repaidPrincipalAmount = debtRegistry.getRepaidPrincipalAmount(\n            agreementId\n        );\n        uint256 repaidInterestAmount = debtRegistry.getRepaidInterestAmount(\n            agreementId\n        );\n        uint256 lastRepaymentTimestamp = debtRegistry.getLastRepaymentTimestamp(\n            agreementId\n        );\n\n        bool isManualInterestLoan = debtRegistry.manualInterestLoan(agreementId);\n        uint256 manualInterestAmountLoan;\n        if (isManualInterestLoan) {\n            manualInterestAmountLoan = debtRegistry.getManualInterestAmountLoan(\n                agreementId\n            );\n        }\n\n        (\n            expectedPrincipal,\n            expectedInterest\n        ) = _getExpectedRepaymentValuesToTimestamp(\n            params,\n            lastRepaymentTimestamp,\n            timestamp,\n            repaidPrincipalAmount,\n            repaidInterestAmount,\n            isManualInterestLoan,\n            manualInterestAmountLoan\n        );\n    }\n\n    // Calculate interest amount for a duration with specific Principal amount\n    function _calculateInterestForDuration(\n        uint _principalAmount,\n        uint _interestRate,\n        uint _durationLengthInSec\n    ) internal pure returns (uint) {\n        return _principalAmount.mul(_interestRate).mul(_durationLengthInSec.div(DAY_LENGTH_IN_SECONDS))\n        .div(INTEREST_RATE_SCALING_FACTOR_MULTIPLIER).div(YEAR_LENGTH_IN_DAYS);\n    }\n\n    function getStartDateInTimestamp(uint _timestamp) private pure returns (uint) {\n        uint secondInDay = _timestamp.mod(DAY_LENGTH_IN_SECONDS);\n        return  _timestamp.sub(secondInDay);\n    }\n    // Calculate interest amount Debtor need to pay until current date\n    function _calculateInterestAmountToTimestamp(\n        uint _principalAmount,\n        uint _currentPrincipalAmount,\n        uint _paidInterestAmount,\n        uint _annualInterestRate,\n        uint _startTermTimestamp,\n        uint _endTermTimestamp,\n        uint _lastRepayTimestamp,\n        uint _timestamp\n    ) internal pure returns (uint) {\n        if (_timestamp <= _startTermTimestamp) {\n            return 0;\n        }\n        uint interest = 0;\n\n        uint startOfDayOfLastRepay = getStartDateInTimestamp(_lastRepayTimestamp);\n        uint startOfDayOfTermsStart = getStartDateInTimestamp(_startTermTimestamp);\n        uint startOfDayToCalculateInterest = getStartDateInTimestamp(_timestamp);\n\n        uint elapseTimeFromLastRepay = startOfDayToCalculateInterest.sub(startOfDayOfLastRepay);\n        uint elapseTimeFromStart = startOfDayToCalculateInterest.sub(startOfDayOfTermsStart).add(DAY_LENGTH_IN_SECONDS);\n\n        // If still within the term length\n        if (_timestamp < _endTermTimestamp) {\n            // Have just made new repayment\n            if (elapseTimeFromLastRepay == 0 && _paidInterestAmount > 0) {\n                interest = 0;\n            } else {\n                if (_paidInterestAmount > 0) {\n                    // Has made at least 1 repayment\n                    interest = _calculateInterestForDuration(\n                        _currentPrincipalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromLastRepay\n                    );\n                } else {\n                    // Haven't made any repayment\n                    interest = _calculateInterestForDuration(\n                        _principalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromStart\n                    );\n                }\n            }\n\n        } else if (_timestamp >= _endTermTimestamp) {\n            // If debtor has made at least 1 repayment\n            if (_paidInterestAmount > 0) {\n                interest = _calculateInterestForDuration(\n                    _currentPrincipalAmount,\n                    _annualInterestRate,\n                    elapseTimeFromLastRepay\n                );\n            } else {\n                interest = _calculateInterestForDuration(\n                    _principalAmount,\n                    _annualInterestRate,\n                    elapseTimeFromStart\n                );\n            }\n        } else {\n            interest = 0;\n        }\n        return interest;\n    }\n\n    function _getExpectedRepaymentValuesToTimestamp(\n        InterestParams memory _params,\n        uint _lastRepaymentTimestamp, // timestamp of last repayment from debtor\n        uint _timestamp,\n        uint repaidPrincipalAmount,\n        uint repaidInterestAmount,\n        bool isManualInterestLoan,\n        uint manualInterestAmountLoan\n    ) internal pure returns (uint expectedPrinciapal, uint expectedInterest) {\n        uint outstandingPrincipal = _params.principalAmount.sub(repaidPrincipalAmount);\n\n        expectedPrinciapal = outstandingPrincipal;\n\n        if (isManualInterestLoan) {\n            expectedInterest = manualInterestAmountLoan;\n        } else {\n            expectedInterest = _calculateInterestAmountToTimestamp(\n                _params.principalAmount,\n                outstandingPrincipal,\n                repaidInterestAmount,\n                _params.interestRate,\n                _params.termStartUnixTimestamp,\n                _params.termEndUnixTimestamp,\n                _lastRepaymentTimestamp,\n                _timestamp\n            );\n        }\n    }\n\n    function getTermStartUnixTimestamp(bytes32 _agreementId)\n        public\n        view\n        returns (uint256)\n    {\n        InterestParams memory params = _unpackParamsForAgreementID(\n            LoanTypes.INVENTORY_FINANCE,\n            _agreementId\n        );\n        return params.termStartUnixTimestamp;\n    }\n\n    /**\n    * Get TOTAL expected repayment value at specific timestamp\n    * (NO AMORTIZATION)\n    */\n    function getTotalExpectedRepaymentValue(\n        bytes32 agreementId,\n        uint256 timestamp\n    )\n        public\n        view\n        returns (uint256 expectedRepaymentValue)\n    {\n        uint256 principalAmount;\n        uint256 interestAmount;\n        (principalAmount, interestAmount) = getExpectedRepaymentValues(\n            agreementId,\n            timestamp\n        );\n        expectedRepaymentValue = principalAmount.add(interestAmount);\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/protocol/loan/inventory/InventoryLoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport './InventoryInterestTermsContract.sol';\nimport '../../cma/SupplyChainManagementProgram.sol';\nimport './InventoryLoanRegistry.sol';\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract InventoryLoanKernel is PausableUpgradeable, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using ConfigHelper for Registry;\n\n    Registry registry;\n\n    bytes32 public constant NULL_ISSUANCE_HASH = bytes32(0);\n\n    /* NOTE: Currently, the `view` keyword does not actually enforce the\n    static nature of the method; this will change in the future, but for now, in\n    order to prevent reentrancy we'll need to arbitrarily set an upper bound on\n    the gas limit allotted for certain method calls. */\n    uint16 public constant EXTERNAL_QUERY_GAS_LIMIT = 8000;\n\n    mapping(bytes32 => bool) public issuanceCancelled;\n    mapping(bytes32 => bool) public debtOrderCancelled;\n    mapping(bytes32 => bool) public debtOrderCompleted;\n\n\n    ///////////////////////////\n    // EVENTS\n    ///////////////////////////\n\n    event LogDebtOrderFilled(\n        bytes32 indexed _agreementId,\n        uint256 _principal,\n        address _principalToken,\n        address _relayer\n    );\n\n    event LogIssuanceCancelled(\n        bytes32 indexed _agreementId,\n        address indexed _cancelledBy\n    );\n\n    event LogDebtOrderCancelled(\n        bytes32 indexed _debtOrderHash,\n        address indexed _cancelledBy\n    );\n\n    event LogFeeTransfer(\n        address indexed payer,\n        address token,\n        uint256 amount,\n        address indexed beneficiary\n    );\n\n    struct Issuance {\n        address version;\n        address debtor;\n        address termsContract;\n        bytes32 termsContractParameters;\n        bytes16 collateralInfoParameters;\n        uint256 salt;\n        bytes32 agreementId;\n    }\n\n    struct DebtOrder {\n        Issuance issuance;\n        uint256 principalAmount;\n        address principalToken;\n        uint256 creditorFee;\n        uint256 debtorFee;\n        address relayer;\n        uint256 expirationTimestampInSec;\n        bytes32 debtOrderHash;\n        address priceFeedOperator;\n        uint256 minCollateralRatio;\n        uint256 liquidationRatio;\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n    ////////////////////////\n    // INTERNAL FUNCTIONS //\n    ////////////////////////\n\n    /**\n     * Returns the hash of the debt order.\n     */\n    function _getDebtOrderHash(DebtOrder memory debtOrder)\n        internal\n        view\n        returns (bytes32 _debtorMessageHash)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    address(this),\n                    debtOrder.issuance.agreementId,\n                    debtOrder.principalAmount,\n                    debtOrder.principalToken,\n                    debtOrder.debtorFee,\n                    debtOrder.creditorFee,\n                    debtOrder.relayer,\n                    debtOrder.expirationTimestampInSec\n                )\n            );\n    }\n\n    /**\n     * Helper function that constructs a hashed debt order struct given the raw parameters\n     * of a debt order.\n     */\n    function _getDebtOrder(\n        address[6] memory orderAddresses,\n        uint256[7] memory orderValues,\n        bytes32[1] memory orderBytes32,\n        bytes16[1] memory orderBytes16\n    ) internal view returns (DebtOrder memory _debtOrder) {\n        DebtOrder memory debtOrder = DebtOrder({\n            issuance: _getIssuance(\n                orderAddresses[0],\n                orderAddresses[1],\n                orderAddresses[2],\n                orderValues[0],\n                orderBytes32[0],\n                orderBytes16[0]\n            ),\n            principalToken: orderAddresses[3],\n            relayer: orderAddresses[4],\n            principalAmount: orderValues[1],\n            creditorFee: orderValues[2],\n            debtorFee: orderValues[3],\n            expirationTimestampInSec: orderValues[4],\n            debtOrderHash: bytes32(0),\n            priceFeedOperator: orderAddresses[5],\n            minCollateralRatio: orderValues[5],\n            liquidationRatio: orderValues[6]\n        });\n\n        debtOrder.debtOrderHash = _getDebtOrderHash(debtOrder);\n\n        return debtOrder;\n    }\n\n    /**\n     * Helper function that returns an issuance's hash\n     */\n    function _getAgreementId(\n        address version,\n        address debtor,\n        address termsContract,\n        uint256 salt,\n        bytes32 termsContractParameters\n    ) internal pure returns (bytes32 _agreementId) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    version,\n                    debtor,\n                    termsContract,\n                    termsContractParameters,\n                    salt\n                )\n            );\n    }\n\n    /**\n     * Helper function that constructs a hashed issuance structs from the given\n     * parameters.\n     */\n    function _getIssuance(\n        address _version,\n        address _debtor,\n        address _termsContract,\n        uint256 _salt,\n        bytes32 _termsContractParameters,\n        bytes16 _collateralInfoParameters\n    ) internal pure returns (Issuance memory _issuance) {\n        Issuance memory issuance = Issuance({\n            version: _version,\n            debtor: _debtor,\n            termsContract: _termsContract,\n            salt: _salt,\n            termsContractParameters: _termsContractParameters,\n            collateralInfoParameters: _collateralInfoParameters,\n            agreementId: _getAgreementId(\n                _version,\n                _debtor,\n                _termsContract,\n                _salt,\n                _termsContractParameters\n            )\n        });\n\n        return issuance;\n    }\n\n    /**\n     * Helper function that mints LAT associated with the\n     * given issuance and grants it to the beneficiary (creditor).\n     */\n    function _issueDebtAgreement(\n        address beneficiary,\n        DebtOrder memory debtOrder\n    ) internal returns (bytes32) {\n        uint256[4] memory valueParams = [\n            debtOrder.minCollateralRatio,\n            debtOrder.liquidationRatio,\n            debtOrder.expirationTimestampInSec,\n            debtOrder.issuance.salt\n        ];\n        //\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n        bytes32 entryHash = debtRegistry.insert(\n            debtOrder.issuance.version,\n            beneficiary,\n            debtOrder.issuance.debtor,\n            debtOrder.issuance.termsContract,\n            debtOrder.priceFeedOperator,\n            debtOrder.principalToken,\n            debtOrder.issuance.termsContractParameters,\n            debtOrder.issuance.collateralInfoParameters,\n            valueParams\n        );\n\n        registry.getLoanAssetToken().mint(beneficiary, uint256(entryHash));\n\n        //\n        require(\n            entryHash == debtOrder.issuance.agreementId,\n            \"Newly minted token's Id is different with agreement Id.\"\n        );\n\n        return (debtOrder.issuance.agreementId);\n    }\n\n    function _burnLoanAssetToken(address creditor, bytes32 agreementId)\n        internal\n    {\n        registry.getLoanAssetToken().burn(uint256(agreementId));\n    }\n\n    /**\n     * Helper function for querying an address' balance on a given token.\n     */\n    function _getBalance(address token, address owner)\n        internal\n        view\n        returns (uint256 _balance)\n    {\n        // Limit gas to prevent reentrancy.\n        return IERC20(token).balanceOf(owner);\n    }\n\n    /**\n     * Helper function for querying an address' allowance to the 0x transfer proxy.\n     */\n    function _getAllowance(address token, address owner)\n        internal\n        view\n        returns (uint256 _allowance)\n    {\n        // Limit gas to prevent reentrancy.\n        return IERC20(token).allowance(owner, address(this));\n    }\n\n    /**\n     * Given a hashed message, a signer's address, and a signature, returns\n     * whether the signature is valid.\n     */\n    function _isValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (bool _valid) {\n        return\n            signer ==\n            ecrecover(\n                keccak256(\n                    abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash)\n                ),\n                v,\n                r,\n                s\n            );\n    }\n\n    /**\n     * Helper function transfers a specified amount of tokens between two parties\n     * using the token transfer proxy contract.\n     */\n    function _transferTokensFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool success) {\n        return IERC20(token).transferFrom(from, to, amount);\n    }\n\n    /**\n     * Asserts that debt order meets all validity requirements described in\n     * the Kernel specification document.\n     */\n    function _assertDebtOrderValidityInvariants(DebtOrder memory debtOrder)\n        internal\n        returns (bool _orderIsValid)\n    {\n        // Validate fee amount\n        // uint totalFees = debtOrder.creditorFee.add(debtOrder.debtorFee);\n\n        // Invariant: debtor is given enough principal to cover at least debtorFees\n        if (debtOrder.principalAmount < debtOrder.debtorFee) {\n            return false;\n        }\n\n        // Invariant: debt order must not be expired\n        // solhint-disable-next-line not-rely-on-time\n        if (debtOrder.expirationTimestampInSec < block.timestamp) {\n            return false;\n        }\n\n        // Invariant: debt order's issuance must not have been cancelled\n        if (issuanceCancelled[debtOrder.issuance.agreementId]) {\n            return false;\n        }\n\n        // Invariant: debt order itself must not have been cancelled\n        if (debtOrderCancelled[debtOrder.debtOrderHash]) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Asserts that a debt order meets all consensuality requirements\n     * described in the DebtKernel specification document.\n     */\n    function _assertDebtOrderConsensualityInvariants(\n        DebtOrder memory debtOrder,\n        address creditor,\n        uint8[2] memory signaturesV,\n        bytes32[2] memory signaturesR,\n        bytes32[2] memory signaturesS\n    ) internal returns (bool _orderIsConsensual) {\n        // Invariant: debtor's signature must be valid, unless debtor is submitting order\n        if (msg.sender != debtOrder.issuance.debtor) {\n            if (\n                !_isValidSignature(\n                    debtOrder.issuance.debtor,\n                    debtOrder.debtOrderHash,\n                    signaturesV[0],\n                    signaturesR[0],\n                    signaturesS[0]\n                )\n            ) {\n                return false;\n            }\n        }\n\n        // Invariant: creditor's signature must be valid, unless creditor is submitting order\n        if (msg.sender != creditor) {\n            if (\n                !_isValidSignature(\n                    creditor,\n                    debtOrder.debtOrderHash,\n                    signaturesV[1],\n                    signaturesR[1],\n                    signaturesS[1]\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     */\n    function _assertDebtExisting(bytes32 agreementId)\n        internal\n        view\n        returns (bool)\n    {\n        return registry.getLoanAssetToken().ownerOf(uint256(agreementId)) != address(0);\n    }\n\n    /**\n     */\n    function _assertCompletedRepayment(bytes32 agreementId)\n        internal\n        view\n        returns (bool)\n    {\n        // TODO change to InventoryLoanRegistry\n        return registry.getInventoryLoanRegistry().completedRepayment(agreementId);\n    }\n\n    //Conclude a loan, stop lending/loan terms or allow the loan loss\n    function _concludeLoan(\n        address creditor,\n        bytes32 agreementId,\n        address termContract\n    ) internal {\n        require(creditor != address(0), 'Invalid creditor account.');\n        require(agreementId != bytes32(0), 'Invalid agreement id.');\n        require(termContract != address(0), 'Invalid terms contract.');\n\n        if (\n            !_assertDebtExisting(agreementId) ||\n            !_assertCompletedRepayment(agreementId)\n        ) {\n            revert(\n                'Debt does not exsits or Debtor have not completed repayment.'\n            );\n        }\n\n        InventoryInterestTermsContract(termContract)\n            .registerConcludeTerm(agreementId);\n\n        _burnLoanAssetToken(creditor, agreementId);\n\n        (uint256 collateralId, ) = registry.getInventoryLoanRegistry()\n            .getCollateralInfoParameters(agreementId);\n        registry.getSupplyChainManagementProgram()\n            .removeAgreementFromCommodity(collateralId, agreementId);\n    }\n\n    // Transfer fee to beneficiaries\n    function _transferFeesToBeneficiaries(\n        address payer,\n        address from,\n        address token,\n        address[5] memory beneficiaries,\n        uint256[5] memory amounts\n    ) internal {\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] > 0 && beneficiaries[i] != address(0x0)) {\n                _transferTokensFrom(token, from, beneficiaries[i], amounts[i]);\n                emit LogFeeTransfer(payer, token, amounts[i], beneficiaries[i]);\n            }\n        }\n    }\n\n    function _sumTotalFees(uint256[5] memory amounts)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 totalAmount;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            totalAmount = totalAmount.add(amounts[i]);\n        }\n        return totalAmount;\n    }\n\n    function getSignatureRS()\n        internal\n        pure\n        returns (bytes32[2] memory signatures)\n    {\n        bytes32[2] memory signaturesRS;\n        return signaturesRS;\n    }\n\n    function getSignatureV()\n        internal\n        pure\n        returns (uint8[2] memory signatures)\n    {\n        uint8[2] memory signaturesV;\n        return signaturesV;\n    }\n\n    function _fillDebtOrder(\n        address creditor,\n        address buyer,\n        uint256 principalAmount,\n        address[6] calldata orderAddresses, // 1-repayment router, 2-debtor, 3-termcontract, 4-principalTokenAddress, 5-relayer, 6-priceFeeOperator, 7-creditor\n        uint256[7] calldata orderValues, // 1-salt, 2-principalAmount, 3-creditorFee, 4-debtorFee, 5-expirationTimestampInSec, 6-minCR, 7-liquidationRatio\n        bytes32[1] calldata orderBytes32, // 1-termsContractParameters\n        bytes16[1] calldata orderBytes16, // 1-collateralInfoParameters\n        address[5] calldata debtorFeeBeneficiaries,\n        address[5] calldata creditorFeeBeneficiaries,\n        uint256[5] calldata debtorFeeAmounts,\n        uint256[5] calldata creditorFeeAmounts\n    ) external whenNotPaused returns (bytes32 _agreementId) {\n        address[6] memory _orderAddresses = orderAddresses;\n        _orderAddresses[1] = buyer;\n        uint256[7] memory _orderValues = orderValues;\n        _orderValues[1] = principalAmount;\n\n        return\n            fillDebtOrder(\n                creditor,\n                _orderAddresses,\n                _orderValues,\n                orderBytes32,\n                orderBytes16,\n                getSignatureV(),\n                getSignatureRS(),\n                getSignatureRS(),\n                debtorFeeBeneficiaries,\n                creditorFeeBeneficiaries,\n                debtorFeeAmounts,\n                creditorFeeAmounts\n            );\n    }\n\n    function getAssetHolder(DebtOrder memory debtOrder)\n        internal\n        view\n        returns (address _assetHolder)\n    {\n/*\n        bool isEmbeddedFlow = EReceiptInventoryTradeFactory(\n            contractRegistry.get(E_RECEIPT_INVENTORY_TRADE_FACTORY)\n        )\n            .isExistedTrade(msg.sender);\n        address assetHolder = isEmbeddedFlow\n            ? msg.sender\n            : debtOrder.issuance.debtor;\n*/\n\n        return debtOrder.issuance.debtor;\n    }\n\n    ////////////////////////\n    // EXTERNAL FUNCTIONS //\n    ////////////////////////\n\n    /**\n     * Fills a given debt order if it is valid and consensual.\n     */\n    function fillDebtOrder(\n        address creditor,\n        address[6] memory orderAddresses, // 1-repayment router, 2-debtor, 3-termcontract, 4-principalTokenAddress, 5-relayer, 6-priceFeeOperator\n        uint256[7] memory orderValues, // 1-salt, 2-principalAmount, 3-creditorFee, 4-debtorFee, 5-expirationTimestampInSec, 6-minCR, 7-liquidationRatio\n        bytes32[1] memory orderBytes32, // 1-termsContractParameters\n        bytes16[1] memory orderBytes16, // 1-collateralInfoParameters\n        uint8[2] memory signaturesV, // 1-debtorSignatureV, 2-creditorSignatureV\n        bytes32[2] memory signaturesR, // 1-debtorSignatureR, 2-creditorSignatureR\n        bytes32[2] memory signaturesS, // 1-debtorSignatureS, 2-creditorSignatureS,\n        address[5] memory debtorFeeBeneficiaries,\n        address[5] memory creditorFeeBeneficiaries,\n        uint256[5] memory debtorFeeAmounts,\n        uint256[5] memory creditorFeeAmounts\n    ) public whenNotPaused returns (bytes32 _agreementId) {\n        DebtOrder memory debtOrder = _getDebtOrder(\n            orderAddresses,\n            orderValues,\n            orderBytes32,\n            orderBytes16\n        );\n\n        //_assertDebtOrderConsensualityInvariants\n        if (!_assertDebtOrderValidityInvariants(debtOrder)) {\n            revert('InventoryLoanDebtKernel: Invalid Debt Order');\n        }\n\n        // Mint debt token and finalize debt agreement\n        _issueDebtAgreement(creditor, debtOrder);\n\n        // Register debt agreement's start with terms contract\n        // We permit terms contracts to be undefined (for debt agreements which\n        // may not have terms contracts associated with them), and only\n        // register a term's start if the terms contract address is defined.\n        if (debtOrder.issuance.termsContract != address(0x0)) {\n            require(\n                InventoryInterestTermsContract(debtOrder.issuance.termsContract)\n                    .registerTermStart(\n                    debtOrder.issuance.agreementId,\n                    [debtOrder.issuance.debtor, getAssetHolder(debtOrder)]\n                ),\n                'Register terms start was failed.'\n            );\n        }\n\n        // Transfer principal to debtor\n        if (debtOrder.principalAmount > 0) {\n            require(\n                _transferTokensFrom(\n                    debtOrder.principalToken,\n                    creditor,\n                    getAssetHolder(debtOrder),\n                    debtOrder.principalAmount.sub(\n                        _sumTotalFees(debtorFeeAmounts).add(debtOrder.debtorFee)\n                    )\n                ),\n                'Unable to transfer principal tokens to Debtor.'\n            );\n        }\n\n        // Transfer debtorFee to relayer\n        if (debtOrder.debtorFee > 0) {\n            require(\n                _transferTokensFrom(\n                    debtOrder.principalToken,\n                    creditor, // because creditor is the person who approved Tranfer Proxy to transfer, not Debtor\n                    debtOrder.relayer,\n                    debtOrder.debtorFee\n                ),\n                \"Unable to transfer debtor's fee to Relayer.\"\n            );\n            emit LogFeeTransfer(\n                debtOrder.issuance.debtor,\n                debtOrder.principalToken,\n                debtOrder.debtorFee,\n                debtOrder.relayer\n            );\n        }\n\n        // require(false, 'checkpoint DEBT_KERNEL REGISTER_TERM_START_1');\n\n        // Transfer debtorFee to relayer\n        if (debtOrder.creditorFee > 0) {\n            require(\n                _transferTokensFrom(\n                    debtOrder.principalToken,\n                    creditor,\n                    debtOrder.relayer,\n                    debtOrder.creditorFee\n                ),\n                \"Unable to transfer creditor's fee to Relayer.\"\n            );\n            emit LogFeeTransfer(\n                creditor,\n                debtOrder.principalToken,\n                debtOrder.creditorFee,\n                debtOrder.relayer\n            );\n        }\n\n        _transferFeesToBeneficiaries(\n            creditor,\n            creditor,\n            debtOrder.principalToken,\n            creditorFeeBeneficiaries,\n            creditorFeeAmounts\n        );\n\n        _transferFeesToBeneficiaries(\n            debtOrder.issuance.debtor,\n            creditor, // because deducted directly from principal amount\n            debtOrder.principalToken,\n            debtorFeeBeneficiaries,\n            debtorFeeAmounts\n        );\n\n        (uint256 collateralId, ) = registry.getInventoryLoanRegistry()\n            .getCollateralInfoParameters(debtOrder.issuance.agreementId);\n        registry.getSupplyChainManagementProgram()\n            .insertAgreementToCommodity(\n            collateralId,\n            debtOrder.issuance.agreementId\n        );\n\n        emit LogDebtOrderFilled(\n            debtOrder.issuance.agreementId,\n            debtOrder.principalAmount,\n            debtOrder.principalToken,\n            debtOrder.relayer\n        );\n\n        return debtOrder.issuance.agreementId;\n    }\n\n    /**\n     * Debtor call to complete this Debt whenever he thinks that he completed all repayment\n     */\n    function concludeLoan(\n        address creditor,\n        bytes32 agreementId,\n        address termContract\n    ) public whenNotPaused {\n        _concludeLoan(creditor, agreementId, termContract);\n    }\n\n    /**\n     *\n     */\n    function secureLoanWithCollateral(\n        bytes32 agreementId,\n        address termsContract,\n        address debtor,\n        uint256 amount,\n        address collateral,\n        bytes16 collateralInfoParameters\n    ) public whenNotPaused {\n        InventoryInterestTermsContract(termsContract)\n            .registerSecureLoanWithCollateral(\n            agreementId,\n            debtor,\n            amount,\n            collateral,\n            collateralInfoParameters\n        );\n    }\n\n    /**\n     * Allows a debtor to cancel a debt order before it's been filled\n     * -- preventing any counterparty from filling it in the future.\n     */\n    function cancelDebtOrder(\n        address[6] memory orderAddresses,\n        uint256[7] memory orderValues,\n        bytes32[1] memory orderBytes32,\n        bytes16[1] memory orderBytes16\n    ) public whenNotPaused {\n        DebtOrder memory debtOrder = _getDebtOrder(\n            orderAddresses,\n            orderValues,\n            orderBytes32,\n            orderBytes16\n        );\n\n        require(\n            msg.sender == debtOrder.issuance.debtor,\n            \"Debtor cancelation's requestor must be the Debtor.\"\n        );\n\n        debtOrderCancelled[debtOrder.debtOrderHash] = true;\n\n        emit LogDebtOrderCancelled(debtOrder.debtOrderHash, msg.sender);\n    }\n\n    /**\n     * Allows debtors to prevent a debt issuance in which they're involved from being used in\n     * a future debt order.\n     */\n    function cancelIssuance(\n        address version,\n        address debtor,\n        address termsContract,\n        bytes32 termsContractParameters,\n        bytes16 collateralInfoParameters,\n        uint256 salt\n    ) public whenNotPaused {\n        require(\n            msg.sender == debtor,\n            \"Issuance cancelation's requestor must be the Debtor.\"\n        );\n\n        Issuance memory issuance = _getIssuance(\n            version,\n            debtor,\n            termsContract,\n            salt,\n            termsContractParameters,\n            collateralInfoParameters\n        );\n\n        issuanceCancelled[issuance.agreementId] = true;\n\n        emit LogIssuanceCancelled(issuance.agreementId, msg.sender);\n    }\n\n    function _isParticipantOfProject(\n        uint256 projectId,\n        address trader,\n        address lender,\n        address executor\n    ) private view returns (bool) {\n        SupplyChainManagementProgram supplyChainManagementProgram = registry.getSupplyChainManagementProgram();\n        if (\n            supplyChainManagementProgram.isTrader(projectId, trader) &&\n            supplyChainManagementProgram.isLender(projectId, lender) &&\n            supplyChainManagementProgram.isExecutor(projectId, executor)\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Trader sell cma collateral\n     */\n    function sellCollateral(\n        bytes32 agreementId,\n        uint256 projectId,\n        uint256 amountCollateral,\n        uint256 price,\n        uint256 fiatTokenIndex,\n        address collateral,\n        bytes16 collateralInfoParameters,\n        address[3] memory participantAddresses, // 1-debtor, 2-approval(creditor), 3-executor\n        uint8[3] memory signaturesV, // 1-debtorSignatureV, 2-creditorSignatureV, 3-executorSignatureV\n        bytes32[3] memory signaturesR, // 1-debtorSignatureR, 2-creditorSignatureR, 3-executorSignatureR\n        bytes32[3] memory signaturesS // 1-debtorSignatureS, 2-creditorSignatureS, 3-executorSignatureS\n    ) public whenNotPaused {\n        // TODO: validate participant from project, remove to get rid of versioning\n        //        require(\n        //            _isParticipantOfProject(projectId, participantAddresses[0], participantAddresses[1], participantAddresses[2]),\n        //            \"Participant is not valid in project\"\n        //        );\n\n        //_assertDebtOrderConsensualityInvariants check signature\n\n        registry.getInventoryInterestTermsContract()\n            .registerSellCollateral(\n            agreementId,\n            amountCollateral,\n            price,\n            fiatTokenIndex,\n            collateral,\n            collateralInfoParameters\n        );\n    }\n\n    /**\n     * Buyer pay the cma collateral by fiat\n     */\n    function payCollateralByFiat(\n        bytes32 agreementId,\n        bytes32 sellCollateralId,\n        address payer\n    ) public whenNotPaused {\n        registry.getInventoryInterestTermsContract()\n            .registerPayCollateralByFiat(\n            agreementId,\n            sellCollateralId,\n            payer\n        );\n    }\n\n    /**\n     * Buyer pay the cma collateral by invoice\n     */\n    function payCollateralByInvoice(\n        bytes32 agreementId,\n        bytes32 sellCollateralId,\n        address payer,\n        uint256 dueDate,\n        uint256 salt\n    ) public whenNotPaused returns (uint256) {\n        require(msg.sender == payer, 'InventoryLoanDebtKernel: Invalid payer');\n\n        uint256 aitTokenId = registry.getInventoryInterestTermsContract()\n            .registerPayCollateralByInvoice(\n            agreementId,\n            sellCollateralId,\n            payer,\n            dueDate,\n            salt\n        );\n\n        require(\n            aitTokenId != 0,\n            'Register sell collateral by invoice was failed.'\n        );\n        return aitTokenId;\n    }\n\n    /**\n     * Debtor withdraw collateral when CR is still safe\n     */\n    function insecureLoanByWithdrawCollateral(\n        bytes32 agreementId,\n        address termsContract,\n        uint256 amount,\n        address collateral,\n        bytes16 collateralInfoParameters\n    ) public whenNotPaused {\n        InventoryInterestTermsContract(termsContract)\n            .registerInsecureLoanByWithdrawCollateral(\n            agreementId,\n            msg.sender,\n            amount,\n            collateral,\n            collateralInfoParameters\n        );\n    }\n\n    /**\n     * Creditor foreclosure if loan is expired or meet the liquidation ratio\n     */\n    function foreclosureLoanBySellCollateral(\n        bytes32 agreementId,\n        uint256 projectId,\n        uint256 amountCollateral,\n        uint256 price,\n        uint256 fiatTokenIndex,\n        address collateral,\n        bytes16 collateralInfoParameters,\n        uint8 signaturesV, // executorSignatureV\n        bytes32 signaturesR, // executorSignatureR\n        bytes32 signaturesS // executorSignatureS\n    ) public whenNotPaused {\n        //_assertDebtOrderConsensualityInvariants check signature\n        //        require(\n        //            SupplyChainManagementProgram(contractRegistry.get(SUPPLY_CHAIN_MANAGEMENT_PROGRAM)).isExecutor(projectId, executor),\n        //            \"InventoryLoanDebtKernel: Invalid executor\");\n\n        require(\n            msg.sender ==\n                    registry.getInventoryLoanRegistry()\n                    .getBeneficiary(agreementId),\n            'InventoryLoanDebtKernel: Invalid creditor'\n        );\n\n        registry.getInventoryInterestTermsContract()\n            .registerForeclosureLoan(agreementId);\n\n        registry.getInventoryInterestTermsContract()\n            .registerSellCollateral(\n            agreementId,\n            amountCollateral,\n            price,\n            fiatTokenIndex,\n            collateral,\n            collateralInfoParameters\n        );\n    }\n\n    function drawdownLoan(\n        bytes32 agreementId,\n        uint256 drawdownAmount,\n        bytes32 termsContractParameters,\n        uint8[2] memory signaturesV, // 1-debtorSignatureV, 2-creditorSignatureV\n        bytes32[2] memory signaturesR, // 1-debtorSignatureR, 2-creditorSignatureR\n        bytes32[2] memory signaturesS // 1-debtorSignatureS, 2-creditorSignatureS\n    ) public whenNotPaused {\n        //_assertDebtOrderConsensualityInvariants check signature\n\n        InventoryLoanRegistry inventoryLoanDebtRegistry = registry.getInventoryLoanRegistry();\n        //        require(\n        //            msg.sender == inventoryLoanDebtRegistry.getBeneficiary(agreementId),\n        //            \"InventoryLoanDebtKernel: Invalid creditor\"\n        //        );\n        //        require(\n        //            msg.sender == inventoryLoanDebtRegistry.getDebtor(agreementId),\n        //            \"InventoryLoanDebtKernel: Invalid debtor\"\n        //        );\n        require(\n            inventoryLoanDebtRegistry.doesEntryExist(agreementId),\n            'Agreement not existed'\n        );\n\n        registry.getInventoryInterestTermsContract().registerDrawdownLoan(\n            agreementId,\n            drawdownAmount,\n            termsContractParameters\n        );\n\n        // Transfer drawdown amount to debtor\n        address creditor = inventoryLoanDebtRegistry.getBeneficiary(\n            agreementId\n        );\n        address debtor = inventoryLoanDebtRegistry.getDebtor(agreementId);\n        address fiatTokenAddress = inventoryLoanDebtRegistry.getAgreement(agreementId).principalTokenAddress;\n        require(\n            fiatTokenAddress != address(0),\n            'Token address must different with NULL.'\n        );\n\n        require(\n                IERC20(fiatTokenAddress)\n                .transferFrom(\n                creditor,\n                debtor,\n                drawdownAmount\n            ),\n            'InventoryLoanDebtKernel: Unsuccessfully transferred drawdown amount to Debtor.'\n        );\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/protocol/loan/inventory/InventoryLoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../loan/inventory/InventoryInterestTermsContract.sol\";\nimport \"../../loan/inventory/InventoryLoanKernel.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../../tokens/ERC721/invoice/AcceptedInvoiceToken.sol\";\nimport \"./CRInventoryDecisionEngine.sol\";\nimport \"../../../libraries/Unpack.sol\";\nimport \"../../../libraries/Unpack16.sol\";\n\ncontract InventoryLoanRegistry is\n    UntangledBase,\n    CRInventoryDecisionEngine\n{\n    using SafeMath for uint256;\n    using ConfigHelper for Registry;\n    using Unpack for bytes32;\n    using Unpack16 for bytes16;\n    Registry public registry;\n\n    struct CollateralRatioValues {\n        address priceFeedOperator; // Who responsible to update collateral price\n        uint initCollateralRatio; // Collateral ratio when setup Loan\n        uint lastCollateralRatio;\n        uint minCollateralRatio; // Minimum calculate collateral ratio\n        uint liquidationRatio; // Minimum acceptable collateral ratio\n    }\n\n\n    struct Entry {\n        address version; // address of current repayment router\n        address beneficiary;\n        address debtor;\n        address termsContract;\n        address principalTokenAddress;\n        bytes32 termsContractParameters;\n        bytes16 collateralInfoParameters;\n        uint256 issuanceBlockTimestamp;\n        uint256 lastRepayTimestamp;\n        uint256 expirationTimestamp;\n        CollateralRatioValues collateralRatioValues;\n    }\n    // Primary entries mapping agreement IDs to their corresponding entries\n    mapping(bytes32 => Entry) public entries;\n    // Helper mapping agreement IDs to their corresponding invoice token id\n    mapping(bytes32 => uint256[]) public registryToInvoice;\n    // Maps debtor addresses to a list of their debts' agreement IDs\n    mapping(address => bytes32[]) internal debtorToDebts;\n    // agreement id -> waiting for payment of sell collateral id -> sell info\n    mapping (bytes32 => mapping (bytes32 => SellCollateralInfo)) public waitingSellCollateral;\n    mapping (bytes32 => mapping (bytes32 => bool)) public waitingSellCollateralExisted;\n    // agreement id -> is foreclosure\n    mapping (bytes32 => bool) public liquidatedLoan;\n\n    // List of terms which have completed repayment\n    mapping (bytes32 => bool) public completedRepayment;\n    mapping (bytes32 => uint) public repaidPrincipalAmount;\n    mapping (bytes32 => uint) public repaidInterestAmount;\n\n    mapping (bytes32 => bool) public completedLoans;\n\n    // Setting manual for interest amount\n    mapping (bytes32 => bool) public manualInterestLoan;\n    mapping (bytes32 => uint) internal manualInterestAmountLoan;\n\n    struct SellCollateralInfo {\n        bytes32 agreementId;\n        uint256 amountPayment;\n        uint256 fiatTokenIndex;\n    }\n\n    //////////////////////////////\n    // CONSTANTS               //\n    ////////////////////////////\n    string public constant INSERT_CONTEXT = \"commodity-debt-entries-insert\";\n    string public constant EDIT_CONTEXT = \"commodity-debt-entries-edit\";\n\n    //////////////////////////////\n    // EVENTS                   //\n    //////////////////////////////\n\n    event LogInsertEntry(\n        bytes32 indexed agreementId,\n        address indexed beneficiary,\n        address termsContract,\n        bytes32 termsContractParameters\n    );\n\n    event LogModifyEntryBeneficiary(\n        bytes32 indexed agreementId,\n        address indexed previousBeneficiary,\n        address indexed newBeneficiary\n    );\n\n    event CollateralRatioChanged(\n        bytes32 indexed agreementId,\n        uint256 previousCR,\n        uint256 latestCR\n    );\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n        registry = _registry;\n    }\n\n    //////////////////////////////\n    // MODIFIERS                //\n    //////////////////////////////\n\n    modifier nonNullBeneficiary(address beneficiary) {\n        require(\n            beneficiary != address(0),\n            \"Inventory Debt Registry: Beneficiary must be different with address 0.\"\n        );\n        _;\n    }\n\n    modifier onlyExtantEntry(bytes32 agreementId) {\n        require(\n            doesEntryExist(agreementId),\n            \"Inventory Debt Registry: Agreement Id does not exists.\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedToEdit() {\n        require(\n            _msgSender() == address(registry.getInventoryInterestTermsContract()),\n            \"Inventory Debt Registry: Sender does not have permission to edit.\"\n        );\n        _;\n    }\n\n    modifier onlyPriceFeedOperator(bytes32 agreementId) {\n        require(\n            msg.sender ==\n            entries[agreementId].collateralRatioValues.priceFeedOperator,\n            \"Inventory Debt Registry: Not authorized to update price.\"\n        );\n        _;\n    }\n\n    ////////////////////////////////////////////\n    // INTERNAL FUNCTIONS                    //\n    //////////////////////////////////////////\n    /**\n     * Helper function for computing the hash of a given issuance,\n     * and, in turn, its agreementId\n     */\n    function _getAgreementId(\n        Entry memory _entry,\n        address _debtor,\n        uint256 _salt\n    ) internal pure returns (bytes32) {\n        return\n        keccak256(\n            abi.encodePacked(\n                _entry.version,\n                _debtor,\n                _entry.termsContract,\n                _entry.termsContractParameters,\n                _salt\n            )\n        );\n    }\n\n    function _evaluateCollateralRatio(bytes32 agreementId, uint256 price)\n    internal\n    {\n        uint256 collateralAmount = entries[agreementId].collateralInfoParameters.unpackCollateralAmount();\n\n        uint256 invoiceAmount = _getTotalInvoiceAmount(agreementId);\n\n        uint256 currentTimestamp = block.timestamp;\n        uint256 totalRemain = registry.getInventoryInterestTermsContract().getTotalExpectedRepaymentValue(\n            agreementId,\n            currentTimestamp\n        );\n\n        uint256 cr = _computeCR(collateralAmount, price, invoiceAmount, totalRemain);\n\n        uint256 previousCR = entries[agreementId].collateralRatioValues.lastCollateralRatio;\n\n        if (cr != previousCR) {\n            entries[agreementId]\n                .collateralRatioValues\n                .lastCollateralRatio = cr;\n            emit CollateralRatioChanged(agreementId, previousCR, cr);\n        }\n    }\n\n    ///////////////////////////////////////////\n    // CROSS-CONTRACT & EXTERNAL FUNCTIONS ///\n    /////////////////////////////////////////\n\n    //--------------\n    // SENDs\n    //--------------\n    /**\n     * TODO: Limitation for inserting\n     * Inserts a new entry into the entries, if the entry is valid and sender is\n     * authorized to make 'insert' mutations to the entries.\n     */\n    function insert(\n        address _version,\n        address _beneficiary,\n        address _debtor,\n        address _termsContract,\n        address _priceFeedOperator,\n        address _principalTokenAddress,\n        bytes32 _termsContractParameters,\n        bytes16 _collateralInfoParameters,\n        uint256[4] memory values\n    )\n    public\n    whenNotPaused\n    nonNullBeneficiary(_beneficiary)\n    returns (bytes32)\n    {\n        CollateralRatioValues memory crValues = CollateralRatioValues({\n            priceFeedOperator: _priceFeedOperator,\n            initCollateralRatio: 0,\n            lastCollateralRatio: 0,\n            minCollateralRatio: values[0],\n            liquidationRatio: values[1]\n        });\n\n        Entry memory entry = Entry({\n            version: _version,\n            beneficiary: _beneficiary,\n            debtor: _debtor,\n            termsContract: _termsContract,\n            termsContractParameters: _termsContractParameters,\n            collateralInfoParameters: _collateralInfoParameters,\n            // solium-disable-next-line security\n            issuanceBlockTimestamp: block.timestamp,\n            lastRepayTimestamp: 0,\n            expirationTimestamp: values[2],\n            collateralRatioValues: crValues,\n            principalTokenAddress: _principalTokenAddress\n        });\n        bytes32 agreementId = _getAgreementId(entry, _debtor, values[3]);\n\n        require(\n            entries[agreementId].beneficiary == address(0),\n            \"Beneficiary account already exists.\"\n        );\n\n        entries[agreementId] = entry;\n\n        selfEvaluateCollateralRatio(agreementId);\n        entries[agreementId]\n            .collateralRatioValues\n            .initCollateralRatio = entries[agreementId].collateralRatioValues.lastCollateralRatio;\n\n        debtorToDebts[_debtor].push(agreementId);\n\n        emit LogInsertEntry(\n            agreementId,\n            entry.beneficiary,\n            entry.termsContract,\n            entry.termsContractParameters\n        );\n\n        return agreementId;\n    }\n\n    function insertInvoiceFinancedToInventoryLoan(bytes32 agreementId, uint256 invoiceTokenId) public {\n        registryToInvoice[agreementId].push(invoiceTokenId);\n    }\n\n    /**\n    * Price Feed Operator will call this function to evaluate the CR and update Liquidation satus\n    */\n    function evaluateCollateralRatio(\n        bytes32 agreementId,\n        uint256 price,\n        uint256 _timestamp\n    ) public onlyPriceFeedOperator(agreementId) returns (bool) {\n        require(_verifyPrice(_timestamp), \"Inventory Debt Registry: Invalid price data.\");\n        _evaluateCollateralRatio(agreementId, price);\n        return true;\n    }\n\n    function selfEvaluateCollateralRatio(bytes32 agreementId)\n    public\n    returns (bool)\n    {\n        uint256 lastPrice = getCollateralLastPrice(agreementId);\n        _evaluateCollateralRatio(agreementId, lastPrice);\n        return true;\n    }\n\n    /**\n    * @dev TODO: Security restriction\n    * Restriction: only if terms parameters is validated\n    */\n    function updateLoanTermParameters(\n        bytes32 agreementId,\n        bytes32 newLoanTermsParameters\n    ) public {\n        entries[agreementId].termsContractParameters = newLoanTermsParameters;\n    }\n\n    /**\n    * @dev TODO: Security restriction\n    */\n    function updateCollateralInfoParameters(\n        bytes32 agreementId,\n        bytes16 newCollateralInfoParameters\n    ) public {\n        entries[agreementId].collateralInfoParameters = newCollateralInfoParameters;\n\n        uint256 collateralAmount = newCollateralInfoParameters.unpackCollateralAmount();\n\n        require(\n            collateralAmount >= 0,\n            \"Inventory Debt Registry: Invalid new collateral info parameters.\"\n        );\n    }\n\n    function setMinCollateralRatio(bytes32 agreementId, uint256 minCollateralRatio) public {\n        entries[agreementId].collateralRatioValues.minCollateralRatio = minCollateralRatio;\n    }\n\n    function setLiquidationRatio(bytes32 agreementId, uint256 liquidationRatio) public {\n        entries[agreementId].collateralRatioValues.liquidationRatio = liquidationRatio;\n    }\n\n    /**\n     * Modifies the beneficiary of a debt issuance, if the sender\n     * is authorized to make 'modifyBeneficiary' mutations to\n     * the entries.\n    */\n    function modifyBeneficiary(bytes32 agreementId, address newBeneficiary)\n    public\n    whenNotPaused\n    onlyExtantEntry(agreementId)\n    nonNullBeneficiary(newBeneficiary)\n    {\n        address previousBeneficiary = entries[agreementId].beneficiary;\n        entries[agreementId].beneficiary = newBeneficiary;\n\n        emit LogModifyEntryBeneficiary(\n            agreementId,\n            previousBeneficiary,\n            newBeneficiary\n        );\n    }\n\n\n    // Update timestamp of the last repayment from Debtor\n    function updateLastRepaymentTimestamp(bytes32 agreementId, uint newTimestamp)\n    public\n    onlyAuthorizedToEdit\n    {\n        entries[agreementId].lastRepayTimestamp = newTimestamp;\n    }\n\n    //-----------------\n    // CALLs\n    //-----------------\n\n    /* Ensures an entry with the specified agreement ID exists within the debt entries. */\n    function doesEntryExist(bytes32 agreementId)\n    public\n    view\n    returns (bool)\n    {\n        return entries[agreementId].beneficiary != address(0);\n    }\n\n    /**\n     * Returns the beneficiary of a given issuance\n     */\n    function getBeneficiary(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (address)\n    {\n        // Lender\n        return entries[agreementId].beneficiary;\n    }\n\n    function getDebtor(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (address)\n    {\n        return entries[agreementId].debtor;\n    }\n\n    /**\n     * Returns a tuple of the terms contract and its associated parameters\n     * for a given issuance\n    */\n    function getTerms(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (address, bytes32, bytes16)\n    {\n        return (\n            entries[agreementId].termsContract,\n            entries[agreementId].termsContractParameters,\n            entries[agreementId].collateralInfoParameters\n        );\n    }\n\n    /**\n    * Returns the terms contract address of a given issuance\n    */\n    function getTermsContract(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (address)\n    {\n        return entries[agreementId].termsContract;\n    }\n\n    /**\n     * Returns the terms contract parameters of a given issuance\n     */\n    function getTermsContractParameters(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (bytes32)\n    {\n        return entries[agreementId].termsContractParameters;\n    }\n\n    /**\n     * Returns the timestamp of the block at which a debt agreement was issued.\n     */\n    function getIssuanceBlockTimestamp(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (uint256 timestamp)\n    {\n        return entries[agreementId].issuanceBlockTimestamp;\n    }\n\n    function getLastRepaymentTimestamp(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (uint256 timestamp)\n    {\n        return entries[agreementId].lastRepayTimestamp;\n    }\n\n    function getExpirationTimestamp(bytes32 agreementId)\n    public\n    view\n    onlyExtantEntry(agreementId)\n    returns (uint256)\n    {\n        // solhint-disable-next-line not-rely-on-time\n        return entries[agreementId].expirationTimestamp;\n    }\n\n    /**\n     * Returns the parameters of a debt issuance in the entries.\n     *\n     * TODO: protect this function with our `onlyExtantEntry` modifier once the restriction\n     * on the size of the call stack has been addressed.\n     */\n    function get(bytes32 agreementId)\n    public\n    view\n    returns (address, address, address, bytes32, uint256)\n    {\n        return (\n            entries[agreementId].version,\n            entries[agreementId].beneficiary,\n            entries[agreementId].termsContract,\n            entries[agreementId].termsContractParameters,\n            entries[agreementId].issuanceBlockTimestamp\n        );\n    }\n\n    function getLiquidationRatio(bytes32 agreementId)\n    public\n    view\n    returns (uint256)\n    {\n        return entries[agreementId].collateralRatioValues.liquidationRatio;\n    }\n\n    function getMinCollateralRatio(bytes32 agreementId)\n    public view\n    returns (uint256)\n    {\n        return entries[agreementId].collateralRatioValues.minCollateralRatio;\n    }\n\n    function getCollateralLastPrice(bytes32 agreementId) public view returns (uint256) {\n        uint collateralId = entries[agreementId].collateralInfoParameters.unpackCollateralTokenId();\n        return registry.getSupplyChainManagementProgram().getCommodityPrice(collateralId);\n    }\n\n    function getInitCollateralRatio(bytes32 agreementId)\n    public\n    view\n    returns (uint256)\n    {\n        return entries[agreementId].collateralRatioValues.initCollateralRatio;\n    }\n\n    function isReadyForLiquidation(bytes32 agreementId)\n    public\n    view\n    returns (bool)\n    {\n        return entries[agreementId].collateralRatioValues.liquidationRatio >= entries[agreementId].collateralRatioValues.lastCollateralRatio;\n    }\n\n    function latestCollateralRatio(bytes32 agreementId)\n    public\n    view\n    returns (uint256)\n    {\n        return entries[agreementId].collateralRatioValues.lastCollateralRatio;\n    }\n\n    function getCollateralInfoParameters(bytes32 agreementId)\n    public\n    view\n    returns (uint256 collateralId, uint256 collateralAmount)\n    {\n        collateralId = entries[agreementId].collateralInfoParameters.unpackCollateralTokenId();\n        collateralAmount = entries[agreementId].collateralInfoParameters.unpackCollateralAmount();\n    }\n\n    function getInvoiceIds(bytes32 agreementId) public view returns (uint256[] memory) {\n        return registryToInvoice[agreementId];\n    }\n\n    function removeInvoiceId(bytes32 agreementId, uint256 invoiceId) public {\n        if (registryToInvoice[agreementId].length > 0) {\n            for (uint i = 0; i < registryToInvoice[agreementId].length; ++i) {\n                if (registryToInvoice[agreementId][i] == invoiceId) {\n\n                    // Remove i element from registryToInvoice[agreementId]\n                    for (uint index = i; index<registryToInvoice[agreementId].length-1; index++){\n                        registryToInvoice[agreementId][index] = registryToInvoice[agreementId][index+1];\n                    }\n                    registryToInvoice[agreementId].pop();\n\n                    selfEvaluateCollateralRatio(agreementId);\n                    break;\n                }\n            }\n        }\n    }\n\n    function _getTotalInvoiceAmount(bytes32 agreementId) public view returns (uint256 amount) {\n        AcceptedInvoiceToken acceptedInvoiceToken = registry.getAcceptedInvoiceToken();\n\n        amount = 0;\n        if (registryToInvoice[agreementId].length > 0) {\n            for (uint i = 0; i < registryToInvoice[agreementId].length; ++i) {\n                amount += acceptedInvoiceToken.getFiatAmount(registryToInvoice[agreementId][i]);\n            }\n        }\n    }\n\n    function setWaitingSellCollateral(bytes32 agreementId, bytes32 sellId, uint256 amount, uint256 fiatTokenIndex)\n        public\n    {\n        SellCollateralInfo memory sellCollateralInfo = SellCollateralInfo({\n            agreementId: agreementId,\n            amountPayment: amount,\n            fiatTokenIndex: fiatTokenIndex\n        });\n        waitingSellCollateral[agreementId][sellId] = sellCollateralInfo;\n        waitingSellCollateralExisted[agreementId][sellId] = true;\n    }\n\n    function isWaitingSellCollateralExisted(bytes32 agreementId, bytes32 sellId) public view returns (bool) {\n        return waitingSellCollateralExisted[agreementId][sellId];\n    }\n\n    function getWaitingSellCollateral(bytes32 _agreementId, bytes32 _sellId)\n        public view\n        returns (uint256 amountPayment, uint256 fiatTokenIndex)\n    {\n        SellCollateralInfo memory sellInfo = waitingSellCollateral[_agreementId][_sellId];\n        return (sellInfo.amountPayment, sellInfo.fiatTokenIndex);\n    }\n\n    function setLoanLiquidated(bytes32 agreementId) public {\n        liquidatedLoan[agreementId] = true;\n    }\n\n    function removeLiquidatedLoan(bytes32 agreementId) public {\n        delete liquidatedLoan[agreementId];\n    }\n\n    function isExpiredOrReadyForLiquidation(bytes32 agreementId) public view returns (bool){\n        uint expTimestamp = entries[agreementId].expirationTimestamp;\n        // solium-disable-next-line\n        if (expTimestamp <= block.timestamp) {\n            return true;\n        }\n\n        return isReadyForLiquidation(agreementId);\n    }\n\n    function setCompletedRepayment(bytes32 agreementId) public {\n        completedRepayment[agreementId] = true;\n    }\n\n    function getRepaidPrincipalAmount(bytes32 agreementId) public view returns (uint) {\n        return repaidPrincipalAmount[agreementId];\n    }\n\n    function addRepaidPrincipalAmount(bytes32 agreementId, uint repaidAmount) public {\n        repaidPrincipalAmount[agreementId] = repaidPrincipalAmount[agreementId].add(repaidAmount);\n    }\n\n    function setRepaidPrincipalAmount(bytes32 agreementId, uint repaidAmount) public {\n        repaidPrincipalAmount[agreementId] = repaidAmount;\n    }\n\n    function getRepaidInterestAmount(bytes32 agreementId) public view returns (uint) {\n        return repaidInterestAmount[agreementId];\n    }\n\n    function addRepaidInterestAmount(bytes32 agreementId, uint repaidAmount) public {\n        repaidInterestAmount[agreementId] = repaidInterestAmount[agreementId].add(repaidAmount);\n    }\n\n    function setRepaidInterestAmount(bytes32 agreementId, uint repaidAmount) public {\n        repaidInterestAmount[agreementId] = repaidAmount;\n    }\n\n    function getValueRepaidToDate(bytes32 agreementId) public view returns (uint, uint) {\n        return (\n            repaidPrincipalAmount[agreementId],\n            repaidInterestAmount[agreementId]\n        );\n    }\n\n    function setCompletedLoan(bytes32 agreementId) public {\n        completedLoans[agreementId] = true;\n    }\n\n    function setManualInterestLoan(bytes32 agreementId, bool isManualInterest) public {\n        manualInterestLoan[agreementId] = isManualInterest;\n    }\n\n    function getManualInterestAmountLoan(bytes32 agreementId) public view returns (uint) {\n        return manualInterestAmountLoan[agreementId];\n    }\n\n    function setManualInterestAmountLoan(bytes32 agreementId, uint interestAmount) public {\n        manualInterestAmountLoan[agreementId] = interestAmount;\n    }\n\n    function getAgreement(bytes32 agreementId) public view returns(Entry memory) {\n        return entries[agreementId];\n    }\n}\n"
    },
    "contracts/protocol/loan/inventory/InventoryLoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./InventoryLoanRegistry.sol\";\nimport \"./InventoryInterestTermsContract.sol\";\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport \"../../../libraries/ConfigHelper.sol\";\nimport \"../../../storage/Registry.sol\";\n\n\ncontract InventoryLoanRepaymentRouter is PausableUpgradeable, OwnableUpgradeable {\n    using ConfigHelper for Registry;\n\n    Registry public registry;\n\n    enum Errors {\n        DEBT_AGREEMENT_NONEXISTENT,\n        PAYER_BALANCE_OR_ALLOWANCE_INSUFFICIENT,\n        REPAYMENT_REJECTED_BY_TERMS_CONTRACT\n    }\n\n    event LogRepayment(\n        bytes32 indexed _agreementId,\n        address indexed _payer,\n        address indexed _beneficiary,\n        uint _amount,\n        address _token\n    );\n\n    event LogError(uint8 indexed _errorId, bytes32 indexed _agreementId);\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n    // Validate repayment request parametters\n    function _assertRepaymentRequest(bytes32 _agreementId, address _payer, uint256 _amount, address _tokenAddress)\n    internal\n    {\n        require(_tokenAddress != address(0), \"Token address must different with NULL.\");\n        require(_amount > 0, \"Amount must greater than 0.\");\n\n        // Ensure agreement exists.\n        require(\n            registry.getInventoryLoanRegistry().doesEntryExist(_agreementId),\n            \"Inventory Debt Registry: Agreement Id does not exists.\"\n        );\n    }\n\n\n    function _doRepay(bytes32 _agreementId, address _payer, uint256 _amount, address _tokenAddress)\n    public\n    {\n        // Notify terms contract\n        InventoryLoanRegistry debtRegistry = registry.getInventoryLoanRegistry();\n\n        address termsContract = debtRegistry.getTermsContract(_agreementId);\n        address beneficiary = debtRegistry.getBeneficiary(_agreementId);\n        address debtor = debtRegistry.getDebtor(_agreementId);\n\n        uint remains = InventoryInterestTermsContract(termsContract).registerRepayment(\n            _agreementId,\n            _amount,\n            _tokenAddress\n        );\n\n        // Transfer amount to creditor\n        require(\n            IERC20(_tokenAddress).transferFrom(_payer, beneficiary, _amount - remains),\n            \"Unsuccessfully transferred repayment amount to Creditor.\"\n        );\n\n        // Transfer remain amount to debtor\n        if (debtor != _payer && remains > 0) {\n            require(\n                IERC20(_tokenAddress).transferFrom(_payer, debtor, remains),\n                \"Unsuccessfully transferred repayment amount to Creditor.\"\n            );\n        }\n\n        // Log event for repayment\n        emit LogRepayment(_agreementId, _payer, beneficiary, _amount - remains, _tokenAddress);\n    }\n\n    // Mannual repay by using Fiat tokens\n    function repay(bytes32 agreementId, address payer, uint256 amount, address tokenAddress)\n    public\n    whenNotPaused\n    returns (uint)\n    {\n        _assertRepaymentRequest(agreementId, payer, amount, tokenAddress);\n        _doRepay(agreementId, payer, amount, tokenAddress);\n        return amount;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/protocol/loan/invoice/InvoiceCollateralizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './InvoiceFinanceInterestTermsContract.sol';\nimport './InvoiceFinanceInterestTermsContract.sol';\nimport './InvoiceDebtRegistry.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts/interfaces/IERC721.sol';\n\n/**\n*  Escrow account that hold all callaterals for Loans\n*/\ncontract InvoiceCollateralizer is Initializable, PausableUpgradeable, AccessControlEnumerableUpgradeable, IERC721ReceiverUpgradeable {\n    using SafeMath for uint256;\n    using ConfigHelper for Registry;\n    using Unpack for bytes32;\n\n    Registry public registry;\n\n    bytes32 public constant COLLATERALIZER = keccak256('COLLATERALIZER');\n\n    // Collateralizer here refers to the owner of the asset that is being collateralized.\n    mapping(bytes32 => address) public agreementToCollateralizer;\n\n    ///////////////////////////////\n    // CONSTANTS               ///\n    /////////////////////////////\n    uint256 public constant SECONDS_IN_DAY = 24 * 60 * 60;\n    string public constant CONTEXT = 'InvoiceCollateralizer';\n    string public constant CONTEXT_COLLATERAL_SALE = 'collateral_sale';\n\n    ///////////////////////////////\n    // EVENTS                  ///\n    /////////////////////////////\n    event InvoiceCollateralLocked(\n        bytes32 indexed agreementID,\n        address indexed token,\n        uint256 tokenId\n    );\n\n    event CollateralReturned(\n        bytes32 indexed agreementID,\n        address indexed collateralizer,\n        address token,\n        uint256 amount\n    );\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        registry = _registry;\n    }\n\n    ///////////////////////////////\n    // MODIFIERS               ///\n    /////////////////////////////\n\n    modifier onlyPermissionedInvoiceTermContract(bytes32 agreementId) {\n        require(\n            msg.sender ==\n            registry.getInvoiceDebtRegistry()\n            .getTermsContract(agreementId),\n            'Collateralizer: Sender must be Term Contract of current Debt.'\n        );\n        _;\n    }\n\n    ///////////////////////////////\n    // INTERNAL FUNCTIONS     ////\n    /////////////////////////////\n    // Paramerters from Loan which have collateral is Invoice\n    function retrieveInvoiceCollateralParameters(bytes32 agreementId)\n    internal\n    view\n    returns (\n        address collateralToken,\n        uint256[] memory invoiceTokenIds,\n        uint256 gracePeriodInDays,\n        InvoiceFinanceInterestTermsContract termsContract\n    )\n    {\n        address termsContractAddress;\n        bytes32 termsContractParameters;\n\n        // Pull the terms contract and associated parameters for the agreement\n        InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n        (termsContractAddress, termsContractParameters) = invoiceDebtRegistry\n        .getTerms(agreementId);\n\n        invoiceTokenIds = invoiceDebtRegistry.getInvoiceTokenIds(agreementId);\n\n        gracePeriodInDays = termsContractParameters.unpackGracePeriodInDays();\n\n        // Resolve address of token associated with this agreement in token registry\n        collateralToken = address(registry.getAcceptedInvoiceToken());\n        termsContract = InvoiceFinanceInterestTermsContract(\n            termsContractAddress\n        );\n    }\n\n    ///////////////////////////////\n    // EXTERNAL FUNCTIONS     ///\n    /////////////////////////////\n    function collateralizeERC721(bytes32 agreementId, address collateralizer)\n    public\n    onlyRole(COLLATERALIZER)\n    whenNotPaused\n    returns (bool)\n    {\n        uint256[] memory invoiceTokenIds;\n        address collateralToken;\n        InvoiceFinanceInterestTermsContract termsContract;\n\n        // Fetch all relevant collateralization parameters\n        (\n        collateralToken,\n        invoiceTokenIds,\n        ,\n        termsContract\n        ) = retrieveInvoiceCollateralParameters(agreementId);\n\n        require(\n            address(termsContract) == msg.sender,\n            'Collateralizer: Sender must be Term Contract smart contract.'\n        );\n\n        require(\n            agreementToCollateralizer[agreementId] == address(0),\n            'Collateralizer: This Debt must be not collateralized.'\n        );\n\n        AcceptedInvoiceToken invoiceToken = AcceptedInvoiceToken(\n            collateralToken\n        );\n        address custodian = address(this);\n        // store collaterallizer in mapping, effectively demarcating that the\n        // agreement is now collateralized.\n        agreementToCollateralizer[agreementId] = collateralizer;\n\n        for (uint256 i = 0; i < invoiceTokenIds.length; i++) {\n            /*\n            The collateralizer must have sufficient balance equal to or greater\n            than the amount being put up for collateral.\n            */\n            require(\n                invoiceToken.ownerOf(invoiceTokenIds[i]) == collateralizer,\n                'Invoice Collateralizer: Collateralizer must owner of invoice.'\n            );\n\n            // the collateral must be successfully transferred to this contract, via a proxy.\n            invoiceToken.safeTransferFrom(\n                collateralizer,\n                custodian,\n                invoiceTokenIds[i]\n            );\n\n            // emit event that collateral has been secured.\n            emit InvoiceCollateralLocked(\n                agreementId,\n                address(registry.getAcceptedInvoiceToken()),\n                invoiceTokenIds[i]\n            );\n        }\n\n        return true;\n    }\n\n    /**\n    * Add more collateral to increase CR\n    */\n    function additionERC721Collateralize(\n        bytes32 agreementId,\n        address collateralizer,\n        bytes32 invoiceTokenId,\n        address token\n    )\n    public\n    onlyRole(COLLATERALIZER)\n    whenNotPaused\n    returns (bool _success)\n    {\n        address collateralToken;\n        InvoiceFinanceInterestTermsContract termsContract;\n\n        (\n        collateralToken,\n        ,\n        ,\n        termsContract\n        ) = retrieveInvoiceCollateralParameters(agreementId);\n\n        require(\n            address(termsContract) == msg.sender,\n            'Collateralizer: Sender must be Term Contract smart contract.'\n        );\n\n        require(\n            collateralToken == token,\n            'InvoiceCollateralizer: Invalid collateral token.'\n        );\n\n        AcceptedInvoiceToken invoiceToken = AcceptedInvoiceToken(\n            collateralToken\n        );\n        address custodian = address(this);\n\n        require(\n            invoiceToken.ownerOf(uint256(invoiceTokenId)) == collateralizer,\n            'Invoice Collateralizer: Collateralizer must owner of invoice.'\n        );\n\n        // the collateral must be successfully transferred to this contract, via a proxy.\n        invoiceToken.safeTransferFrom(collateralizer, custodian, uint256(invoiceTokenId));\n\n        return true;\n    }\n\n    function withdrawERC721Collateralize(\n        bytes32 agreementId,\n        address collateralizer,\n        bytes32 invoiceTokenId,\n        address token\n    )\n    public\n    onlyRole(COLLATERALIZER)\n    whenNotPaused\n    returns (bool _success)\n    {\n        if (agreementToCollateralizer[agreementId] != address(0)) {\n            // The token in which collateral is denominated\n            address collateralToken;\n            // The terms contract according to which this asset is being collateralized.\n            InvoiceFinanceInterestTermsContract termsContract;\n\n            (\n            collateralToken,\n            ,\n            ,\n            termsContract\n            ) = retrieveInvoiceCollateralParameters(agreementId);\n\n            require(\n                address(termsContract) == msg.sender,\n                'Collateralizer: Sender must be Term Contract smart contract.'\n            );\n\n            require(\n                collateralToken == token,\n                'InvoiceCollateralizer: Invalid collateral token.'\n            );\n            require(\n                collateralizer == agreementToCollateralizer[agreementId],\n                'InvoiceCollateralizer: Invalid debtor of agreement'\n            );\n\n            // transfer the collateral this contract was holding in escrow back to collateralizer.\n            AcceptedInvoiceToken invoiceToken = AcceptedInvoiceToken(\n                collateralToken\n            );\n\n            require(\n                invoiceToken.ownerOf(uint256(invoiceTokenId)) == address(this),\n                'Invoice Collateralizer: Collateralizer must owner of invoice.'\n            );\n\n            invoiceToken.safeTransferFrom(address(this), collateralizer, uint256(invoiceTokenId));\n\n            // stop financing\n//            invoiceToken.stopFinancing(invoiceTokenId);\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns collateral to the debt agreement's original collateralizer\n     * if and only if the debt agreement's term has lapsed and\n     * the total expected repayment value has been repaid.\n     *\n     * @param agreementId bytes32 The debt agreement's ID\n     */\n    function returnInvoiceCollateral(bytes32 agreementId)\n    public\n    whenNotPaused\n    onlyPermissionedInvoiceTermContract(agreementId)\n    returns (bool)\n    {\n        if (agreementToCollateralizer[agreementId] != address(0)) {\n            // The token in which collateral is denominated\n            address collateralToken;\n\n            // Fetch all relevant collateralization parameters.\n            (collateralToken,,,) = retrieveInvoiceCollateralParameters(\n                agreementId\n            );\n\n            InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n\n            // Ensure a valid form of collateral is tied to this agreement id\n            require(\n                collateralToken != address(0),\n                'Collateral token must different with NULL.'\n            );\n            // Ensure that the debt is not in a state of default\n            // Ensure Value Repaid to date is greater or equal expected value until this Debt expired\n            require(\n                invoiceDebtRegistry.isCompletedRepayment(agreementId),\n                'Debtor have not completed repayment.'\n            );\n            // determine collateralizer of the collateral.\n            address collateralizer = agreementToCollateralizer[agreementId];\n\n            // Mark agreement's collateral as withdrawn by setting the agreement's\n            // collateralizer to 0x0.\n            delete agreementToCollateralizer[agreementId];\n\n            // transfer the collateral this contract was holding in escrow back to collateralizer.\n            uint256[] memory invoiceTokenIds = invoiceDebtRegistry\n            .getInvoiceTokenIds(agreementId);\n            if (invoiceTokenIds.length > 0) {\n                AcceptedInvoiceToken invoiceToken = registry.getAcceptedInvoiceToken();\n\n                for (uint256 i = 0; i < invoiceTokenIds.length; ++i) {\n                    if (invoiceToken.ownerOf(uint256(invoiceTokenIds[i])) != address(0)) {\n                        IERC721(collateralToken).safeTransferFrom(address(this), collateralizer, invoiceTokenIds[i]);\n                        // stop financing\n                        // invoiceToken.stopFinancing(bytes32(invoiceTokenIds[i]));\n\n                        // log the return event.\n                        emit CollateralReturned(\n                            agreementId,\n                            collateralizer,\n                            collateralToken,\n                            uint256(invoiceTokenIds[i])\n                        );\n                    }\n                }\n            }\n\n        }\n\n        return true;\n    }\n\n    // For receiving AIT token\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n    *\n    */\n    function timestampAdjustedForGracePeriod(uint256 gracePeriodInDays)\n    public\n    view\n    returns (uint256)\n    {\n        return block.timestamp.sub(SECONDS_IN_DAY.mul(gracePeriodInDays));\n    }\n\n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n}\n"
    },
    "contracts/protocol/loan/invoice/InvoiceDebtRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './CRDecisionEngine.sol';\nimport \"../../../libraries/Unpack16.sol\";\nimport \"../../../libraries/Unpack.sol\";\nimport \"../../../libraries/ConfigHelper.sol\";\nimport '../../../storage/Registry.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../../../tokens/ERC721/invoice/AcceptedInvoiceToken.sol';\n\n/**\n * The CommodityDebtRegistry stores the parameters and beneficiaries of all debt agreements in\n * Binkabi protocol.  It authorizes a limited number of agents to\n * perform mutations on it -- those agents can be changed at any\n * time by the contract's owner.\n */\ncontract InvoiceDebtRegistry is Initializable, PausableUpgradeable, OwnableUpgradeable, CRDecisionEngine {\n    using SafeMath for uint256;\n    using ConfigHelper for Registry;\n    using Unpack for bytes32;\n    using Unpack16 for bytes16;\n\n    struct Entry {\n        address version; // address of current repayment router\n        address beneficiary;\n        address debtor;\n        address termsContract;\n        address principalTokenAddress;\n        bytes32 termsContractParameters;\n        uint256 issuanceBlockTimestamp;\n        uint256 lastRepayTimestamp;\n        uint256 expirationTimestamp;\n        uint256 collateralRatio;\n        uint256 minCollateralRatio;\n    }\n\n    Registry public registry;\n    // Primary registry mapping agreement IDs to their corresponding entries\n    mapping(bytes32 => Entry) internal entries;\n    mapping(bytes32 => uint256[]) internal registryToInvoice;\n\n    // Maps debtor addresses to a list of their debts' agreement IDs\n    mapping(address => bytes32[]) internal debtorToDebts;\n\n    // List of terms which have completed repayment\n    mapping(bytes32 => bool) public completedRepayment;\n    mapping(bytes32 => uint256) public repaidPrincipalAmount;\n    mapping(bytes32 => uint256) public repaidInterestAmount;\n\n    mapping(bytes32 => bool) public completedLoans;\n\n    // Setting manual for interest amount\n    mapping(bytes32 => bool) public manualInterestLoan;\n    mapping(bytes32 => uint256) public manualInterestAmountLoan;\n\n    //////////////////////////////\n    // EVENTS                   //\n    //////////////////////////////\n\n    event LogInsertEntry(\n        bytes32 indexed agreementId,\n        address indexed beneficiary,\n        address termsContract,\n        bytes32 termsContractParameters\n    );\n\n    event LogModifyEntryBeneficiary(\n        bytes32 indexed agreementId,\n        address indexed previousBeneficiary,\n        address indexed newBeneficiary\n    );\n\n    //////////////////////////////\n    // MODIFIERS                //\n    //////////////////////////////\n\n    modifier nonNullBeneficiary(address beneficiary) {\n        require(\n            beneficiary != address(0),\n            'Invoice Debt Registry: Beneficiary must be different with address 0.'\n        );\n        _;\n    }\n\n    modifier onlyExtantEntry(bytes32 agreementId) {\n        require(\n            doesEntryExist(agreementId),\n            'Invoice Debt Registry: Agreement Id does not exists.'\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedToEdit() {\n        require(\n            _msgSender() == address(registry.getInvoiceFinanceInterestTermsContract()),\n            'Invoice Debt Registry: Sender does not have permission to edit.'\n        );\n        _;\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n    ////////////////////////////////////////////\n    // INTERNAL FUNCTIONS                    //\n    //////////////////////////////////////////\n    /**\n     * Helper function for computing the hash of a given issuance,\n     * and, in turn, its agreementId\n     */\n    function _getAgreementId(\n        Entry memory _entry,\n        address _debtor,\n        uint256 _salt\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _entry.version,\n                    _debtor,\n                    _entry.termsContract,\n                    _entry.termsContractParameters,\n                    _salt\n                )\n            );\n    }\n\n    function _evaluateCollateralRatio(bytes32 agreementId) internal {\n        uint256 invoiceAmount = _getTotalInvoiceAmount(agreementId);\n        uint256 totalRemain = registry.getInvoiceFinanceInterestTermsContract()\n            .getTotalExpectedRepaymentValue(agreementId, block.timestamp);\n\n        uint256 cr = _computeInvoiceCR(invoiceAmount, totalRemain);\n\n        uint256 previousCR = entries[agreementId].collateralRatio;\n\n        if (cr != previousCR) {\n            entries[agreementId].collateralRatio = cr;\n        }\n    }\n\n    ///////////////////////////////////////////\n    // CROSS-CONTRACT & EXTERNAL FUNCTIONS ///\n    /////////////////////////////////////////\n    //--------------\n    // SENDs\n    //--------------\n    /**\n     * TODO: Limitation for inserting\n     * Inserts a new entry into the registry, if the entry is valid and sender is\n     * authorized to make 'insert' mutations to the registry.\n     */\n    function insert(\n        address _version,\n        address _beneficiary,\n        address _debtor,\n        address _termsContract,\n        address _principalTokenAddress,\n        bytes32 _termsContractParameters,\n        bytes32[] memory _invoiceTokenIds,\n        uint256[3] memory values\n    )\n        public\n        whenNotPaused\n        nonNullBeneficiary(_beneficiary)\n        returns (bytes32 _agreementId)\n    {\n        Entry memory entry = Entry({\n            version: _version,\n            beneficiary: _beneficiary,\n            debtor: _debtor,\n            termsContract: _termsContract,\n            termsContractParameters: _termsContractParameters, //solium-disable-next-line security\n            issuanceBlockTimestamp: block.timestamp,\n            lastRepayTimestamp: 0,\n            collateralRatio: 0,\n            minCollateralRatio: values[0],\n            expirationTimestamp: values[1],\n            principalTokenAddress: _principalTokenAddress\n        });\n        bytes32 agreementId = _getAgreementId(entry, _debtor, values[2]); // entry, debtor, salt\n\n        require(\n            entries[agreementId].beneficiary == address(0),\n            'Beneficiary account already exists.'\n        );\n\n        entries[agreementId] = entry;\n\n        for (uint256 i = 0; i < _invoiceTokenIds.length; i++) {\n            registryToInvoice[agreementId].push(uint256(_invoiceTokenIds[i]));\n        }\n\n        selfEvaluateCollateralRatio(agreementId);\n\n        debtorToDebts[_debtor].push(agreementId);\n\n        emit LogInsertEntry(\n            agreementId,\n            entry.beneficiary,\n            entry.termsContract,\n            entry.termsContractParameters\n        );\n\n        return agreementId;\n    }\n\n    /**\n    * @dev TODO: Security restriction\n    * Restriction: only if terms parameters is validated\n    */\n    function updateLoanTermParameters(\n        bytes32 agreementId,\n        bytes32 newLoanTermsParameters\n    ) public {\n        entries[agreementId].termsContractParameters = newLoanTermsParameters;\n    }\n\n    function setMinCollateralRatio(\n        bytes32 agreementId,\n        uint256 minCollateralRatio\n    ) public {\n        entries[agreementId].minCollateralRatio = minCollateralRatio;\n    }\n\n    //@TODO security restriction\n    /**\n     * Modifies the beneficiary of a debt issuance, if the sender\n     * is authorized to make 'modifyBeneficiary' mutations to\n     * the entries.\n    */\n    function modifyBeneficiary(bytes32 agreementId, address newBeneficiary)\n        public\n        whenNotPaused\n        onlyExtantEntry(agreementId)\n        nonNullBeneficiary(newBeneficiary)\n    {\n        address previousBeneficiary = entries[agreementId].beneficiary;\n        entries[agreementId].beneficiary = newBeneficiary;\n\n        emit LogModifyEntryBeneficiary(\n            agreementId,\n            previousBeneficiary,\n            newBeneficiary\n        );\n    }\n\n    function selfEvaluateCollateralRatio(bytes32 agreementId) public {\n        _evaluateCollateralRatio(agreementId);\n    }\n\n    // Update timestamp of the last repayment from Debtor\n    function updateLastRepaymentTimestamp(\n        bytes32 agreementId,\n        uint256 newTimestamp\n    ) public onlyAuthorizedToEdit {\n        entries[agreementId].lastRepayTimestamp = newTimestamp;\n    }\n\n    //-----------------\n    // CALLs\n    //-----------------\n\n    /* Ensures an entry with the specified agreement ID exists within the debt entries. */\n    function doesEntryExist(bytes32 agreementId)\n        public\n        view\n        returns (bool exists)\n    {\n        return entries[agreementId].beneficiary != address(0);\n    }\n\n    /**\n     * Returns the beneficiary of a given issuance\n     */\n    function getBeneficiary(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (address)\n    {\n        // Lender\n        return entries[agreementId].beneficiary;\n    }\n\n    function getDebtor(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (address)\n    {\n        return entries[agreementId].debtor;\n    }\n\n    /**\n     * Returns a tuple of the terms contract and its associated parameters\n     * for a given issuance\n    */\n    function getTerms(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (address, bytes32)\n    {\n        return (\n            entries[agreementId].termsContract,\n            entries[agreementId].termsContractParameters\n        );\n    }\n\n    function getInvoiceTokenIds(bytes32 agreementId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return registryToInvoice[agreementId];\n    }\n\n    function insertInvoiceFinancedToInvoiceLoan(\n        bytes32 agreementId,\n        uint256 invoiceTokenId\n    ) public {\n        registryToInvoice[agreementId].push(invoiceTokenId);\n    }\n\n    function removeInvoiceId(bytes32 agreementId, uint256 invoiceId) public {\n        if (registryToInvoice[agreementId].length > 0) {\n            for (\n                uint256 i = 0;\n                i < registryToInvoice[agreementId].length;\n                ++i\n            ) {\n                if (registryToInvoice[agreementId][i] == invoiceId) {\n                    // Remove i element from registryToInvoice[agreementId]\n                    for (\n                        uint256 index = i;\n                        index < registryToInvoice[agreementId].length - 1;\n                        index++\n                    ) {\n                        registryToInvoice[agreementId][index] = registryToInvoice[agreementId][index +\n                            1];\n                    }\n                    registryToInvoice[agreementId].pop();\n\n                    selfEvaluateCollateralRatio(agreementId);\n                    break;\n                }\n            }\n        }\n    }\n\n    function _getTotalInvoiceAmount(bytes32 agreementId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        AcceptedInvoiceToken acceptedInvoiceToken = registry.getAcceptedInvoiceToken();\n\n        amount = 0;\n        if (registryToInvoice[agreementId].length > 0) {\n            for (\n                uint256 i = 0;\n                i < registryToInvoice[agreementId].length;\n                ++i\n            ) {\n                if (\n                    acceptedInvoiceToken.ownerOf(\n                        registryToInvoice[agreementId][i]\n                    ) != address(0)\n                ) {\n                    amount += acceptedInvoiceToken.getFiatAmount(\n                        registryToInvoice[agreementId][i]\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n    * Returns the terms contract address of a given issuance\n    */\n    function getTermsContract(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (address)\n    {\n        return entries[agreementId].termsContract;\n    }\n\n    /**\n     * Returns the terms contract parameters of a given issuance\n     */\n    function getTermsContractParameters(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (bytes32)\n    {\n        return entries[agreementId].termsContractParameters;\n    }\n\n    /**\n     * Returns the timestamp of the block at which a debt agreement was issued.\n     */\n    function getIssuanceBlockTimestamp(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (uint256 timestamp)\n    {\n        return entries[agreementId].issuanceBlockTimestamp;\n    }\n\n    function getLastRepaymentTimestamp(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (uint256 timestamp)\n    {\n        return entries[agreementId].lastRepayTimestamp;\n    }\n\n    function getExpirationTimestamp(bytes32 agreementId)\n        public\n        view\n        onlyExtantEntry(agreementId)\n        returns (uint256)\n    {\n        // solhint-disable-next-line not-rely-on-time\n        return entries[agreementId].expirationTimestamp;\n    }\n\n    /**\n     * Returns the parameters of a debt issuance in the entries.\n     *\n     * TODO: protect this function with our `onlyExtantEntry` modifier once the restriction\n     * on the size of the call stack has been addressed.\n     */\n    function get(bytes32 agreementId)\n        public\n        view\n        returns (address, address, address, bytes32, uint256)\n    {\n        return (\n            entries[agreementId].version,\n            entries[agreementId].beneficiary,\n            entries[agreementId].termsContract,\n            entries[agreementId].termsContractParameters,\n            entries[agreementId].issuanceBlockTimestamp\n        );\n    }\n\n    function getCollateralRatio(bytes32 agreementId)\n        public\n        view\n        returns (uint256)\n    {\n        return entries[agreementId].collateralRatio;\n    }\n\n    function getMinCollateralRatio(bytes32 agreementId)\n        public\n        view\n        returns (uint256)\n    {\n        return entries[agreementId].minCollateralRatio;\n    }\n\n    function isCompletedRepayment(bytes32 agreementId)\n        public\n        view\n        returns (bool)\n    {\n        return completedRepayment[agreementId];\n    }\n\n    function setCompletedRepayment(bytes32 agreementId) public {\n        completedRepayment[agreementId] = true;\n    }\n\n    function getRepaidPrincipalAmount(bytes32 agreementId)\n        public\n        view\n        returns (uint256)\n    {\n        return repaidPrincipalAmount[agreementId];\n    }\n\n    function addRepaidPrincipalAmount(bytes32 agreementId, uint256 repaidAmount)\n        public\n    {\n        repaidPrincipalAmount[agreementId] = repaidPrincipalAmount[agreementId]\n            .add(repaidAmount);\n    }\n\n    function setRepaidPrincipalAmount(bytes32 agreementId, uint256 repaidAmount)\n        public\n    {\n        repaidPrincipalAmount[agreementId] = repaidAmount;\n    }\n\n    function getRepaidInterestAmount(bytes32 agreementId)\n        public\n        view\n        returns (uint256)\n    {\n        return repaidInterestAmount[agreementId];\n    }\n\n    function addRepaidInterestAmount(bytes32 agreementId, uint256 repaidAmount)\n        public\n    {\n        repaidInterestAmount[agreementId] = repaidInterestAmount[agreementId]\n            .add(repaidAmount);\n    }\n\n    function setRepaidInterestAmount(bytes32 agreementId, uint256 repaidAmount)\n        public\n    {\n        repaidInterestAmount[agreementId] = repaidAmount;\n    }\n\n    function getValueRepaidToDate(bytes32 agreementId)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            repaidPrincipalAmount[agreementId],\n            repaidInterestAmount[agreementId]\n        );\n    }\n\n    function isCompletedLoan(bytes32 agreementId) public view returns (bool) {\n        return completedLoans[agreementId];\n    }\n\n    function setCompletedLoan(bytes32 agreementId) public {\n        completedLoans[agreementId] = true;\n    }\n\n    function isManualInterestLoan(bytes32 agreementId)\n        public\n        view\n        returns (bool)\n    {\n        return manualInterestLoan[agreementId];\n    }\n\n    function setManualInterestLoan(bytes32 agreementId, bool isManualInterest)\n        public\n    {\n        manualInterestLoan[agreementId] = isManualInterest;\n    }\n\n    function getManualInterestAmountLoan(bytes32 agreementId)\n        public\n        view\n        returns (uint256)\n    {\n        return manualInterestAmountLoan[agreementId];\n    }\n\n    function setManualInterestAmountLoan(\n        bytes32 agreementId,\n        uint256 interestAmount\n    ) public {\n        manualInterestAmountLoan[agreementId] = interestAmount;\n    }\n\n    function getAgreement(bytes32 agreementId) public view returns(Entry memory) {\n        return entries[agreementId];\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/protocol/loan/invoice/InvoiceFinanceInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './InvoiceDebtRegistry.sol';\nimport './InvoiceCollateralizer.sol';\nimport \"../LoanTyping.sol\";\nimport \"../../../storage/Registry.sol\";\nimport \"./CRDecisionEngine.sol\";\nimport \"../../../libraries/Unpack16.sol\";\nimport \"../../../libraries/Unpack.sol\";\nimport \"../../../libraries/ConfigHelper.sol\";\n\ncontract InvoiceFinanceInterestTermsContract is PausableUpgradeable, OwnableUpgradeable, CRDecisionEngine {\n    using SafeMath for uint;\n    using ConfigHelper for Registry;\n    using Unpack for bytes32;\n    using Unpack16 for bytes16;\n\n    uint public constant NUM_AMORTIZATION_UNIT_TYPES = 6;\n\n    uint public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    uint public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint public constant WEEK_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 7;\n    uint public constant MONTH_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 30;\n    uint public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10 ** 4;\n\n    // To convert an encoded interest rate into its equivalent multiplier\n    // (for purposes of calculating total interest), divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 0.01 interest multiplier\n    uint public constant INTEREST_RATE_SCALING_FACTOR_MULTIPLIER = INTEREST_RATE_SCALING_FACTOR_PERCENT * 100;\n\n    Registry public registry;\n\n    enum AmortizationUnitType {\n        MINUTES, // 0 - since 1.0.13\n        HOURS, // 1\n        DAYS, // 2\n        WEEKS, // 3\n        MONTHS, // 4\n        YEARS // 5\n    }\n\n    struct InterestParams {\n        uint256 principalAmount;\n        uint256 termStartUnixTimestamp;\n        uint256 termEndUnixTimestamp;\n        AmortizationUnitType amortizationUnitType;\n        uint256 termLengthInAmortizationUnits;\n        // interest rates can, at a maximum, have 4 decimal places of precision.\n        uint256 interestRate;\n    }\n\n    event LogInterestTermStart(\n        bytes32 indexed agreementId,\n        address indexed principalToken,\n        uint principalAmount,\n        uint interestRate,\n        uint indexed amortizationUnitType,\n        uint termLengthInAmortizationUnits\n    );\n\n    event LogRegisterRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    );\n\n    event LogRegisterCompleteTerm (\n        bytes32 agreementId\n    );\n\n    modifier onlyRouter() {\n        require(\n            msg.sender == address(registry.getInvoiceLoanRepaymentRouter()),\n            \"Only for Repayment Router.\"\n        );\n        _;\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n\n    function registerInvoiceLoanTermStart(bytes32 agreementId, address debtor)\n        external\n        returns (bool)\n    {\n        require(_msgSender() == address(registry.getInvoiceLoanKernel()), \"InvoiceFinanceInterestTermsContract: only debt kernel\");\n        address termsContract;\n        bytes32 termsContractParameters;\n\n        (termsContract, termsContractParameters) = registry.getInvoiceDebtRegistry()\n            .getTerms(agreementId);\n\n        uint256 principalAmount = termsContractParameters.unpackPrincipalAmount();\n        uint256 interestRate = termsContractParameters.unpackInterestRate();\n        uint256 amortizationUnitType= termsContractParameters.unpackAmortizationUnitType();\n        uint256 termLengthInAmortizationUnits= termsContractParameters.unpackTermLengthInAmortizationUnits();\n        uint256 gracePeriodInDays= termsContractParameters.unpackGracePeriodInDays();\n\n        address principalTokenAddress = registry.getInvoiceDebtRegistry().getAgreement(agreementId).principalTokenAddress;\n\n        // Collateralize AIT token\n        bool collateralized = registry.getInvoiceCollateralizer()\n            .collateralizeERC721(agreementId, debtor);\n\n        // Returns true (i.e. valid) if the specified principal token is valid,\n        // the specified amortization unit type is valid, and the terms contract\n        // associated with the agreement is this one.  We need not check\n        // if any of the other simple interest parameters are valid, because\n        // it is impossible to encode invalid values for them.\n        if (\n            principalTokenAddress != address(0) &&\n            amortizationUnitType < NUM_AMORTIZATION_UNIT_TYPES &&\n            termsContract == address(this) &&\n            collateralized\n        ) {\n            emit LogInterestTermStart(\n                agreementId,\n                principalTokenAddress,\n                principalAmount,\n                interestRate,\n                amortizationUnitType,\n                termLengthInAmortizationUnits\n            );\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  payer address. The address of the payer.\n    /// @param  beneficiary address. The address of the payment's beneficiary.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    function registerRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public onlyRouter() returns (uint256 remains) {\n        InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n        require(\n            tokenAddress == invoiceDebtRegistry.getAgreement(agreementId).principalTokenAddress,\n            'LoanTermsContract: Invalid token for repayment.'\n        );\n        // solium-disable-next-line\n        uint256 currentTimestamp = block.timestamp;\n\n        uint256 expectedPrincipal;\n        uint256 expectedInterest;\n        // query total outstanding amounts\n        (expectedPrincipal, expectedInterest) = getExpectedRepaymentValues(\n            agreementId,\n            currentTimestamp\n        );\n        // TODO: Currently only allow Debtor to repay with amount >= expectedInterest of that time\n        // Because, we haven't made any mechanism to manage outstanding interest amounts in the case when Debtor\n        // repaid with amount < expectedInterest (at that moment)\n        require(\n            unitsOfRepayment >= expectedInterest,\n            'LoanTermsContract: Expected interest amount is minimum.'\n        );\n\n        // exceed expectation, Debtor can pay all at once\n        if (unitsOfRepayment >= expectedPrincipal.add(expectedInterest)) {\n            invoiceDebtRegistry.setCompletedRepayment(agreementId);\n            invoiceDebtRegistry.addRepaidInterestAmount(\n                agreementId,\n                expectedInterest\n            );\n            invoiceDebtRegistry.addRepaidPrincipalAmount(\n                agreementId,\n                expectedPrincipal\n            );\n            // put the remain to interest\n            remains = unitsOfRepayment.sub(\n                expectedPrincipal.add(expectedInterest)\n            );\n        } else {\n            // if currently Debtor no need to repay for interest\n            if (expectedInterest == 0) {\n                if (unitsOfRepayment >= expectedPrincipal) {\n                    invoiceDebtRegistry.addRepaidPrincipalAmount(\n                        agreementId,\n                        expectedPrincipal\n                    );\n                    // with the remains\n                    if (unitsOfRepayment.sub(expectedPrincipal) > 0) {\n                        invoiceDebtRegistry.addRepaidInterestAmount(\n                            agreementId,\n                            unitsOfRepayment.sub(expectedPrincipal)\n                        );\n                    }\n                } else {\n                    invoiceDebtRegistry.addRepaidPrincipalAmount(\n                        agreementId,\n                        unitsOfRepayment\n                    );\n                }\n            } else {\n                // if expectedInterest > 0 ( & unitsOfRepayment >= expectedInterest)\n                invoiceDebtRegistry.addRepaidInterestAmount(\n                    agreementId,\n                    expectedInterest\n                );\n                if (unitsOfRepayment.sub(expectedInterest) > 0) {\n                    // Debtor is not able to fulfill the expectedPrincipal as we already validated from first IF statement\n                    // -> there is no remains for adding to repaidInterestAmount\n                    invoiceDebtRegistry.addRepaidPrincipalAmount(\n                        agreementId,\n                        unitsOfRepayment.sub(expectedInterest)\n                    );\n                }\n            }\n        }\n\n        // Update Debt registry record\n        invoiceDebtRegistry.updateLastRepaymentTimestamp(\n            agreementId,\n            currentTimestamp\n        );\n        invoiceDebtRegistry.selfEvaluateCollateralRatio(agreementId);\n\n        // Emit new event\n        emit LogRegisterRepayment(\n            agreementId,\n            payer,\n            beneficiary,\n            unitsOfRepayment,\n            tokenAddress\n        );\n\n        return remains;\n    }\n\n    /**\n        * Function will be called by Debt Kernel, supports Debtor to deposit more invoice\n        */\n    function registerSecureLoanWithInvoice(\n        bytes32 agreementId,\n        address debtor,\n        address collateral,\n        bytes32[] memory invoiceTokenIds\n    ) public returns (bool) {\n        InvoiceDebtRegistry debtRegistry = registry.getInvoiceDebtRegistry();\n        require(\n            debtor == debtRegistry.getDebtor(agreementId),\n            'Invalid debtor of agreement'\n        );\n\n        for (uint256 i = 0; i < invoiceTokenIds.length; i++) {\n            // Sezie collateral tokens with addition amount\n            bool collateralized = registry.getInvoiceCollateralizer()\n                .additionERC721Collateralize(\n                agreementId,\n                debtor,\n                invoiceTokenIds[i],\n                collateral\n            );\n\n            if (collateralized) {\n                // update terms contract parameters, then re evaluate CR\n                debtRegistry.insertInvoiceFinancedToInvoiceLoan(\n                    agreementId,\n                    uint256(invoiceTokenIds[i])\n                );\n                debtRegistry.selfEvaluateCollateralRatio(agreementId);\n            }\n        }\n        return true;\n    }\n\n    function registerInsecureLoanByWithdrawInvoice(\n        bytes32 agreementId,\n        address debtor,\n        address collateral,\n        bytes32[] memory invoiceTokenIds\n    ) public returns (bool) {\n        InvoiceDebtRegistry debtRegistry = registry.getInvoiceDebtRegistry();\n        address debtorOfAgreement = debtRegistry.getDebtor(agreementId);\n        require(debtor == debtorOfAgreement, 'Invalid debtor of agreement');\n\n        for (uint256 i = 0; i < invoiceTokenIds.length; i++) {\n            // Sezie collateral tokens with addition amount\n            bool collateralized = registry.getInvoiceCollateralizer()\n                .withdrawERC721Collateralize(\n                agreementId,\n                debtor,\n                invoiceTokenIds[i],\n                collateral\n            );\n\n            if (collateralized) {\n                // update terms contract parameters, then re evaluate CR\n                debtRegistry.removeInvoiceId(\n                    agreementId,\n                    uint256(invoiceTokenIds[i])\n                );\n                debtRegistry.selfEvaluateCollateralRatio(agreementId);\n            }\n\n        }\n\n        uint256 cr = debtRegistry.getCollateralRatio(agreementId);\n        uint256 minCollateralRatio = debtRegistry.getMinCollateralRatio(\n            agreementId\n        );\n\n        if (cr < minCollateralRatio) {\n            revert(\n                'InvoiceInterest: Invalid collateral ratio, bellow min collateral ratio'\n            );\n        }\n\n        return true;\n    }\n\n    function registerConcludeInvoiceLoan(bytes32 agreementId)\n        external\n        returns (bool)\n    {\n        InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n        require(\n            invoiceDebtRegistry.isCompletedRepayment(agreementId),\n            'Debtor has not completed repayment yet.'\n        );\n        require(\n            registry.getInvoiceCollateralizer()\n                .returnInvoiceCollateral(agreementId),\n            'Unable to return AIT to its owner'\n        );\n\n        invoiceDebtRegistry.setCompletedLoan(agreementId);\n        emit LogRegisterCompleteTerm(agreementId);\n        return true;\n    }\n\n    function _unpackParamsForAgreementID(\n        bytes32 agreementId\n    )\n    internal\n    view\n    returns (InterestParams memory params)\n    {\n        bytes32 parameters;\n        uint issuanceBlockTimestamp = 0;\n\n        InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n        issuanceBlockTimestamp = invoiceDebtRegistry.getIssuanceBlockTimestamp(agreementId);\n        parameters = invoiceDebtRegistry.getTermsContractParameters(agreementId);\n\n        // The principal amount denominated in the aforementioned token.\n        uint256 principalAmount = parameters.unpackPrincipalAmount();\n        uint256 interestRate = parameters.unpackInterestRate();\n        // The amortization unit in which the repayments installments schedule is defined.\n        uint256 rawAmortizationUnitType= parameters.unpackAmortizationUnitType();\n        // The debt's entire term's length, denominated in the aforementioned amortization units\n        uint256 termLengthInAmortizationUnits= parameters.unpackTermLengthInAmortizationUnits();\n\n        // Before we cast to `AmortizationUnitType`, ensure that the raw value being stored is valid.\n        require(\n            rawAmortizationUnitType <= uint(AmortizationUnitType.YEARS),\n            \"Amortization Unit Type is invalid.\"\n        );\n\n        AmortizationUnitType amortizationUnitType = AmortizationUnitType(rawAmortizationUnitType);\n\n        // Calculate term length base on Amortization Unit and number\n        uint termLengthInSeconds = termLengthInAmortizationUnits.mul(\n            _getAmortizationUnitLengthInSeconds(amortizationUnitType)\n        );\n\n        return InterestParams({\n            principalAmount: principalAmount,\n            interestRate: interestRate,\n            termStartUnixTimestamp: issuanceBlockTimestamp,\n            termEndUnixTimestamp: termLengthInSeconds.add(issuanceBlockTimestamp),\n            amortizationUnitType: amortizationUnitType,\n            termLengthInAmortizationUnits: termLengthInAmortizationUnits\n        });\n    }\n\n    function _getAmortizationUnitLengthInSeconds(AmortizationUnitType amortizationUnitType)\n    internal\n    pure\n    returns (uint)\n    {\n        if (amortizationUnitType == AmortizationUnitType.MINUTES) {\n            return MINUTE_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.HOURS) {\n            return HOUR_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.DAYS) {\n            return DAY_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.WEEKS) {\n            return WEEK_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.MONTHS) {\n            return MONTH_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == AmortizationUnitType.YEARS) {\n            return YEAR_LENGTH_IN_SECONDS;\n        } else {\n            revert(\"Unknown amortization unit type.\");\n        }\n    }\n    /**\n    * Expected repayment value with Amortization of Interest and Principal\n    * (AMORTIZATION) - will be used for repayment from Debtor\n    */\n    function getExpectedRepaymentValues(bytes32 agreementId, uint256 timestamp)\n        public\n        view\n        returns (uint256 expectedPrincipal, uint256 expectedInterest)\n    {\n        InterestParams memory params = _unpackParamsForAgreementID(agreementId);\n        InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n\n        uint256 repaidPrincipalAmount = invoiceDebtRegistry\n            .getRepaidPrincipalAmount(agreementId);\n        uint256 repaidInterestAmount = invoiceDebtRegistry\n            .getRepaidInterestAmount(agreementId);\n        uint256 lastRepaymentTimestamp = invoiceDebtRegistry\n            .getLastRepaymentTimestamp(agreementId);\n\n        bool isManualInterestLoan = invoiceDebtRegistry.isManualInterestLoan(\n            agreementId\n        );\n        uint256 manualInterestAmountLoan;\n        if (isManualInterestLoan) {\n            manualInterestAmountLoan = invoiceDebtRegistry\n                .getManualInterestAmountLoan(agreementId);\n        }\n\n        (\n            expectedPrincipal,\n            expectedInterest\n        ) = _getExpectedRepaymentValuesToTimestamp(\n            params,\n            lastRepaymentTimestamp,\n            timestamp,\n            repaidPrincipalAmount,\n            repaidInterestAmount,\n            isManualInterestLoan,\n            manualInterestAmountLoan\n        );\n    }\n\n    /**\n   * Calculate values which Debtor need to pay to conclude current Loan\n   */\n    function _getExpectedRepaymentValuesToTimestamp(\n        InterestParams memory _params,\n        uint _lastRepaymentTimestamp, // timestamp of last repayment from debtor\n        uint _timestamp,\n        uint repaidPrincipalAmount,\n        uint repaidInterestAmount,\n        bool isManualInterestLoan,\n        uint manualInterestAmountLoan\n    ) internal pure returns (uint expectedPrinciapal, uint expectedInterest) {\n        uint outstandingPrincipal = _params.principalAmount.sub(repaidPrincipalAmount);\n\n        expectedPrinciapal = outstandingPrincipal;\n\n        if (isManualInterestLoan) {\n            expectedInterest = manualInterestAmountLoan;\n        } else {\n            expectedInterest = _calculateInterestAmountToTimestamp(\n                _params.principalAmount,\n                outstandingPrincipal,\n                repaidInterestAmount,\n                _params.interestRate,\n                _params.termStartUnixTimestamp,\n                _params.termEndUnixTimestamp,\n                _lastRepaymentTimestamp,\n                _timestamp\n            );\n        }\n    }\n\n    // Calculate interest amount for a duration with specific Principal amount\n    function _calculateInterestForDuration(\n        uint _principalAmount,\n        uint _interestRate,\n        uint _durationLengthInSec\n    ) internal pure returns (uint) {\n        return _principalAmount.mul(_interestRate).mul(_durationLengthInSec.div(DAY_LENGTH_IN_SECONDS))\n        .div(INTEREST_RATE_SCALING_FACTOR_MULTIPLIER).div(YEAR_LENGTH_IN_DAYS);\n    }\n\n    function getStartDateInTimestamp(uint _timestamp) private pure returns (uint) {\n        uint secondInDay = _timestamp.mod(DAY_LENGTH_IN_SECONDS);\n        return  _timestamp.sub(secondInDay);\n    }\n\n    // Calculate interest amount Debtor need to pay until current date\n    function _calculateInterestAmountToTimestamp(\n        uint _principalAmount,\n        uint _currentPrincipalAmount,\n        uint _paidInterestAmount,\n        uint _annualInterestRate,\n        uint _startTermTimestamp,\n        uint _endTermTimestamp,\n        uint _lastRepayTimestamp,\n        uint _timestamp\n    ) internal pure returns (uint) {\n        if (_timestamp <= _startTermTimestamp) {\n            return 0;\n        }\n        uint interest = 0;\n\n        uint startOfDayOfLastRepay = getStartDateInTimestamp(_lastRepayTimestamp);\n        uint startOfDayOfTermsStart = getStartDateInTimestamp(_startTermTimestamp);\n        uint startOfDayToCalculateInterest = getStartDateInTimestamp(_timestamp);\n\n        uint elapseTimeFromLastRepay = startOfDayToCalculateInterest.sub(startOfDayOfLastRepay);\n        uint elapseTimeFromStart = startOfDayToCalculateInterest.sub(startOfDayOfTermsStart).add(DAY_LENGTH_IN_SECONDS);\n\n        // If still within the term length\n        if (_timestamp < _endTermTimestamp) {\n            // Have just made new repayment\n            if (elapseTimeFromLastRepay == 0 && _paidInterestAmount > 0) {\n                interest = 0;\n            } else {\n                if (_paidInterestAmount > 0) {\n                    // Has made at least 1 repayment\n                    interest = _calculateInterestForDuration(\n                        _currentPrincipalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromLastRepay\n                    );\n                } else {\n                    // Haven't made any repayment\n                    interest = _calculateInterestForDuration(\n                        _principalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromStart\n                    );\n                }\n            }\n\n        } else if (_timestamp >= _endTermTimestamp) {\n            // If debtor has made at least 1 repayment\n            if (_paidInterestAmount > 0) {\n                interest = _calculateInterestForDuration(\n                    _currentPrincipalAmount,\n                    _annualInterestRate,\n                    elapseTimeFromLastRepay\n                );\n            } else {\n                interest = _calculateInterestForDuration(\n                    _principalAmount,\n                    _annualInterestRate,\n                    elapseTimeFromStart\n                );\n            }\n        } else {\n            interest = 0;\n        }\n        return interest;\n    }\n\n    function getValueRepaidToDate(bytes32 agreementId)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return registry.getInvoiceDebtRegistry().getValueRepaidToDate(agreementId);\n    }\n\n    function isTermsContractExpired(bytes32 agreementId)\n        public\n        view\n        returns (bool)\n    {\n        uint256 expTimestamp = registry.getInvoiceDebtRegistry()\n            .getExpirationTimestamp(agreementId);\n        // solium-disable-next-line\n        if (expTimestamp <= block.timestamp) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n    * Function will be called by Debt Kernel, supports Debtor to deposit more collateral\n    */\n    function registerDrawdownLoan(\n        bytes32 agreementId,\n        uint256 drawdownAmount,\n        bytes32 termsContractParameters\n    ) public returns (bool) {\n        // query current terms contract parameters\n        InvoiceDebtRegistry debtRegistry = registry.getInvoiceDebtRegistry();\n        require(\n            drawdownAmount > 0,\n            'Invoice Terms Contract: Drawdown amount must greater than 0.'\n        );\n\n        (, bytes32 currentTermsParameters) = debtRegistry.getTerms(agreementId);\n        // validate new paramters, compare the amounts\n        require(\n            _validateNewTermsContractParamsDrawdown(\n                currentTermsParameters,\n                termsContractParameters,\n                drawdownAmount\n            ),\n            'Invoice Terms Contract: Invalid terms contract parameters.'\n        );\n        require(\n            _validateNewCollateralRatioWhenDrawdown(\n                agreementId,\n                drawdownAmount,\n                debtRegistry\n            ),\n            'InvoiceInterest: Invalid collateral ratio, bellow min collateral ratio'\n        );\n\n        // update terms contract parameters, then re evaluate CR\n        debtRegistry.updateLoanTermParameters(\n            agreementId,\n            termsContractParameters\n        );\n        debtRegistry.selfEvaluateCollateralRatio(agreementId);\n\n        return true;\n    }\n\n    function _validateNewTermsContractParamsDrawdown(\n        bytes32 _oldTermsContractParameters,\n        bytes32 _newTermsContractParameters,\n        uint _drawdownAmount\n    ) internal pure returns (bool) {\n        bool isValidPrincipalAmount = _newTermsContractParameters.unpackPrincipalAmount()\n        .sub(_oldTermsContractParameters.unpackPrincipalAmount()) == _drawdownAmount;\n\n        bool isInterestRateCorrect = _oldTermsContractParameters.unpackInterestRate()\n        == _newTermsContractParameters.unpackInterestRate();\n\n        bool isAmortizationUnitTypeCorrect = _oldTermsContractParameters.unpackAmortizationUnitType()\n        == _newTermsContractParameters.unpackAmortizationUnitType();\n\n        bool isTermLengthInAmortizationUnitsCorrect = _oldTermsContractParameters.unpackTermLengthInAmortizationUnits()\n        == _newTermsContractParameters.unpackTermLengthInAmortizationUnits();\n\n        bool isGracePeriodInDaysCorrect = _oldTermsContractParameters.unpackGracePeriodInDays()\n        == _newTermsContractParameters.unpackGracePeriodInDays();\n\n        return (\n            isValidPrincipalAmount &&\n            isInterestRateCorrect &&\n            isAmortizationUnitTypeCorrect &&\n            isTermLengthInAmortizationUnitsCorrect &&\n            isGracePeriodInDaysCorrect\n        );\n\n    }\n\n    function _validateNewCollateralRatioWhenDrawdown(\n        bytes32 agreementId,\n        uint256 _amountDrawdown,\n        InvoiceDebtRegistry debtRegistry\n    ) private view returns (bool) {\n        uint256 collateralAmount = debtRegistry._getTotalInvoiceAmount(\n            agreementId\n        );\n        uint256 currentTimestamp = block.timestamp;\n\n        uint256 totalRemain = getTotalExpectedRepaymentValue(\n            agreementId,\n            currentTimestamp\n        );\n        uint256 cr = _computeInvoiceCR(\n            collateralAmount,\n            totalRemain + _amountDrawdown\n        );\n\n        uint256 minCollateralRatio = debtRegistry.getMinCollateralRatio(\n            agreementId\n        );\n\n        if (cr < minCollateralRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n    * Get TOTAL expected repayment value at specific timestamp\n    * (NO AMORTIZATION)\n    */\n    function getTotalExpectedRepaymentValue(\n        bytes32 agreementId,\n        uint256 timestamp\n    )\n        public\n        view\n        returns (uint256 expectedRepaymentValue)\n    {\n        uint256 principalAmount;\n        uint256 interestAmount;\n        (principalAmount, interestAmount) = getExpectedRepaymentValues(\n            agreementId,\n            timestamp\n        );\n        expectedRepaymentValue = principalAmount.add(interestAmount);\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/protocol/loan/invoice/InvoiceLoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './InvoiceFinanceInterestTermsContract.sol';\nimport './InvoiceDebtRegistry.sol';\nimport \"../../../storage/Registry.sol\";\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport \"../../../libraries/ConfigHelper.sol\";\n\n/**\n * The InvoiceLoanDebtKernel is the hub of all business logic governing how and when\n * debt orders can be filled and cancelled.  All logic that determines\n * whether a debt order is valid & consensual is contained herein,\n * as well as the mechanisms that transfer fees to keepers and\n * principal payments to debtors.\n *\n */\ncontract InvoiceLoanKernel is PausableUpgradeable, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using ConfigHelper for Registry;\n\n    Registry registry;\n\n    bytes32 public constant NULL_ISSUANCE_HASH = bytes32(0);\n\n    /* NOTE: Currently, the `view` keyword does not actually enforce the\n    static nature of the method; this will change in the future, but for now, in\n    order to prevent reentrancy we'll need to arbitrarily set an upper bound on\n    the gas limit allotted for certain method calls. */\n    uint16 public constant EXTERNAL_QUERY_GAS_LIMIT = 8000;\n\n    mapping(bytes32 => bool) public issuanceCancelled;\n    mapping(bytes32 => bool) public debtOrderCancelled;\n    mapping(bytes32 => bool) public debtOrderCompleted;\n\n    mapping(bytes32 => bytes32) public agreementToLiability;\n\n    ///////////////////////////\n    // EVENTS\n    ///////////////////////////\n\n    event LogDebtOrderFilled(\n        bytes32 indexed _agreementId,\n        uint256 _principal,\n        address _principalToken,\n        address _relayer\n    );\n\n    event LogIssuanceCancelled(\n        bytes32 indexed _agreementId,\n        address indexed _cancelledBy\n    );\n\n    event LogDebtOrderCancelled(\n        bytes32 indexed _debtOrderHash,\n        address indexed _cancelledBy\n    );\n\n    event LogFeeTransfer(\n        address indexed payer,\n        address token,\n        uint256 amount,\n        address indexed beneficiary\n    );\n\n    struct Issuance {\n        address version;\n        address debtor;\n        address termsContract;\n        bytes32 termsContractParameters;\n        bytes32[] invoiceTokenIds;\n        bytes32 agreementId;\n        uint256 salt;\n    }\n\n    struct DebtOrder {\n        Issuance issuance;\n        uint256 principalAmount;\n        address principalToken;\n        uint256 creditorFee;\n        uint256 debtorFee;\n        address relayer;\n        uint256 expirationTimestampInSec;\n        bytes32 debtOrderHash;\n        uint256 minCollateralRatio;\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n    ////////////////////////\n    // INTERNAL FUNCTIONS //\n    ////////////////////////\n\n    /**\n     * Returns the hash of the debt order.\n     */\n    function _getDebtOrderHash(DebtOrder memory debtOrder)\n        internal\n        view\n        returns (bytes32 _debtorMessageHash)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    address(this),\n                    debtOrder.issuance.agreementId,\n                    debtOrder.principalAmount,\n                    debtOrder.principalToken,\n                    debtOrder.debtorFee,\n                    debtOrder.creditorFee,\n                    debtOrder.relayer,\n                    debtOrder.expirationTimestampInSec\n                )\n            );\n    }\n\n    function getInvoiceTokenIds(bytes32[] memory orderBytes32)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory invoiceTokenIds = new bytes32[](\n            orderBytes32.length - 1\n        );\n        for (uint256 i = 0; i < invoiceTokenIds.length; i++) {\n            invoiceTokenIds[i] = orderBytes32[i + 1];\n        }\n        return invoiceTokenIds;\n    }\n\n    /**\n     * Helper function that constructs a hashed debt order struct given the raw parameters\n     * of a debt order.\n     */\n    function _getDebtOrder(\n        address[5] memory orderAddresses, // 0-repayment router, 1-debtor, 2-termcontract, 3-principalTokenAddress, 4-relayer\n        uint256[6] memory orderValues, // 0-salt, 1-principalAmount, 2-creditorFee, 3-debtorFee, 4-expirationTimestampInSec, 5-minCR\n        bytes32[] memory orderBytes32\n    ) internal view returns (DebtOrder memory _debtOrder) {\n        DebtOrder memory debtOrder = DebtOrder({\n            issuance: _getIssuance(\n                orderAddresses[0],\n                orderAddresses[1],\n                orderAddresses[2],\n                orderValues[0],\n                orderBytes32[0],\n                getInvoiceTokenIds(orderBytes32)\n            ),\n            principalToken: orderAddresses[3],\n            relayer: orderAddresses[4],\n            principalAmount: orderValues[1],\n            creditorFee: orderValues[2],\n            debtorFee: orderValues[3],\n            expirationTimestampInSec: orderValues[4],\n            debtOrderHash: bytes32(0),\n            minCollateralRatio: orderValues[5]\n        });\n\n        debtOrder.debtOrderHash = _getDebtOrderHash(debtOrder);\n\n        return debtOrder;\n    }\n\n    /**\n     * Helper function that returns an issuance's hash\n     */\n    function _getAgreementId(\n        address version,\n        address debtor,\n        address termsContract,\n        uint256 salt,\n        bytes32 termsContractParameters\n    ) internal pure returns (bytes32 _agreementId) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    version,\n                    debtor,\n                    termsContract,\n                    termsContractParameters,\n                    salt\n                )\n            );\n    }\n\n    /**\n     * Helper function that constructs a hashed issuance structs from the given\n     * parameters.\n     */\n    function _getIssuance(\n        address _version,\n        address _debtor,\n        address _termsContract,\n        uint256 _salt,\n        bytes32 _termsContractParameters,\n        bytes32[] memory _invoiceTokenIds\n    ) internal pure returns (Issuance memory _issuance) {\n        Issuance memory issuance = Issuance({\n            version: _version,\n            debtor: _debtor,\n            termsContract: _termsContract,\n            salt: _salt,\n            termsContractParameters: _termsContractParameters,\n            invoiceTokenIds: _invoiceTokenIds,\n            agreementId: _getAgreementId(\n                _version,\n                _debtor,\n                _termsContract,\n                _salt,\n                _termsContractParameters\n            )\n        });\n\n        return issuance;\n    }\n\n    function _burnLoanAssetToken(bytes32 agreementId)\n        internal\n    {\n        registry.getLoanAssetToken().burn(uint256(agreementId));\n    }\n\n    /**\n     * Helper function for querying an address' balance on a given token.\n     */\n    function _getBalance(address token, address owner)\n        internal\n        view\n        returns (uint256 _balance)\n    {\n        // Limit gas to prevent reentrancy.\n        return ERC20(token).balanceOf(owner);\n    }\n\n    /**\n     * Helper function transfers a specified amount of tokens between two parties\n     * using the token transfer proxy contract.\n     */\n    function _transferTokensFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool success) {\n        return\n            IERC20(token)\n                .transferFrom(from, to, amount);\n    }\n\n    /**\n     * Asserts that debt order meets all validity requirements described in\n     * the Kernel specification document.\n     */\n    function _assertDebtOrderValidityInvariants(DebtOrder memory debtOrder)\n        internal view\n        returns (bool)\n    {\n        // Validate fee amount\n        // uint totalFees = debtOrder.creditorFee.add(debtOrder.debtorFee);\n        // Invariant: debtor is given enough principal to cover at least debtorFees\n        if (debtOrder.principalAmount < debtOrder.debtorFee) {\n            return false;\n        }\n        // Invariant: debt order must not be expired\n        // solhint-disable-next-line not-rely-on-time\n        if (debtOrder.expirationTimestampInSec < block.timestamp) {\n            return false;\n        }\n        // Invariant: debt order's issuance must not have been cancelled\n        if (issuanceCancelled[debtOrder.issuance.agreementId]) {\n            return false;\n        }\n        // Invariant: debt order itself must not have been cancelled\n        if (debtOrderCancelled[debtOrder.debtOrderHash]) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n    *\n    */\n    function _assertDebtExisting(bytes32 agreementId)\n        internal\n        view\n        returns (bool)\n    {\n        return registry.getLoanAssetToken().ownerOf(uint256(agreementId)) != address(0);\n    }\n\n    /**\n    */\n    function _assertCompletedRepayment(bytes32 agreementId)\n        internal\n        view\n        returns (bool)\n    {\n        return\n                registry.getInvoiceDebtRegistry()\n                .isCompletedRepayment(agreementId);\n    }\n\n    //Conclude a loan, stop lending/loan terms or allow the loan loss\n    function _concludeLoan(\n        address creditor,\n        bytes32 agreementId,\n        address termContract\n    ) internal {\n        require(creditor != address(0), 'Invalid creditor account.');\n        require(agreementId != bytes32(0), 'Invalid agreement id.');\n        require(termContract != address(0), 'Invalid terms contract.');\n\n        if (\n            !_assertDebtExisting(agreementId) ||\n            !_assertCompletedRepayment(agreementId)\n        ) {\n            revert(\n                'Debt does not exsits or Debtor have not completed repayment.'\n            );\n        }\n\n        // bool isTermCompleted = true;\n        bool isTermCompleted = InvoiceFinanceInterestTermsContract(termContract)\n            .registerConcludeInvoiceLoan(agreementId);\n\n        if (isTermCompleted) {\n            _burnLoanAssetToken(agreementId);\n        } else {\n            revert('Unable to conclude terms contract.');\n        }\n    }\n\n    // Transfer fee to beneficiaries\n    function _transferFeesToBeneficiaries(\n        address payer,\n        address from,\n        address token,\n        address[5] memory beneficiaries,\n        uint256[5] memory amounts\n    ) internal {\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] > 0 && beneficiaries[i] != address(0x0)) {\n                _transferTokensFrom(token, from, beneficiaries[i], amounts[i]);\n                emit LogFeeTransfer(payer, token, amounts[i], beneficiaries[i]);\n            }\n        }\n    }\n\n    function _sumTotalFees(uint256[5] memory amounts)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 totalAmount;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            totalAmount = totalAmount.add(amounts[i]);\n        }\n        return totalAmount;\n    }\n\n    ////////////////////////\n    // EXTERNAL FUNCTIONS //\n    ////////////////////////\n\n    /**\n    * Debtor call to complete this Debt whenever he thinks that he completed all repayment\n    */\n    function concludeLoan(\n        address creditor,\n        address debtor,\n        bytes32 agreementId,\n        address termContract\n    ) public whenNotPaused {\n        _concludeLoan(creditor, agreementId, termContract);\n    }\n\n    /**\n     * Allows a debtor to cancel a debt order before it's been filled\n     * -- preventing any counterparty from filling it in the future.\n     */\n    function cancelDebtOrder(\n        address[5] memory orderAddresses,\n        uint256[6] memory orderValues,\n        bytes32[] memory orderBytes32\n    ) public whenNotPaused {\n        DebtOrder memory debtOrder = _getDebtOrder(\n            orderAddresses,\n            orderValues,\n            orderBytes32\n        );\n\n        require(\n            msg.sender == debtOrder.issuance.debtor,\n            \"Debtor cancelation's requestor must be the Debtor.\"\n        );\n\n        debtOrderCancelled[debtOrder.debtOrderHash] = true;\n\n        emit LogDebtOrderCancelled(debtOrder.debtOrderHash, msg.sender);\n    }\n\n    /**\n     * Allows debtors to prevent a debt issuance in which they're involved from being used in\n     * a future debt order.\n     */\n    function cancelIssuance(\n        address version,\n        address debtor,\n        address termsContract,\n        bytes32 termsContractParameters,\n        bytes32[] memory collateralInfoParameters,\n        uint256 salt\n    ) public whenNotPaused {\n        require(\n            msg.sender == debtor,\n            \"Issuance cancelation's requestor must be the Debtor.\"\n        );\n\n        Issuance memory issuance = _getIssuance(\n            version,\n            debtor,\n            termsContract,\n            salt,\n            termsContractParameters,\n            collateralInfoParameters\n        );\n\n        issuanceCancelled[issuance.agreementId] = true;\n\n        emit LogIssuanceCancelled(issuance.agreementId, msg.sender);\n    }\n\n    function getDebtorCreditorFeeBeneficiaries(\n        address[10] memory feeBeneficiaries,\n        bool isDebtor\n    ) internal pure returns (address[5] memory result) {\n        uint256 dataMargin = isDebtor ? 0 : 5;\n        for (uint8 i = 0; i < result.length; i++) {\n            result[i] = feeBeneficiaries[i + dataMargin];\n        }\n    }\n\n    function getDebtorCreditorFeeAmounts(\n        uint256[10] memory feeAmounts,\n        bool isDebtor\n    ) internal pure returns (uint256[5] memory result) {\n        uint256 dataMargin = isDebtor ? 0 : 5;\n        for (uint8 i = 0; i < result.length; i++) {\n            result[i] = feeAmounts[i + dataMargin];\n        }\n    }\n\n    function _transferTokensLoanIssuance(\n        DebtOrder memory debtOrder,\n        address creditor,\n        address[10] memory feeBeneficiaries,\n        uint256[10] memory feeAmounts\n    ) internal {\n        uint256[5] memory debtorFeeAmounts = getDebtorCreditorFeeAmounts(\n            feeAmounts,\n            true\n        );\n\n        // Transfer principal to debtor\n        if (debtOrder.principalAmount > 0) {\n            require(\n                _transferTokensFrom(\n                    debtOrder.principalToken,\n                    creditor,\n                    debtOrder.issuance.debtor,\n                    debtOrder.principalAmount.sub(\n                        _sumTotalFees(debtorFeeAmounts).add(debtOrder.debtorFee)\n                    )\n                ),\n                'Unable to transfer principal tokens to Debtor.'\n            );\n        }\n\n        // Transfer debtorFee to relayer\n        if (debtOrder.debtorFee > 0) {\n            require(\n                _transferTokensFrom(\n                    debtOrder.principalToken,\n                    creditor, // because creditor is the person who approved Tranfer Proxy to transfer, not Debtor\n                    debtOrder.relayer,\n                    debtOrder.debtorFee\n                ),\n                \"Unable to transfer debtor's fee to Relayer.\"\n            );\n            emit LogFeeTransfer(\n                debtOrder.issuance.debtor,\n                debtOrder.principalToken,\n                debtOrder.debtorFee,\n                debtOrder.relayer\n            );\n        }\n\n        // Transfer debtorFee to relayer\n        if (debtOrder.creditorFee > 0) {\n            require(\n                _transferTokensFrom(\n                    debtOrder.principalToken,\n                    creditor,\n                    debtOrder.relayer,\n                    debtOrder.creditorFee\n                ),\n                \"Unable to transfer creditor's fee to Relayer.\"\n            );\n            emit LogFeeTransfer(\n                creditor,\n                debtOrder.principalToken,\n                debtOrder.creditorFee,\n                debtOrder.relayer\n            );\n        }\n\n        _transferFeesToBeneficiaries(\n            creditor,\n            creditor,\n            debtOrder.principalToken,\n            getDebtorCreditorFeeBeneficiaries(feeBeneficiaries, false),\n            getDebtorCreditorFeeAmounts(feeAmounts, false)\n        );\n\n        _transferFeesToBeneficiaries(\n            debtOrder.issuance.debtor,\n            creditor, // because deducted directly from principal amount\n            debtOrder.principalToken,\n            getDebtorCreditorFeeBeneficiaries(feeBeneficiaries, true),\n            debtorFeeAmounts\n        );\n    }\n\n    // Modify financing status of AIT\n/*\n    function _changeInvoiceFinancingState(\n        bytes32[] memory _tokenIds,\n        bytes32 _agreementId\n    ) internal {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            AcceptedInvoiceToken ait = registry.getAcceptedInvoiceToken();\n            ait.beginFinancing(_tokenIds[i], _agreementId);\n        }\n    }\n*/\n\n    /**\n     * Helper function that mints LAT associated with the\n     * given issuance and grants it to the beneficiary (creditor).\n     */\n    function _issueDebtAgreement(\n        address beneficiary,\n        DebtOrder memory debtOrder\n    ) internal {\n        uint256[3] memory valueParams = [\n            debtOrder.minCollateralRatio,\n            debtOrder.expirationTimestampInSec,\n            debtOrder.issuance.salt\n        ];\n\n        InvoiceDebtRegistry debtRegistry = registry.getInvoiceDebtRegistry();\n        bytes32 entryHash = debtRegistry.insert(\n            debtOrder.issuance.version, // version\n            beneficiary, // beneficiary\n            debtOrder.issuance.debtor, // debtor\n            debtOrder.issuance.termsContract, // term contract\n            debtOrder.principalToken,\n            debtOrder.issuance.termsContractParameters,\n            debtOrder.issuance.invoiceTokenIds,\n            valueParams\n        );\n        registry.getLoanAssetToken().mint(beneficiary, uint256(entryHash));\n\n        require(\n            entryHash == debtOrder.issuance.agreementId,\n            \"Newly minted token's Id is different with agreement Id.\"\n        );\n    }\n\n    /**\n     * Fills a given debt order if it is valid and consensual.\n     */\n    function fillDebtOrder(\n        address creditor,\n        address[5] calldata orderAddresses, // 0-repayment router, 1-debtor, 2-termcontract, 3-principalTokenAddress, 4-relayer\n        uint256[6] calldata orderValues, // 0-salt, 1-principalAmount, 2-creditorFee, 3-debtorFee, 4-expirationTimestampInSec, 5-minCR\n        bytes32[] calldata orderBytes32, // 0-termsContractParameters, 1-x -invoiceTokenIdBytes32\n        uint8[2] calldata signaturesV, // 1-debtorSignatureV, 2-creditorSignatureV\n        bytes32[2] calldata signaturesR, // 1-debtorSignatureR, 2-creditorSignatureR\n        bytes32[2] calldata signaturesS, // 1-debtorSignatureS, 2-creditorSignatureS,\n        address[10] calldata feeBeneficiaries,\n        uint256[10] calldata feeAmounts\n    ) external whenNotPaused returns (bytes32 _agreementId) {\n        DebtOrder memory debtOrder = _getDebtOrder(\n            orderAddresses,\n            orderValues,\n            orderBytes32\n        );\n\n        //_assertDebtOrderConsensualityInvariants\n        if (!_assertDebtOrderValidityInvariants(debtOrder)) {\n            revert('InvoiceLoanDebtKernel: Invalid debt order or lacking of approval');\n        }\n\n        // Mint debt token and finalize debt agreement\n        _issueDebtAgreement(creditor, debtOrder);\n\n        // Register debt agreement's start with terms contract\n        // We permit terms contracts to be undefined (for debt agreements which\n        // may not have terms contracts associated with them), and only\n        // register a term's start if the terms contract address is defined.\n        if (debtOrder.issuance.termsContract != address(0x0)) {\n            require(\n                InvoiceFinanceInterestTermsContract(\n                    debtOrder\n                        .issuance\n                        .termsContract\n                )\n                    .registerInvoiceLoanTermStart(\n                    debtOrder.issuance.agreementId,\n                    debtOrder.issuance.debtor\n                ),\n                'Register terms start was failed.'\n            );\n        }\n\n        _transferTokensLoanIssuance(\n            debtOrder,\n            creditor,\n            feeBeneficiaries,\n            feeAmounts\n        );\n\n/*\n        _changeInvoiceFinancingState(\n            debtOrder.issuance.invoiceTokenIds,\n            debtOrder.issuance.agreementId\n        );\n*/\n\n        emit LogDebtOrderFilled(\n            debtOrder.issuance.agreementId,\n            debtOrder.principalAmount,\n            debtOrder.principalToken,\n            debtOrder.relayer\n        );\n\n        return debtOrder.issuance.agreementId;\n    }\n\n    function drawdownLoan(\n        bytes32 agreementId,\n        uint256 drawdownAmount,\n        bytes32 termsContractParameters,\n        uint8[2] memory signaturesV, // 1-debtorSignatureV, 2-creditorSignatureV\n        bytes32[2] memory signaturesR, // 1-debtorSignatureR, 2-creditorSignatureR\n        bytes32[2] memory signaturesS // 1-debtorSignatureS, 2-creditorSignatureS\n    ) public whenNotPaused {\n        //_assertDebtOrderConsengualityInvariants check signature\n\n        InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n        require(\n            invoiceDebtRegistry.doesEntryExist(agreementId),\n            'Agreement not existed'\n        );\n\n        require(\n                registry.getInvoiceFinanceInterestTermsContract()\n                .registerDrawdownLoan(\n                agreementId,\n                drawdownAmount,\n                termsContractParameters\n            ),\n            'Register drawdown was failed'\n        );\n\n        // Transfer drawdown amount to debtor\n        address creditor = invoiceDebtRegistry.getBeneficiary(agreementId);\n        address debtor = invoiceDebtRegistry.getDebtor(agreementId);\n        address fiatTokenAddress = invoiceDebtRegistry.getAgreement(agreementId).principalTokenAddress;\n        require(\n            fiatTokenAddress != address(0),\n            'Token address must different with NULL.'\n        );\n\n        require(\n            IERC20(fiatTokenAddress)\n                .transferFrom(\n                creditor,\n                debtor,\n                drawdownAmount\n            ),\n            'Unsuccessfully transferred drawdown amount to Debtor.'\n        );\n    }\n\n    function secureLoanWithInvoice(\n        bytes32 agreementId,\n        address termsContract,\n        address debtor,\n        address collateral,\n        bytes32[] memory invoiceTokenIds\n    ) public whenNotPaused {\n\n        require(\n            InvoiceFinanceInterestTermsContract(termsContract)\n                .registerSecureLoanWithInvoice(\n                agreementId,\n                debtor,\n                collateral,\n                invoiceTokenIds\n            ),\n            'InvoiceFinanceInterestTermsContract: Register secure loan with invoice was failed.'\n        );\n\n//        _changeInvoiceFinancingState(invoiceTokenIds, agreementId);\n    }\n\n    function insecureLoanByWithdrawInvoice(\n        bytes32 agreementId,\n        address termsContract,\n        address collateral,\n        bytes32[] memory invoiceTokenIds\n    ) public whenNotPaused {\n\n        require(\n            InvoiceFinanceInterestTermsContract(termsContract)\n                .registerInsecureLoanByWithdrawInvoice(\n                agreementId,\n                msg.sender,\n                collateral,\n                invoiceTokenIds\n            ),\n            'InvoiceFinanceInterestTermsContract: Register insecure loan by withdraw invoice was failed.'\n        );\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/protocol/loan/invoice/InvoiceLoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./InvoiceFinanceInterestTermsContract.sol\";\nimport \"./InvoiceDebtRegistry.sol\";\nimport \"../../../storage/Registry.sol\";\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\n\n/**\n* The RepaymentRouter routes allowers payers to make repayments on any\n* given debt agreement in any given token by routing the payments to\n* the debt agreement's beneficiary.  Additionally, the router acts\n* as a trusted oracle to the debt agreement's terms contract, informing\n* it of exactly what payments have been made in what quantity and in what token.\n*/\ncontract InvoiceLoanRepaymentRouter is PausableUpgradeable, OwnableUpgradeable {\n\n    using ConfigHelper for Registry;\n    Registry public registry;\n\n    enum Errors {\n        DEBT_AGREEMENT_NONEXISTENT,\n        PAYER_BALANCE_OR_ALLOWANCE_INSUFFICIENT,\n        REPAYMENT_REJECTED_BY_TERMS_CONTRACT\n    }\n\n    event LogRepayment(\n        bytes32 indexed _agreementId,\n        address indexed _payer,\n        address indexed _beneficiary,\n        uint _amount,\n        address _token\n    );\n\n    event LogError(uint8 indexed _errorId, bytes32 indexed _agreementId);\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n    // Validate repayment request parametters\n    function _assertRepaymentRequest(bytes32 _agreementId, address _payer, uint256 _amount, address _tokenAddress)\n        internal view\n    {\n        require(_tokenAddress != address(0), \"Token address must different with NULL.\");\n        require(_amount > 0, \"Amount must greater than 0.\");\n\n        // Ensure agreement exists.\n        require(\n            registry.getInvoiceDebtRegistry().doesEntryExist(_agreementId),\n            \"Inventory Debt Registry: Agreement Id does not exists.\"\n        );\n    }\n\n\n    function _doRepay(bytes32 _agreementId, address _payer, uint256 _amount, address _tokenAddress)\n        internal\n    {\n        // Notify terms contract\n        InvoiceDebtRegistry invoiceDebtRegistry = registry.getInvoiceDebtRegistry();\n        address termsContract = invoiceDebtRegistry.getTermsContract(_agreementId);\n        address beneficiary = invoiceDebtRegistry.getBeneficiary(_agreementId);\n        address debtor = invoiceDebtRegistry.getDebtor(_agreementId);\n\n        uint remains = InvoiceFinanceInterestTermsContract(termsContract).registerRepayment(\n            _agreementId,\n            _payer,\n            beneficiary,\n            _amount,\n            _tokenAddress\n        );\n\n        // Transfer amount to creditor\n        require(\n            IERC20(_tokenAddress).transferFrom(_payer, beneficiary, _amount - remains),\n            \"Unsuccessfully transferred repayment amount to Creditor.\");\n\n        // Transfer remain amount to debtor\n        if (debtor != _payer && remains > 0) {\n            require(\n                IERC20(_tokenAddress).transferFrom(_payer, debtor, remains),\n                \"Unsuccessfully transferred remain repayment amount to Debtor.\"\n            );\n        }\n\n        // Log event for repayment\n        emit LogRepayment(_agreementId, _payer, beneficiary, _amount, _tokenAddress);\n    }\n\n\n    /**\n     */\n    function repayFromInvoicePayment(\n        bytes32 agreementId,\n        address payer,\n        uint256 amount,\n        address tokenAddress\n    )\n        public\n        whenNotPaused\n        returns (uint)\n    {\n        _assertRepaymentRequest(agreementId, payer, amount, tokenAddress);\n        _doRepay(agreementId, payer, amount, tokenAddress);\n        return amount;\n    }\n\n    // Mannual repay by using Fiat tokens\n    function repay(bytes32 agreementId, address payer, uint256 amount, address tokenAddress)\n        public\n        whenNotPaused\n        returns (uint)\n    {\n        _assertRepaymentRequest(agreementId, payer, amount, tokenAddress);\n        _doRepay(agreementId, payer, amount, tokenAddress);\n        return amount;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/tokens/ERC20/NoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../interfaces/INoteToken.sol';\n\ncontract NoteToken is INoteToken {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 _decimals,\n        address _poolAddress,\n        uint8 _noteTokenType\n    ) ERC20PresetMinterPauser(name, symbol) {\n        _d = _decimals;\n        poolAddress = _poolAddress;\n        noteTokenType = _noteTokenType;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _d;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"../extensions/ERC721BurnableUpgradeable.sol\";\nimport \"../extensions/ERC721PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC721PresetMinterPauserAutoIdUpgradeable is\n    Initializable, ContextUpgradeable,\n    AccessControlEnumerableUpgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721BurnableUpgradeable,\n    ERC721PausableUpgradeable\n{\n    function initialize(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) public virtual initializer {\n        __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);\n    }\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    CountersUpgradeable.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n     * See {ERC721-tokenURI}.\n     */\n    function __ERC721PresetMinterPauserAutoId_init(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __ERC721_init_unchained(name, symbol);\n        __Pausable_init_unchained();\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __ERC721PresetMinterPauserAutoId_init_unchained(\n        string memory,\n        string memory,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        _baseTokenURI = baseTokenURI;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/UntangledMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary UntangledMath {\n    uint256 public constant ONE = 10**27;\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/presets/ERC1155PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../extensions/ERC1155BurnableUpgradeable.sol\";\nimport \"../extensions/ERC1155PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC1155} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC1155PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC1155BurnableUpgradeable, ERC1155PausableUpgradeable {\n    function initialize(string memory uri) public virtual initializer {\n        __ERC1155PresetMinterPauser_init(uri);\n    }\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that\n     * deploys the contract.\n     */\n    function __ERC1155PresetMinterPauser_init(string memory uri) internal onlyInitializing {\n        __ERC1155_init_unchained(uri);\n        __Pausable_init_unchained();\n        __ERC1155PresetMinterPauser_init_unchained(uri);\n    }\n\n    function __ERC1155PresetMinterPauser_init_unchained(string memory) internal onlyInitializing {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     */\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerableUpgradeable, ERC1155Upgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155Upgradeable, ERC1155PausableUpgradeable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n */\nabstract contract ERC1155SupplyUpgradeable is Initializable, ERC1155Upgradeable {\n    function __ERC1155Supply_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Supply_init_unchained() internal onlyInitializing {\n    }\n    mapping(uint256 => uint256) private _totalSupply;\n\n    /**\n     * @dev Total amount of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /**\n     * @dev Indicates whether any token exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155SupplyUpgradeable.totalSupply(id) > 0;\n    }\n\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] -= amounts[i];\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {\n    function __ERC1155Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {\n    function __ERC1155Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC1155Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ISupplyChainManagementProgram.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\nabstract contract ISupplyChainManagementProgram is Initializable, PausableUpgradeable, AccessControlEnumerableUpgradeable {\n    Registry public registry;\n\n    bytes32 public constant PRICE_FEED_ROLE = keccak256('PRICE_FEED_ROLE');\n    bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\n\n    mapping(uint256 => CollateralProject) public collateralProjects;\n    mapping(uint256 => bool) public isExistingProjects;\n\n    mapping(uint256 => mapping(address => bool)) public projectToLenders;\n    mapping(uint256 => mapping(address => bool)) public projectToTraders;\n    mapping(uint256 => mapping(address => bool)) public projectToExecutors;\n    mapping(address => bool) public isExistingManager;\n\n    //Id of project -> id of project-commodity => existed\n    mapping(uint256 => mapping(uint256 => bool)) public projectToExistedProjectCommodity;\n    //Id of project -> bytes32 of movement\n    mapping(uint256 => mapping(bytes32 => Movement)) public projectToMovements;\n    mapping(uint256 => mapping(bytes32 => bool)) public projectToExistedMovements;\n\n    //Id of project-commodity- => price\n    mapping(uint256 => uint256) public projectCommodityToPrice;\n    //Id of project-commodity => list agreements id\n    mapping(uint256 => bytes32[]) public projectCommodityToAgreements;\n    //Id of project-commodity -> commodity symbol hash\n    mapping(uint256 => bytes32) public projectCommodityToCommodity;\n    //Id of project-commodity -> project id\n    mapping(uint256 => uint256) public projectCommodityToProject;\n\n    struct CollateralProject {\n        address managerAddress;\n        address projectWallet;\n        bytes32 companyHash;\n    }\n\n    enum MovementState {INITIATED, APPROVED, EXECUTED}\n    enum MovementType {UNKNOWN, DEPOSIT, WITHDRAW}\n\n    struct Movement {\n        uint256 projectCommodityId;\n        MovementType movementType;\n        MovementState state;\n        uint quantity;\n        address initiator;\n        address approver;\n        address executor;\n    }\n\n    function initialize(\n        Registry _registry\n    ) public virtual;\n\n    //************  */\n    // EXTERNAL\n    //************  *\n    // Create new CMA project\n    function newProject(\n        uint256 projectId,\n        string memory companyId,\n        address projectWallet\n    ) public virtual;\n\n    function updateCompanyId(uint256 projectId, string memory companyId) public virtual;\n\n    function addCommodity(\n        uint256 projectId,\n        uint256 projectCommodityId,\n        string memory commodity,\n        uint256 initBalance\n    ) public virtual;\n\n    // Add Trader for CMA project\n    function addTrader(uint256 projectId, address trader)\n    public virtual;\n\n    // Add Lender for CMA project\n    function addLender(uint256 projectId, address lender)\n    public virtual;\n\n    // Add Executor for CMA project\n    function addExecutor(uint256 projectId, address executor)\n    public virtual;\n\n    // Remove Trader for CMA project\n    /** @dev NOTE: delete array element but still occupy storage space */\n    function removeTrader(uint256 projectId, address trader)\n    public virtual;\n\n    // Remove Lender for CMA project\n    function removeLender(uint256 projectId, address lender)\n    public virtual;\n\n    // Remove Executor for CMA project\n    function removeExecutor(uint256 projectId, address executor)\n    public virtual;\n\n    function isTrader(uint256 projectId, address account) public view virtual returns (bool);\n\n    function isLender(uint256 projectId, address account) public view virtual returns (bool);\n\n    function isExecutor(uint256 projectId, address account) public view virtual returns (bool);\n\n    function initMovement(\n        string memory movementId,\n        uint256 projectId,\n        uint256 projectCommodityId,\n        uint8 _movementType\n    ) public virtual;\n\n    function approveMovement(\n        string memory movementId,\n        uint256 projectId\n    ) public virtual;\n\n    function executeMovement(\n        string memory movementId,\n        uint256 projectId,\n        uint _quantity\n    ) public virtual;\n\n    function updateStateMovement(\n        string memory movementId,\n        uint256 projectId,\n        MovementState _movementState,\n        uint _quantity,\n        address caller\n    ) public virtual;\n\n    function isProjectExisting(uint256 projectId) public view virtual returns (bool);\n\n    /**\n    * @dev NOTE: memory & public is not recommeneded for function which have input param is arrays, calldata & external function instead\n     */\n    function bulkInsertCompletedMovement(\n        bytes32[] memory movementIdsHashes,\n        uint256[] memory projectIds,\n        uint256[] memory projectCommodityIds,\n        uint8[] memory movementTypes,\n        address[] memory traders,\n        address[] memory executors,\n        uint[] memory quantities\n    ) public virtual;\n\n    function addExistedBalance(\n        uint256 projectId,\n        uint256 projectCommodityId,\n        address trader,\n        uint quantity\n    ) public virtual;\n\n    function removeExistedBalance(\n        uint256 projectId,\n        uint256 projectCommodityId,\n        address trader,\n        uint quantity\n    ) public virtual;\n\n    function getCommodityPrice(uint256 projectCommodityId) public view virtual returns (uint256);\n\n    function updateCommodityPrice(uint256 projectCommodityId, uint256 price) public virtual;\n\n    function insertAgreementToCommodity(uint256 projectCommodityId, bytes32 agreementId) public virtual;\n\n    function removeAgreementFromCommodity(uint256 projectCommodityId, bytes32 agreementId) public virtual;\n\n    function getAgreementsOfProjectCommodity(uint256 projectCommodityId) public view virtual returns (bytes32[] memory);\n\n/*\n    function getProjectDetail(uint256 projectId) public view virtual\n    returns (address managerAddress, address projectWallet, bytes32 companyHash);\n*/\n\n/*\n    function getMovementDetail(string memory movementId, uint256 projectId) public view virtual\n    returns (\n        uint256 projectCommodityId,\n        MovementType movementType,\n        MovementState state,\n        uint256 quantity,\n        address initiator,\n        address approver,\n        address executor\n    );\n*/\n\n/*\n    function getProjectCommodityDetail(uint256 projectCommodityId) public view virtual\n    returns (\n        uint256 projectId,\n        uint256 price,\n        bytes32 commoditySymbol\n    );\n*/\n\n}"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/IERC1155.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "contracts/tokens/ERC721/invoice/AcceptedInvoiceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol';\nimport '../../../interfaces/ISecuritizationPool.sol';\nimport '../../../interfaces/IUntangledERC721.sol';\nimport '../../../libraries/ConfigHelper.sol';\n\n/**\n * UntangledAcceptedInvoiceToken: The representative for a payment responsibility\n */\ncontract AcceptedInvoiceToken is IUntangledERC721 {\n    using ConfigHelper for Registry;\n\n    bytes32 public constant INVOICE_CREATOR_ROLE = keccak256(\"INVOICE_CREATOR_ROLE\");\n\n    struct InvoiceMetaData {\n        address payer;\n        uint256 fiatAmount;\n        uint256 paidAmount;\n        address fiatTokenAddress;\n        uint256 dueDate;\n        uint256 createdAt;\n        uint8 riskScoreIdx;\n        Configuration.ASSET_PURPOSE assetPurpose;\n    }\n\n    mapping(bytes32 => InvoiceMetaData) public entries;\n\n    /** CONSTRUCTOR */\n    function initialize(\n        Registry _registry,\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) public initializer {\n        __UntangledERC721__init(name, symbol, baseTokenURI);\n        registry = _registry;\n    }\n\n    //////////////////////////////\n    // PRIVATE Functions     ///\n    /////////////////////////////\n\n    //** */\n    function _generateEntryHash(\n        address _payer,\n        address _receiver,\n        uint256 _fiatAmount,\n        uint256 _dueDate,\n        uint256 _salt\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_payer, _receiver, _fiatAmount, _dueDate, _salt));\n    }\n\n    function _transferTokensFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        if (registry.getSecuritizationManager().isExistingPools(to)) to = ISecuritizationPool(to).pot();\n        return IERC20(token).transferFrom(from, to, amount);\n    }\n\n    function createBatch(\n        address[] calldata addressPayerAndReceiver,\n        // address[] calldata addressReceiver,\n        uint256[] calldata _fiatAmount,\n        address[] calldata _fiatTokenAddress,\n        uint256[] calldata _dueDate,\n        uint256[] calldata salt,\n        uint8[] calldata riskScoreIdxsAndAssetPurpose //[...riskScoreIdxs, assetPurpose]\n    ) external whenNotPaused {\n        require(\n            hasRole(INVOICE_CREATOR_ROLE, _msgSender()),\n            'not permission to create token'\n        );\n\n        Configuration.ASSET_PURPOSE assetPurpose = Configuration.ASSET_PURPOSE(\n            riskScoreIdxsAndAssetPurpose[_fiatAmount.length - 1]\n        );\n        for (uint256 i = 0; i < _fiatAmount.length; ++i) {\n            _createAIT(\n                addressPayerAndReceiver[i],\n                addressPayerAndReceiver[i + _fiatAmount.length],\n                _fiatAmount[i],\n                _fiatTokenAddress[i],\n                _dueDate[i],\n                salt[i],\n                riskScoreIdxsAndAssetPurpose[i],\n                assetPurpose\n            );\n        }\n    }\n\n    function payInBatch(uint256[] calldata tokenIds, uint256[] calldata payAmounts) external returns (bool) {\n        require(tokenIds.length == payAmounts.length, 'Length miss match');\n\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            require(!isPaid(tokenIds[i]), 'AIT: Invoice is already paid');\n\n            InvoiceMetaData storage metadata = entries[bytes32(tokenIds[i])];\n\n            ERC20PresetMinterPauser token = ERC20PresetMinterPauser(entries[bytes32(tokenIds[i])].fiatTokenAddress);\n\n            require(token.balanceOf(msg.sender) >= payAmounts[i], 'Not enough balance');\n\n            uint256 fiatAmountRemain = 0;\n            if (metadata.fiatAmount > (payAmounts[i] + metadata.paidAmount)) {\n                fiatAmountRemain = metadata.fiatAmount - metadata.paidAmount - payAmounts[i];\n            }\n\n            _transferTokensFrom(metadata.fiatTokenAddress, msg.sender, ownerOf(tokenIds[i]), payAmounts[i]);\n\n            if (fiatAmountRemain == 0) {\n                metadata.paidAmount += payAmounts[i];\n                super._burn(tokenIds[i]);\n            } else {\n                metadata.paidAmount += payAmounts[i];\n            }\n\n            emit LogRepayment(tokenIds[i], msg.sender, ownerOf(tokenIds[i]), payAmounts[i], metadata.fiatTokenAddress);\n        }\n\n        emit LogRepayments(tokenIds, msg.sender, payAmounts);\n        return true;\n    }\n\n    /**=--------- */\n    // CALL\n    /**=--------- */\n    function _createAIT(\n        address payer,\n        address receiver,\n        uint256 _fiatAmount,\n        address _fiatTokenAddress,\n        uint256 _dueDate,\n        uint256 salt,\n        uint8 _riskScoreIdx,\n        Configuration.ASSET_PURPOSE _assetPurpose\n    ) private returns (uint256) {\n        bytes32 entryHash = _generateEntryHash(payer, receiver, _fiatAmount, _dueDate, salt);\n\n        entries[entryHash] = InvoiceMetaData({\n            payer: payer,\n            fiatAmount: _fiatAmount,\n            paidAmount: 0,\n            fiatTokenAddress: _fiatTokenAddress,\n            dueDate: _dueDate,\n            createdAt: block.timestamp,\n            riskScoreIdx: _riskScoreIdx,\n            assetPurpose: _assetPurpose\n        });\n\n        mint(receiver, uint256(entryHash));\n\n        return uint256(entryHash);\n    }\n\n    function getExpectedRepaymentValues(uint256 tokenId, uint256) public view returns (uint256, uint256) {\n        return (entries[bytes32(tokenId)].fiatAmount - entries[bytes32(tokenId)].paidAmount, 0);\n    }\n\n    function getTotalExpectedRepaymentValue(uint256 agreementId, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 expectedRepaymentValue)\n    {\n        uint256 principalAmount;\n        uint256 interestAmount;\n        (principalAmount, interestAmount) = getExpectedRepaymentValues(agreementId, timestamp);\n        expectedRepaymentValue = principalAmount + interestAmount;\n    }\n\n    function getExpirationTimestamp(uint256 _tokenId) public view override returns (uint256) {\n        return entries[bytes32(_tokenId)].dueDate;\n    }\n\n    function getInterestRate(uint256 _tokenId) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function getAssetPurpose(uint256 _tokenId) public view override returns (Configuration.ASSET_PURPOSE) {\n        return entries[bytes32(_tokenId)].assetPurpose;\n    }\n\n    function getRiskScore(uint256 _tokenId) public view override returns (uint8) {\n        return entries[bytes32(_tokenId)].riskScoreIdx;\n    }\n\n    function getFiatAmount(uint256 tokenId) public view returns (uint256) {\n        return entries[bytes32(tokenId)].fiatAmount;\n    }\n\n    function isPaid(uint256 tokenId) public view returns (bool) {\n        return entries[bytes32(tokenId)].fiatAmount <= entries[bytes32(tokenId)].paidAmount;\n    }\n\n    event LogRepayment(\n        uint256 indexed _tokenId,\n        address indexed _payer,\n        address indexed _beneficiary,\n        uint256 _amount,\n        address _token\n    );\n\n    event LogRepayments(uint256[] _tokenIds, address _payer, uint256[] _amounts);\n}\n"
    },
    "contracts/libraries/UnpackLoanParamtersLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.10;\n\nlibrary UnpackLoanParamtersLib {\n    struct InterestParams {\n        uint256 principalAmount;\n        uint256 termStartUnixTimestamp;\n        uint256 termEndUnixTimestamp;\n        AmortizationUnitType amortizationUnitType;\n        uint256 termLengthInAmortizationUnits;\n        // interest rates can, at a maximum, have 4 decimal places of precision.\n        uint256 interestRate;\n    }\n\n    enum AmortizationUnitType {\n        MINUTES, // 0 - since 1.0.13\n        HOURS, // 1\n        DAYS, // 2\n        WEEKS, // 3\n        MONTHS, // 4\n        YEARS // 5\n    }\n\n    /**\n     *\n     * Notice: * uint256 (a) reinterprets a as 256-bit unsigned integer. As long as 256 bit = 32 bytes\n     */\n    function _bitShiftRight(bytes32 value, uint256 amount) internal pure returns (uint256) {\n        return uint256(value) / 2**amount;\n    }\n\n    /**\n     * Unpack parameters from packed bytes32 data\n     */\n    function _unpackLoanTermsParametersFromBytes(bytes32 parameters)\n        internal\n        pure\n        returns (\n            uint256 _principalAmount,\n            uint256 _interestRate,\n            uint256 _amortizationUnitType,\n            uint256 _termLengthInAmortizationUnits,\n            uint256 _gracePeriodInDays\n        )\n    {\n        // The subsequent 12 bytes of the parameters encode the PRINCIPAL AMOUNT.\n        bytes32 principalAmountShifted = parameters &\n            0x00ffffffffffffffffffffffff00000000000000000000000000000000000000;\n        // The subsequent 3 bytes of the parameters encode the INTEREST RATE.\n        bytes32 interestRateShifted = parameters & 0x00000000000000000000000000ffffff00000000000000000000000000000000;\n        // The subsequent 4 bits (half byte) encode the AMORTIZATION UNIT TYPE code.\n        bytes32 amortizationUnitTypeShifted = parameters &\n            0x00000000000000000000000000000000f0000000000000000000000000000000;\n        // The subsequent 12 bytes encode the term length, as denominated in\n        // the encoded amortization unit.\n        bytes32 termLengthInAmortizationUnitsShifted = parameters &\n            0x000000000000000000000000000000000ffffffffffffffffffffffff0000000;\n\n        bytes32 gracePeriodInDaysShifted = parameters &\n            0x000000000000000000000000000000000000000000000000000000000ff00000;\n\n        return (\n            _bitShiftRight(principalAmountShifted, 152),\n            _bitShiftRight(interestRateShifted, 128),\n            _bitShiftRight(amortizationUnitTypeShifted, 124),\n            _bitShiftRight(termLengthInAmortizationUnitsShifted, 28),\n            _bitShiftRight(gracePeriodInDaysShifted, 20)\n        );\n    }\n\n    /**\n     * Unpack data from hex string which including informations about Loan\n     */\n    function unpackParametersFromBytes(bytes32 parameters)\n        internal\n        pure\n        returns (\n            uint256 _principalAmount,\n            uint256 _interestRate,\n            uint256 _amortizationUnitType,\n            uint256 _termLengthInAmortizationUnits,\n            uint256 _gracePeriodInDays\n        )\n    {\n        return _unpackLoanTermsParametersFromBytes(parameters);\n    }\n}\n"
    },
    "contracts/protocol/loan/LoanTyping.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ncontract LoanTyping {\n\n    enum LoanTypes {\n        WAREHOUSE_RECEIPT,\n        INPUT_FINANCE,\n        INVOICE_FINANCE,\n        INVENTORY_FINANCE\n    }\n}"
    },
    "contracts/libraries/Unpack.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary Unpack {\n\n    function unpackPrincipalAmount(bytes32 term) internal\n    pure\n    returns (uint) {\n        return uint(term & 0x00ffffffffffffffffffffffff00000000000000000000000000000000000000) >> 152;\n    }\n\n    function unpackInterestRate(bytes32 term) internal\n    pure\n    returns (uint) {\n        return uint(term & 0x00000000000000000000000000ffffff00000000000000000000000000000000) >> 128;\n    }\n\n    function unpackAmortizationUnitType(bytes32 term) internal\n    pure\n    returns (uint) {\n        return uint(term & term & 0x00000000000000000000000000000000f0000000000000000000000000000000) >> 124;\n    }\n\n    function unpackTermLengthInAmortizationUnits(bytes32 term) internal\n    pure\n    returns (uint) {\n        return uint(term & term & 0x000000000000000000000000000000000ffffffffffffffffffffffff0000000) >> 28;\n    }\n\n    function unpackGracePeriodInDays(bytes32 term) internal\n    pure\n    returns (uint gracePeriodInDays) {\n        return uint(term & term & 0x000000000000000000000000000000000000000000000000000000000ff00000) >> 20;\n    }\n}\n"
    },
    "contracts/libraries/Unpack16.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary Unpack16 {\n\n    function unpackCollateralTokenId(bytes16 collateralParams) internal\n    pure\n    returns (uint) {\n        return uint(uint128(collateralParams) & 0xffffffff000000000000000000000000) >> 96;\n    }\n\n    function unpackCollateralAmount(bytes16 collateralParams) internal\n    pure\n    returns (uint) {\n        return uint(uint128(collateralParams) & 0x00000000ffffffffffffffffffffffff);\n    }\n}\n"
    },
    "contracts/protocol/loan/inventory/CRInventoryDecisionEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../../libraries/SignaturesLib.sol\";\n\ncontract CRInventoryDecisionEngine is SignaturesLib {\n    using SafeMath for uint;\n\n    uint public constant PRICE_PRECISION = 4; //Number decimals for price of collateral token\n    uint public constant CR_PRECISION = 2; //Number decimals for collateral ratio\n\n    uint public constant MAX_PRICE_TTL_IN_SECONDS = 300;\n\n    // These values must be dynamic in future, query from token information in registry\n    uint public COLLATERAL_PRECISION = 3; // Number decimals of CMA token\n    uint public PRINCIPAL_PRECISION = 2; // Number decimals of FAT\n\n    uint256 constant MAX_UINT256 = ~uint256(0);\n\n    //==============================\n    // Internal funcs\n    //==============================\n    function _computeCR(\n        uint _collateralAmount,\n        uint _price,\n        uint _invoiceAmount,\n        uint _principalAmount\n    )\n        internal view returns (uint)\n    {\n        if (_principalAmount == 0) {\n            return MAX_UINT256;\n        }\n        uint collateralValue = (_price.mul(_collateralAmount) + _invoiceAmount.mul(10 ** (PRICE_PRECISION - PRINCIPAL_PRECISION)).mul(10 ** COLLATERAL_PRECISION))\n                                    .mul(10 ** PRINCIPAL_PRECISION).mul(10 ** CR_PRECISION).mul(10 ** 2);\n        uint principalValue = _principalAmount.mul(10 ** COLLATERAL_PRECISION).mul(10 ** PRICE_PRECISION);\n        return collateralValue.div(principalValue);\n    }\n\n    function _computeCR(uint _collateralAmount, uint _principalAmount) internal view returns (uint) {\n        uint collateralValue = _collateralAmount.mul(10 ** PRINCIPAL_PRECISION).mul(10 ** CR_PRECISION).mul(10 ** 2);\n        return collateralValue.div(_principalAmount);\n    }\n\n    // Compute commodity value in principal decimals number\n    function _computePriceValue(\n        uint _collateralAmount,\n        uint _price\n    ) internal view returns (uint) {\n        return _price.mul(_collateralAmount).div(10 ** (PRICE_PRECISION - PRINCIPAL_PRECISION + COLLATERAL_PRECISION));\n    }\n\n    // Compute require principal value to satisfy min collateral ratio\n    function _computePrincipalValueRequire(\n        uint _collateralAmount,\n        uint _price,\n        uint256 invoiceValue,\n        uint256 minCollateralRatio\n    ) internal view returns (uint) {\n        return _price.mul(_collateralAmount).mul(10 ** CR_PRECISION).mul(10 ** 2).div(10 ** (PRICE_PRECISION - PRINCIPAL_PRECISION + COLLATERAL_PRECISION))\n            .div(minCollateralRatio) + invoiceValue.mul(10 ** CR_PRECISION).mul( 10 ** 2).div(minCollateralRatio);\n    }\n\n    /**\n    * @dev TODO: Verify Operator's signature here\n    */\n    function _verifyPrice(uint _timestamp) internal view returns(bool) {\n        uint minPriceTimestamp = uint(block.timestamp).sub(MAX_PRICE_TTL_IN_SECONDS);\n        if (_timestamp < minPriceTimestamp) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "contracts/libraries/SignaturesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SignaturesLib {\n\n    bytes constant internal PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\n\n    struct ECDSASignature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n    public\n    pure\n    returns (bool valid)\n    {\n        bytes32 prefixedHash = keccak256(abi.encodePacked(PREFIX, hash));\n        return ecrecover(prefixedHash, v, r, s) == signer;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "contracts/protocol/loan/invoice/CRDecisionEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../../libraries/SignaturesLib.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract CRDecisionEngine is SignaturesLib {\n    using SafeMath for uint;\n\n    // Maximum 4 decmal places for the price of collteral token\n    uint public constant PRICE_PRECISION = 4;\n    uint public constant CR_PRECISION = 2;\n\n    uint public constant MAX_PRICE_TTL_IN_SECONDS = 300;\n\n    // These values must be dynamic in future, query from token information in registry\n    uint public COLLATERAL_PRECISION = 3; // Number decimals of CAT token\n    uint public PRINCIPAL_PRECISION = 2; // Number decimaals of FAT\n\n    uint256 constant MAX_UINT256 = ~uint256(0);\n\n    //==============================\n    // Internal funcs\n    //==============================\n    function _computeCR(\n        uint _collateralAmount,\n        uint _price,\n        uint _principalAmount\n    )\n        internal view returns (uint)\n    {\n        if (_principalAmount == 0) {\n            return MAX_UINT256;\n        }\n\n        uint collateralValue = _price.mul(_collateralAmount).mul(10 ** PRINCIPAL_PRECISION).mul(10 ** CR_PRECISION).mul(10 ** 2);\n        uint principalValue = _principalAmount.mul(10 ** COLLATERAL_PRECISION).mul(10 ** PRICE_PRECISION);\n        return collateralValue.div(principalValue);\n    }\n\n    function _computeInvoiceCR(uint _collateralAmount, uint _principalAmount) internal view returns (uint) {\n        if (_principalAmount == 0) {\n            return MAX_UINT256;\n        }\n\n        uint collateralValue = _collateralAmount.mul(10 ** PRINCIPAL_PRECISION).mul(10 ** CR_PRECISION).mul(10 ** 2);\n        return collateralValue.div(_principalAmount.mul(10 ** PRINCIPAL_PRECISION));\n    }\n\n    /**\n    * @dev TODO: Verify Operator's signature here\n    */\n    function _verifyPrice(uint _timestamp) internal view returns(bool) {\n        uint minPriceTimestamp = uint(block.timestamp).sub(MAX_PRICE_TTL_IN_SECONDS);\n        if (_timestamp < minPriceTimestamp) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/trade/EReceiptInventoryTradeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './EReceiptInventoryTrade.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport \"../storage/Registry.sol\";\nimport \"../libraries/ConfigHelper.sol\";\n\n/**\n * The Factory to create new E-Receipt Inventory Trade smart contract instance,\n * Notice: This smart contract must be \"isTokenHolderManager\" of FBT token smart contracts, hence it can add new Holder for those tokens\n */\ncontract EReceiptInventoryTradeFactory is Initializable, PausableUpgradeable, OwnableUpgradeable {\n    address public registry;\n\n    // Trade smart contract mapped with Trade ID\n    mapping(string => address) public tradeContracts;\n    mapping(address => bool) public existedTrade;\n    mapping(bytes32 => bool) public isExistingReferenceId;\n\n    modifier onlyIfReferenceIdNotInUse(string memory _referenceId) {\n        bytes32 identifyHash = keccak256(abi.encodePacked(_referenceId));\n        require(\n            !isExistingReferenceId[identifyHash],\n            'Reference Id is not available'\n        );\n        _addReferenceId(identifyHash);\n        _;\n    }\n\n    modifier onlyExistedTrade(address tradeAddress) {\n        require(existedTrade[tradeAddress], 'Trade not existed');\n        _;\n    }\n\n    function _addReferenceId(bytes32 _hashReferenceId) internal {\n        isExistingReferenceId[_hashReferenceId] = true;\n    }\n\n    function initialize(\n        address _registry\n    ) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n        registry = _registry;\n    }\n\n    //-----------------------\n    // SEND\n    //-----------------------\n    // Need to wait util be minned, unable to return contract address\n    function newContract(\n        string calldata tradeId,\n        address[3] calldata tradeAddresses,// TODO note tanlm add buyerPayment tokenaddress to element 2\n        uint256[2] calldata tradeTokenIndexs,\n        uint256[2] calldata tradeAmounts,\n        uint256 expirationTime,\n        uint256[2] calldata loanAmounts // 1.principalAmount 2. debtorFee\n    ) external whenNotPaused onlyOwner onlyIfReferenceIdNotInUse(tradeId) {\n        address[4] memory tradeAddress = [\n            tradeAddresses[0], // seller\n            tradeAddresses[1], // buyer\n            registry,\n            tradeAddresses[2]\n        ];\n        uint256[2] memory tradeNumbers = [tradeAmounts[0], tradeAmounts[1]];\n\n        EReceiptInventoryTrade tradeContract = new EReceiptInventoryTrade();\n\n        tradeContract.initialize(\n            tradeAddress,\n            tradeTokenIndexs,\n            tradeNumbers,\n            expirationTime,\n            loanAmounts\n        );\n\n        // Operator of this Trade: Barter Block\n        tradeContract.transferOwnership(_msgSender());\n\n        tradeContracts[tradeId] = address(tradeContract);\n        existedTrade[address(tradeContract)] = true;\n    }\n\n    //-----------------------\n    // CALL\n    //-----------------------\n    function contractAddressOf(string calldata _tradeId)\n    external\n    view\n    returns (address)\n    {\n        return tradeContracts[_tradeId];\n    }\n\n    function isExistedTrade(address tradeAddress) external view returns (bool) {\n        return existedTrade[tradeAddress];\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    //-----------------------\n    // Interact with other contract\n    //-----------------------\n}\n"
    },
    "contracts/trade/EReceiptInventoryTrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../storage/Registry.sol\";\nimport \"../libraries/ConfigHelper.sol\";\nimport '@openzeppelin/contracts-upgradeable/interfaces/IERC1155ReceiverUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract EReceiptInventoryTrade is Initializable, PausableUpgradeable, OwnableUpgradeable, ERC1155ReceiverUpgradeable {\n    using SafeMath for uint256;\n    using ConfigHelper for Registry;\n\n    Registry public registry;\n\n    struct Fees {\n        uint256 amount;\n        address erc20Token;\n        address beneficiary;\n    }\n\n    // bool internal isHasSetupMandatoryFee = false;\n    bool public isRefundedOptionalFees = false;\n\n    // the existence of beneficiary\n    mapping(address => bool) public isFeePayers;\n    address[] public feePayers;\n\n    // Optional Area\n    mapping(bytes32 => bool) public isOptionalFeeTypeIds;\n    bytes32[] public optionalFeeTypeIds;\n\n    // Mandatory Area\n    mapping(bytes32 => bool) public isMandatoryFeeTypeIds;\n    bytes32[] public mandatoryFeeTypeIds;\n\n    // index -> true/false\n    mapping(address => bool) public isFeeTokens;\n    address[] public feeTokens;\n\n    mapping(address => bool) public isMandatoryFeeTokens;\n    address[] public mandatoryFeeTokens;\n\n    // payer => (fee type id => fee details list)\n    // For now only support 1 beneficiary for 1 type of fee from each payers\n    mapping(address => mapping(bytes32 => Fees)) public requiredFees;\n    mapping(address => mapping(bytes32 => bool)) public hasSetupFees;\n\n    // payer => (token fee index => expected amount)\n    mapping(address => mapping(address => uint256)) public tokenFeeAmounts;\n    // payer => (token fee index => paid amount)\n    mapping(address => mapping(address => uint256)) public paidTokenFeeAmounts;\n\n    // payer => (token fee => released amount)\n    mapping(address => mapping(address => uint256)) releasedTokenAmounts;\n\n    //From EReceiptInventoryTrade contract\n    struct TradePayment {\n        uint256 tokenIndex;\n        uint256 amount;\n        uint256 paidAmount;\n    }\n\n    struct Payment {\n        IERC20 token;\n        uint256 amount;\n        uint256 paidAmount;\n    }\n\n    // Seller\n    address public seller;\n    // Buyer\n    address public buyer;\n\n    uint256 public expirationTime;\n    uint256 public creationTime;\n    uint256 public principalAmount;\n    uint256 public debtorFee;\n    bytes32 public loanAgreementId;\n\n    enum State {Initiated, CompletedPayment, Completed, Aborted, Expired}\n    State public state;\n\n    // Buyer expected&completed payments\n    Payment public buyerPayment;\n\n    // Seller completed&completed payments\n    TradePayment public sellerPayment;\n    //End EReceiptInventoryTrade contract\n\n    //-------------------------------------------\n    // Events\n    //-------------------------------------------\n\n    //-------------------------------------------\n    // Modifiers\n    //-------------------------------------------\n    modifier onlyFeePayer {\n        require(\n            isFeePayers[_msgSender()],\n            \"Fees: Only payer can call to this function.\"\n        );\n        _;\n    }\n\n    // modifier onlyIfHasSetupMandatoryFee {\n    //     require(isHasSetupMandatoryFee, \"Fees: Requires setting up fees before can go any further.\");\n    //     _;\n    // }\n\n    modifier onlyUncompletedTrade() {\n        require(\n            state != State.Completed &&\n            state != State.Aborted &&\n            state != State.Expired,\n            'Only for uncompleted trade'\n        );\n        _;\n    }\n\n    //==============================\n    // Internal functions\n    //==============================\n\n\n    function initialize(\n        address[4] memory tradeAddresses, // 0: seller, 1: buyer, 2: contractRegistry, 3: buyerPayment token address // TODO Note: buyerPayment token address\n        uint256[2] memory tradeTokenIndexs, // 0: cat, 1: cma // TODO not remove index0, not use. use 0x0000 for undefined\n        uint256[2] memory tradeNumbers, // 0: amount fat, 1: amount cma\n        uint256 _expirationTime,\n        uint256[2] memory loanAmounts // 0: principalAmount, 2: debtorFee\n    ) public initializer {\n        __Pausable_init_unchained();\n        __Ownable_init_unchained();\n\n        seller = tradeAddresses[0];\n        buyer = tradeAddresses[1];\n        registry = Registry(tradeAddresses[2]);\n\n        buyerPayment = Payment({\n        token: IERC20(tradeAddresses[3]),\n        amount: tradeNumbers[0],\n        paidAmount: 0\n        });\n\n        sellerPayment = TradePayment({\n        tokenIndex: tradeTokenIndexs[1],\n        amount: tradeNumbers[1],\n        paidAmount: 0\n        });\n\n        creationTime = block.timestamp;\n        principalAmount = loanAmounts[0];\n        debtorFee = loanAmounts[1];\n        expirationTime = _expirationTime;\n        state = State.Initiated;\n    }\n\n    function _isOptionalFeeType(uint256 id) internal view returns (bool) {\n        return isOptionalFeeTypeIds[bytes32(id)];\n    }\n\n    function _isMandatoryFeeType(uint256 id) internal view returns (bool) {\n        return isMandatoryFeeTypeIds[bytes32(id)];\n    }\n\n    function _addPayer(address account) internal {\n        if (!isFeePayers[account]) {\n            feePayers.push(account);\n            isFeePayers[account] = true;\n        }\n    }\n\n    function _addOptionalFeeTypeId(uint256 id) internal {\n        if (!_isOptionalFeeType(id)) {\n            optionalFeeTypeIds.push(bytes32(id));\n            isOptionalFeeTypeIds[bytes32(id)] = true;\n        }\n    }\n\n    function _addMandatoryFeeTypeId(uint256 id) internal {\n        if (!_isMandatoryFeeType(id)) {\n            mandatoryFeeTypeIds.push(bytes32(id));\n            isMandatoryFeeTypeIds[bytes32(id)] = true;\n        }\n    }\n\n    function _addFeeToken(address _erc20Token) internal {\n        if (!isFeeTokens[_erc20Token]) {\n            feeTokens.push(_erc20Token);\n            isFeeTokens[_erc20Token] = true;\n        }\n    }\n\n    function _addMandatoryFeeToken(address _erc20Token) internal {\n        if (!isMandatoryFeeTokens[_erc20Token]) {\n            mandatoryFeeTokens.push(_erc20Token);\n            isMandatoryFeeTokens[_erc20Token] = true;\n        }\n    }\n\n    function _transferFeeToBeneficiary(\n        address payer,\n        uint256 amount,\n        address erc20TokenAddress,\n        address beneficiary\n    ) internal {\n        IERC20(erc20TokenAddress).transfer(beneficiary, amount);\n\n        _newFeeReleaseHasCompleted(payer, amount, erc20TokenAddress);\n    }\n\n    function _transferTokensFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool success) {\n        return\n        IERC20(token).transferFrom(\n            from,\n            to,\n            amount\n        );\n    }\n\n    /**\n    * Setup other additional fees for trading\n    */\n    function _setupFee(\n        uint256 _feeId,\n        address _payer,\n        uint256 _amount,\n        address _erc20Token,\n        address _beneficiary,\n        bool _isMandatory\n    ) internal {\n        Fees memory fee = Fees({\n        amount: _amount,\n        erc20Token: _erc20Token,\n        beneficiary: _beneficiary\n        });\n\n        requiredFees[_payer][bytes32(_feeId)] = fee;\n        hasSetupFees[_payer][bytes32(_feeId)] = true;\n\n        _addPayer(_payer);\n        _addFeeToken(_erc20Token);\n        _setupNewFeePayment(_payer, _amount, _erc20Token);\n        if (_isMandatory) {\n            _addMandatoryFeeTypeId(_feeId);\n            _addMandatoryFeeToken(_erc20Token);\n        } else {\n            _addOptionalFeeTypeId(_feeId);\n        }\n    }\n\n    function _newFeePaymentHasCompleted(\n        address _payer,\n        uint256 _amount,\n        address _erc20Token\n    ) internal {\n        uint256 totalPaid = paidTokenFeeAmounts[_payer][_erc20Token].add(_amount);\n        paidTokenFeeAmounts[_payer][_erc20Token] = totalPaid;\n    }\n\n    function _newFeeReleaseHasCompleted(\n        address _payer,\n        uint256 _amount,\n        address _erc20TokenAddress\n    ) internal {\n        uint256 totalReleased = releasedTokenAmounts[_payer][_erc20TokenAddress].add(\n            _amount\n        );\n        releasedTokenAmounts[_payer][_erc20TokenAddress] = totalReleased;\n    }\n\n    function _setupNewFeePayment(\n        address _payer,\n        uint256 _amount,\n        address _erc20Token\n    ) internal {\n        uint256 totalRequiredAmount = tokenFeeAmounts[_payer][_erc20Token].add(\n            _amount\n        );\n        tokenFeeAmounts[_payer][_erc20Token] = totalRequiredAmount;\n    }\n\n    function _doFeePayment(address _payer, uint256 _amount, address _erc20Token)\n    internal\n    {\n        require(_erc20Token != address(0), \"MultipleFeesTrading: Invalid token address - NULL address.\");\n        if (_transferTokensFrom(_erc20Token, _payer, address(this), _amount)) {\n            _newFeePaymentHasCompleted(_payer, _amount, _erc20Token);\n        }\n    }\n\n    function _isCompletedFeePaymentWithToken(address _payer, address _erc20Token)\n    internal\n    view\n    returns (bool)\n    {\n        return tokenFeeAmounts[_payer][_erc20Token] <= paidTokenFeeAmounts[_payer][_erc20Token];\n    }\n\n    // Refunds all optional tokens fee when Trade instance is ABORTED or EXPIRED\n    function _refundOptionalFees() internal {\n        uint256 payerListLength = feePayers.length;\n        uint256 feeTypesLength = optionalFeeTypeIds.length;\n\n        for (uint256 i = 0; i < payerListLength; i++) {\n            for (uint256 j = 0; j < feeTypesLength; j++) {\n                if (hasSetupFees[feePayers[i]][optionalFeeTypeIds[j]]) {\n                    Fees memory fee = requiredFees[feePayers[i]][optionalFeeTypeIds[j]];\n                    // If paid amount greater than the released amount (IN > OUT)\n                    if (\n                        paidTokenFeeAmounts[feePayers[i]][fee.erc20Token] >\n                        releasedTokenAmounts[feePayers[i]][fee.erc20Token]\n                    ) {\n                        uint256 remainAmount = paidTokenFeeAmounts[feePayers[i]][fee\n                        .erc20Token]\n                        .sub(releasedTokenAmounts[feePayers[i]][fee.erc20Token]);\n\n                        _transferFeeToBeneficiary(\n                            feePayers[i],\n                            remainAmount,\n                            fee.erc20Token,\n                            feePayers[i]\n                        );\n                    }\n                }\n            }\n        }\n        isRefundedOptionalFees = true;\n    }\n\n    // Release optional fees whenever instance has been expired/aborted\n    function _releaseOptionalFees() internal {\n        uint256 feeTypesLength = optionalFeeTypeIds.length;\n        uint256 payerListLength = feePayers.length;\n\n        for (uint256 j = 0; j < feeTypesLength; j++) {\n            for (uint256 i = 0; i < payerListLength; i++) {\n                if (hasSetupFees[feePayers[i]][optionalFeeTypeIds[j]]) {\n                    Fees memory fee = requiredFees[feePayers[i]][optionalFeeTypeIds[j]];\n                    if (\n                        paidTokenFeeAmounts[feePayers[i]][fee.erc20Token] >\n                        releasedTokenAmounts[feePayers[i]][fee.erc20Token]\n                    ) {\n                        uint256 remainAmount = paidTokenFeeAmounts[feePayers[i]][fee.erc20Token]\n                        .sub(releasedTokenAmounts[feePayers[i]][fee.erc20Token]);\n                        if (remainAmount > fee.amount) {\n                            _transferFeeToBeneficiary(\n                                feePayers[i],\n                                fee.amount,\n                                fee.erc20Token,\n                                fee.beneficiary\n                            );\n\n                            _transferFeeToBeneficiary(\n                                feePayers[i],\n                                remainAmount - fee.amount,\n                                fee.erc20Token,\n                                feePayers[i]\n                            );\n                        } else {\n                            _transferFeeToBeneficiary(\n                                feePayers[i],\n                                remainAmount,\n                                fee.erc20Token,\n                                fee.beneficiary\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    // function _releaseMandatoryFees() internal {\n    //     uint feeTypesLength = mandatoryFeeTypeIds.length;\n    //     uint payerListLength = feePayers.length;\n\n    //     for(uint j = 0; j < feeTypesLength; j++) {\n    //         for (uint i = 0; i < payerListLength; i++) {\n    //             if (hasSetupFees[feePayers[i]][mandatoryFeeTypeIds[j]]) {\n    //                 Fees memory fee = requiredFees[feePayers[i]][mandatoryFeeTypeIds[j]];\n    //                 if (paidTokenFeeAmounts[feePayers[i]][fee.token] > releasedTokenAmounts[feePayers[i]][fee.token]) {\n    //                     uint remainAmount = paidTokenFeeAmounts[feePayers[i]][fee.token].sub(releasedTokenAmounts[feePayers[i]][fee.token]);\n    //                     if (remainAmount >= fee.amount) {\n    //                         _transferFeeToBeneficiary(feePayers[i], fee.amount, fee.token, fee.beneficiary);\n    //                     } else {\n    //                         _transferFeeToBeneficiary(feePayers[i], remainAmount, fee.token, fee.beneficiary);\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     }\n    // }\n\n    /**\n    * Transfer fee to corresponding beneficiary\n    */\n    function _transferFeeToBeneficiaries() internal {\n        // _releaseMandatoryFees();\n        if (!isRefundedOptionalFees) {\n            _releaseOptionalFees();\n        }\n    }\n\n    //-------------------------------------------\n    // External functions\n    //-------------------------------------------\n    /**\n    * Setup mandatory fee, which user need to pay regardless what happened with Trade instance\n    */\n    // function setupMandatoryFee(\n    //     uint _feeId,\n    //     address _payer,\n    //     uint _amount,\n    //     address _token,\n    //     address _beneficiary\n    // )\n    //     public\n    //     onlyOwner\n    // {\n    //     _setupFee(_feeId, _payer, _amount, _token, _beneficiary, true);\n    //     isHasSetupMandatoryFee = true;\n    // }\n\n    function setupOptionalFee(\n        uint256 _feeId,\n        address _payer,\n        uint256 _amount,\n        address _erc20Token,\n        address _beneficiary\n    ) public onlyOwner {\n        _setupFee(_feeId, _payer, _amount, _erc20Token, _beneficiary, false);\n    }\n\n    function removeOptionalFee(\n        uint256 _feeId,\n        address _payer,\n        address _erc20Token\n    )  public onlyOwner {\n        require(paidTokenFeeAmounts[_payer][_erc20Token] == 0, \"Payer already paid for fee\");\n\n        delete requiredFees[_payer][bytes32(_feeId)];\n        delete hasSetupFees[_payer][bytes32(_feeId)];\n        delete tokenFeeAmounts[_payer][_erc20Token];\n        delete isOptionalFeeTypeIds[bytes32(_feeId)];\n\n        for (uint i = 0; i < optionalFeeTypeIds.length; ++i) {\n            if (optionalFeeTypeIds[i] == bytes32(_feeId)) {\n\n                // Remove i element from optionalFeeTypeIds\n                for (uint index = i; index < optionalFeeTypeIds.length-1; index++){\n                    optionalFeeTypeIds[index] = optionalFeeTypeIds[index+1];\n                }\n                optionalFeeTypeIds.pop();\n\n                break;\n            }\n        }\n    }\n\n    //---------------\n    // CALL\n    //---------------\n\n    // Have account completed fee payment for his trade, both Mandatory and Optional\n    function isCompletedFeesPayment(address account)\n    public\n    view\n    returns (bool)\n    {\n        uint256 feeTokensLength = feeTokens.length;\n        bool isCompleted = true;\n        for (uint256 i = 0; i < feeTokensLength; i++) {\n            if (!_isCompletedFeePaymentWithToken(account, feeTokens[i])) {\n                isCompleted = false;\n                break;\n            }\n        }\n        return isCompleted;\n    }\n\n    // function isSatisfiedMandatoryFeePayment(address account) {\n    //     uint mandatoryFeeIdsLength = mandatoryFeeTypeIds.length;\n    //     for(uint i = 0; i < mandatoryFeeIdsLength; i++) {\n\n    //     }\n    // }\n\n    function feePaymentStatus(address account)\n    public\n    view\n    returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        uint256 feeTokensLength = feeTokens.length;\n        address[] memory feeTokenAddresses = new address[](feeTokensLength);\n        uint256[] memory expectedAmounts = new uint256[](feeTokensLength);\n        uint256[] memory paidAmounts = new uint256[](feeTokensLength);\n\n        for (uint256 i = 0; i < feeTokensLength; i++) {\n            feeTokenAddresses[i] = feeTokens[i];\n            expectedAmounts[i] = tokenFeeAmounts[account][feeTokens[i]];\n            paidAmounts[i] = paidTokenFeeAmounts[account][feeTokens[i]];\n        }\n\n        return (feeTokenAddresses, expectedAmounts, paidAmounts);\n    }\n\n    function _inState(State _state) internal view returns (bool) {\n        return (state == _state);\n    }\n\n    // Process checking the payment from seller and buyer to change Trade's state\n    function _paymentStatusCheck() internal {\n        if (\n            buyerPayment.paidAmount >= buyerPayment.amount &&\n            sellerPayment.paidAmount >= sellerPayment.amount &&\n            isCompletedFeesPayment(seller) &&\n            isCompletedFeesPayment(buyer)\n        ) {\n            state = State.CompletedPayment;\n        } else {\n            state = State.Initiated;\n        }\n    }\n\n    function _newFiatPayment(uint256 _amount) internal {\n        buyerPayment.paidAmount = SafeMath.add(\n            buyerPayment.paidAmount,\n            _amount\n        );\n    }\n\n    function _newCommodityPayment(uint256 _amount) internal {\n        sellerPayment.paidAmount = SafeMath.add(\n            sellerPayment.paidAmount,\n            _amount\n        );\n    }\n\n    //==============================\n    // External functions\n    //==============================\n    //-------------------\n    // CALL\n    //-------------------\n\n    function expirationTimeLeft() public view returns (uint256) {\n        return SafeMath.sub(expirationTime, SafeMath.sub(block.timestamp, creationTime));\n    }\n\n    function isExpired() public view returns (bool) {\n        if (expirationTime > SafeMath.sub(block.timestamp, creationTime)) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function isCompleted() public view returns (bool) {\n        return (state == State.Completed);\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n    external returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n    external returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n\n    //--------------------------\n    // SEND\n    //--------------------------\n    //=----------------\n    // Function for Controllers\n    //=----------------\n    function setExpirationTime(uint256 _expirationTime)\n    public\n    onlyOwner\n    {\n        expirationTime = _expirationTime;\n    }\n\n    function updateCommodityTokenIndex(uint256 _newIndex)\n    public\n    onlyOwner\n    {\n        sellerPayment.tokenIndex = _newIndex;\n    }\n\n    function updateFiatTokenAddress(address _erc20Token)\n    public\n    onlyOwner\n    {\n        buyerPayment.token = IERC20(_erc20Token);\n    }\n\n    function updateBuyerPaymentAmount(uint256 newPaymentAmount)\n    external\n    onlyOwner\n    {\n        buyerPayment.amount = newPaymentAmount;\n        _paymentStatusCheck();\n    }\n\n    function updateSellerPaymentAmount(uint256 newPaymentAmount)\n    external\n    onlyOwner\n    {\n        sellerPayment.amount = newPaymentAmount;\n        _paymentStatusCheck();\n    }\n\n    function checkExpirationTime() public onlyOwner {\n        if (isExpired()) {\n            state = State.Expired;\n        }\n    }\n\n    function paymentStatusCheck() public {\n        _paymentStatusCheck();\n    }\n\n    function payFee(address payer, uint256 amount, address _erc20Token) public {\n        require(_inState(State.Initiated), 'Only for uncompleted trade');\n\n        _doFeePayment(payer, amount, _erc20Token);\n        _paymentStatusCheck();\n    }\n\n    /**\n     */\n    function submitExpirationRelease() public onlyOwner {\n        require(\n            _inState(State.Expired) || isExpired(),\n            'Only for expired trade'\n        );\n\n        returnPaymentAmountAndCollectFee();\n    }\n\n    /**\n     * NOTICE: Must call approve first\n     * @dev Function only able to be called by Trade Contract's controller\n     */\n    function doFiatPayment(uint256 _amount) public {\n        require(_inState(State.Initiated), 'Only for uncompleted trade');\n\n        if (\n            buyerPayment.token.transferFrom(buyer,\n                address(this),\n                _amount\n            )\n        ) {\n            _newFiatPayment(_amount);\n        }\n        _paymentStatusCheck();\n    }\n\n    function doCommodityPayment(uint256 _amount) public {\n        require(_inState(State.Initiated), 'Only for uncompleted trade');\n\n        registry.getCollateralManagementToken()\n        .safeTransferFrom(\n            seller,\n            address(this),\n            sellerPayment.tokenIndex,\n            _amount,\n            \"0x0\"\n        );\n        _newCommodityPayment(_amount);\n        _paymentStatusCheck();\n    }\n\n    function initLoanForTrade(\n        address creditor,\n        address[6] calldata orderAddresses, // 1-repayment router, 2-debtor, 3-termcontract, 4-principalTokenAddress, 5-relayer, 6-priceFeeOperator\n        uint256[7] calldata orderValues, // 1-salt, 2-principalAmount, 3-creditorFee, 4-debtorFee, 5-expirationTimestampInSec, 6-minCR, 7-liquidationRatio\n        bytes32[1] calldata orderBytes32, // 1-termsContractParameters\n        bytes16[1] calldata orderBytes16, // 1-collateralInfoParameters\n        address[5] calldata debtorFeeBeneficiaries,\n        address[5] calldata creditorFeeBeneficiaries,\n        uint256[5] calldata debtorFeeAmounts,\n        uint256[5] calldata creditorFeeAmounts\n    ) external onlyOwner {\n        loanAgreementId = registry.getInventoryLoanKernel()\n            ._fillDebtOrder(\n                creditor,\n                buyer,\n                principalAmount,\n                orderAddresses,\n                orderValues,\n                orderBytes32,\n                orderBytes16,\n                debtorFeeBeneficiaries,\n                creditorFeeBeneficiaries,\n                debtorFeeAmounts,\n                creditorFeeAmounts\n            );\n        swap();\n    }\n\n    // Owner interact with Trade's state\n    /// @dev Function only able to be called by contract Owner. Obviously participants only able to complete the payments\n    // if Trade Controller has set up fee\n    function swap() public onlyOwner {\n        require(_inState(State.CompletedPayment), 'Not completed payment');\n\n        bool isEmbeddedFlow = principalAmount > 0;\n\n        IERC20 erc20 = buyerPayment.token;\n\n        if (isEmbeddedFlow) {\n            erc20.transfer(seller, buyerPayment.amount + principalAmount - debtorFee);\n        } else {\n            erc20.transfer(seller, buyerPayment.amount);\n        }\n\n        // return redundant paid amount to buyer\n        if (buyerPayment.paidAmount > buyerPayment.amount) {\n            erc20.transfer(\n                buyer,\n                buyerPayment.paidAmount.sub(buyerPayment.amount)\n            );\n        }\n\n        CollateralManagementToken erc1155 = registry.getCollateralManagementToken();\n\n        if (!isEmbeddedFlow) {\n            erc1155.safeTransferFrom(\n                address(this),\n                buyer,\n                sellerPayment.tokenIndex,\n                sellerPayment.amount,\n                \"0x0\"\n            );\n        }\n\n        // return redundant paid amount to seller\n        if (sellerPayment.paidAmount > sellerPayment.amount) {\n            erc1155.safeTransferFrom(\n                address(this),\n                seller,\n                sellerPayment.tokenIndex,\n                sellerPayment.paidAmount.sub(sellerPayment.amount),\n                \"0x0\"\n            );\n        }\n\n        _transferFeeToBeneficiaries();\n\n        state = State.Completed;\n    }\n\n    /// @dev Function is not able to be called by normal user\n    function abortTrade() public onlyOwner onlyUncompletedTrade {\n        returnPaymentAmountAndCollectFee();\n\n        state = State.Aborted;\n    }\n\n    function returnPaymentAmountAndCollectFee() internal {\n        // Return fiat tokens to buyer\n        buyerPayment.token\n        .transfer(buyer, buyerPayment.paidAmount);\n\n        // Return cma tokens to seller\n        CollateralManagementToken erc1155 = registry.getCollateralManagementToken();\n        erc1155.safeTransferFrom(\n            address(this),\n            seller,\n            sellerPayment.tokenIndex,\n            sellerPayment.paidAmount,\n            \"0x0\"\n        );\n\n        // Collect fee\n        _transferFeeToBeneficiaries();\n    }\n\n    //=-----------------------------------------------------------------------\n    // Functions for participants of Trade\n    //=-----------------------------------------------------------------------\n    //=-- Query payment state from parties\n    function getContractState() public view returns (uint8) {\n        return uint8(state);\n    }\n\n    /**\n     * response formatting:\n     */\n    function getSellerPaymentStatus()\n    external\n    view\n    returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        uint256 totalLength = feeTokens.length + 1;\n        address[] memory spendingTokens = new address[](totalLength);\n        uint256[] memory expectedAmounts = new uint[](totalLength);\n        uint256[] memory paidAmounts = new uint[](totalLength);\n\n        for (uint256 i = 0; i < feeTokens.length; i++) {\n            spendingTokens[i] = feeTokens[i];\n            expectedAmounts[i] = tokenFeeAmounts[seller][feeTokens[i]];\n            paidAmounts[i] = paidTokenFeeAmounts[seller][feeTokens[i]];\n        }\n\n        spendingTokens[feeTokens.length] = address(registry.getCollateralManagementToken());\n\n        expectedAmounts[feeTokens.length] = sellerPayment.amount;\n\n        paidAmounts[feeTokens.length] = sellerPayment.paidAmount;\n\n        return (spendingTokens, expectedAmounts, paidAmounts);\n    }\n\n    /**\n     * response formatting:\n     */\n/*\n    function getBuyerPaymentStatus()\n    external\n    view\n    returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        address[] memory spendingTokens;\n        uint256[] memory expectedAmounts;\n        uint256[] memory paidAmounts;\n\n        (spendingTokens, expectedAmounts, paidAmounts) = feePaymentStatus(\n            buyer\n        );\n\n        uint256 tokenFeesLength = spendingTokens.length;\n        if (tokenFeesLength == 0) {\n            spendingTokens = new address[](1);\n            expectedAmounts = new uint256[](1);\n            paidAmounts = new uint256[](1);\n\n            spendingTokens[0] = address(buyerPayment.token);\n            expectedAmounts[0] = buyerPayment.amount;\n            paidAmounts[0] = buyerPayment.paidAmount;\n        } else {\n            bool isFiatTokenInList = false;\n            for (uint256 i = 0; i < tokenFeesLength; i++) {\n                // if trading fiat token is including in list\n                if (\n                    spendingTokens[i] == address(buyerPayment.token)\n                ) {\n                    expectedAmounts[i] = expectedAmounts[i].add(\n                        buyerPayment.amount\n                    );\n                    paidAmounts[i] = paidAmounts[i].add(\n                        buyerPayment.paidAmount\n                    );\n                    isFiatTokenInList = true;\n                }\n            }\n            // If fiat token is not in list, append it to list\n            if (!isFiatTokenInList) {\n                spendingTokens.push(address(buyerPayment.token));\n                expectedAmounts.push(buyerPayment.amount);\n                paidAmounts.push(buyerPayment.paidAmount);\n            }\n        }\n\n        return (spendingTokens, expectedAmounts, paidAmounts);\n    }\n*/\n\n    function getTradeInfo()\n    public\n    view\n    returns (\n        address _seller,\n        address _buyer,\n        address _buyerPaymentTokenAddress,\n        uint256 _buyerPaymentAmount,\n        uint256 _buyerPaidAmount,\n        uint256 _sellerPaymentTokenIndex,\n        uint256 _sellerPaymentAmount,\n        uint256 _sellerPaidAmount\n    )\n    {\n        _seller = seller;\n        _buyer = buyer;\n        _buyerPaymentTokenAddress = address(buyerPayment.token);\n        _buyerPaymentAmount = buyerPayment.amount;\n        _buyerPaidAmount = buyerPayment.paidAmount;\n        _sellerPaymentTokenIndex = sellerPayment.tokenIndex;\n        _sellerPaymentAmount = sellerPayment.amount;\n        _sellerPaidAmount = sellerPayment.paidAmount;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/tokens/reconcile/AssetsTransformation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract AssetsTransformation {\n    using SafeMath for uint256;\n\n    address internal creator;\n    address internal tokenOwner;\n    address internal tokenAddress;\n\n    string internal referenceID;\n\n    uint internal amount;\n    uint internal createdTime;\n    uint internal expirationTime;\n\n    //********** Setting up fees *************/\n    struct TransformationFees {\n        uint256 amount;\n        address token;\n        address beneficiary;\n    }\n\n    mapping(address => bool) isFeeTokens;\n    address[] feeTokens;\n\n    // fee type id => fee details list)\n    // For now only support 1 beneficiary for 1 type of fee from each payers\n    mapping(bytes32 => TransformationFees) requiredFees;\n    mapping(bytes32 => bool) isRequiredFeeTypes;\n    bytes32[] requiredFeeTypeIds;\n\n    // Fee token => map to required amount\n    mapping(address => uint256) tokenFeeAmounts;\n    // Fee token => map to paid amount\n    mapping(address => uint256) paidTokenFeeAmounts;\n    mapping(address => uint256) releasedTokenFeeAmounts;\n    //****************************************/\n\n    event ContractExpired(address indexed contractAddress, uint time);\n    event ExpirationRelease(address indexed contractAddress, uint time);\n\n    event SetupNewFee(address indexed _beneficiary, uint256 _amount, address _token);\n    event NewFeePayment(address indexed _payer, uint256 _amount, address _token);\n    event NewFeeReleased(address indexed _beneficiary, uint _amount, address indexed _token);\n\n    event AddedNewFeeType(bytes32 indexed _id);\n\n    enum State { Proposed, Completed, Expired, Canceled}\n    enum TokenType { Unknown, Commodity, Fiat }\n\n    State state;\n    TokenType internal tokenType;\n\n    modifier onlyCreator {\n        require(msg.sender == creator, \"AssetsTransformation: Sender must be creator of smart contract instance.\");\n        _;\n    }\n\n    modifier onlyTokenOwner {\n        require(msg.sender == tokenOwner, \"AssetsTransformation: Sender must be token owner.\");\n        _;\n    }\n    constructor(\n        address _creator,\n        string memory _refID,\n        address _owner,\n        uint8 _tokenType,\n        address _tokenAddress,\n        uint _amount,\n        uint _expTime\n    ) {\n        creator = _creator;\n        referenceID = _refID;\n        tokenAddress = _tokenAddress;\n        amount = _amount;\n        tokenOwner = _owner;\n        expirationTime = _expTime;\n        if (_tokenType == uint8(TokenType.Commodity)) {\n            tokenType = TokenType.Commodity;\n        } else if(_tokenType == uint8(TokenType.Fiat)) {\n            tokenType = TokenType.Fiat;\n        } else {\n            tokenType = TokenType.Unknown;\n        }\n\n        // solium-disable-next-line\n        createdTime = block.timestamp;\n        state = State.Proposed;\n    }\n\n    /********* INTERNAL FUNCS *********/\n\n    function _transferTokensFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool success) {\n        return\n            IERC20(_token).transferFrom(\n                _from,\n                _to,\n                _amount\n            );\n    }\n\n    // Transfer fee to beneficiary\n    function _transferFeeToBeneficiary(\n        uint256 _amount,\n        address _token,\n        address _beneficiary\n    ) internal {\n//        BinkabiERC20Token tokenInstance = BinkabiERC20Token(_token);\n/*\n        require(\n            tokenInstance.approve(tokenTransferProxy, _amount),\n            \"Fees: Unable to grant permission for transferring token to proxy.\"\n        );\n*/\n        require(\n            _transferTokensFrom(_token, address(this), _beneficiary, _amount),\n            \"Fees: Unable to transfer fee to beneficiary.\"\n        );\n        _newFeeReleaseHasCompleted(_beneficiary, _amount, _token);\n    }\n\n    // Add token fee to list if it is non-existed\n    function _addFeeToken(address token) internal {\n        if (!isFeeTokens[token]) {\n            feeTokens.push(token);\n            isFeeTokens[token] = true;\n        }\n    }\n\n    function _addFeeTypeId(uint256 id) internal {\n        if (!isRequiredFeeTypes[bytes32(id)]) {\n            requiredFeeTypeIds.push(bytes32(id));\n            isRequiredFeeTypes[bytes32(id)] = true;\n            emit AddedNewFeeType(bytes32(id));\n        }\n    }\n\n    // Add fee amount to respective existing fee token\n    function _setupNewFeePayment(\n        uint256 _amount,\n        address _token\n    ) internal {\n        uint256 totalRequiredAmount = tokenFeeAmounts[_token].add(\n            _amount\n        );\n        tokenFeeAmounts[_token] = totalRequiredAmount;\n    }\n\n    // Setup new fee for this exchange, new fee type/amount/beneficiary\n    function _setupFee(\n        uint256 _feeId,\n        uint256 _amount,\n        address _token,\n        address _beneficiary\n    ) internal {\n        TransformationFees memory fee = TransformationFees({\n            amount: _amount,\n            token: _token,\n            beneficiary: _beneficiary\n        });\n        requiredFees[bytes32(_feeId)] = fee;\n        _addFeeToken(_token);\n        _addFeeTypeId(_feeId);\n        _setupNewFeePayment(_amount, _token);\n        emit SetupNewFee(_beneficiary, _amount, _token);\n    }\n\n    // Whenever there is new fee payment to this withdrawal/top-up\n    function _newFeePaymentHasCompleted(\n        address _payer,\n        uint256 _amount,\n        address _token\n    ) internal {\n        uint256 totalPaid = paidTokenFeeAmounts[_token].add(_amount);\n        paidTokenFeeAmounts[_token] = totalPaid;\n        emit NewFeePayment(_payer, _amount, _token);\n    }\n\n    function _newFeeReleaseHasCompleted(\n        address _beneficiary,\n        uint256 _amount,\n        address _token\n    ) internal {\n        uint256 totalReleased = releasedTokenFeeAmounts[_token].add(_amount);\n        releasedTokenFeeAmounts[_token] = totalReleased;\n        emit NewFeeReleased(_beneficiary, _amount, _token);\n    }\n\n\n    function _isCompletedFeePaymentWithToken(address _token)\n        internal\n        view\n        returns (bool)\n    {\n        return paidTokenFeeAmounts[_token] >= tokenFeeAmounts[_token];\n    }\n\n    // Release fees to respective beneficiary\n    function _releaseFees() internal {\n        uint256 feeTypesLength = requiredFeeTypeIds.length;\n        if (feeTypesLength > 0) {\n            for (uint256 i = 0; i < feeTypesLength; i++) {\n                TransformationFees memory fee = requiredFees[requiredFeeTypeIds[i]];\n                if (paidTokenFeeAmounts[fee.token] > releasedTokenFeeAmounts[fee.token]) {\n                    uint256 remain = paidTokenFeeAmounts[fee.token].sub(releasedTokenFeeAmounts[fee.token]);\n                    if (remain >= fee.amount) {\n                        _transferFeeToBeneficiary(\n                            fee.amount,\n                            fee.token,\n                            fee.beneficiary\n                        );\n                    } else {\n                        _transferFeeToBeneficiary(\n                            remain,\n                            fee.token,\n                            fee.beneficiary\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    /****** State functions ******/\n    function _inState(State _state) internal view returns (bool) {\n        return (state == _state);\n    }\n\n    function _notInState(State _state) internal view returns (bool) {\n        return (state != _state);\n    }\n\n    // ============================ //\n    // Fee functions\n    // ============================ //\n\n    function payFee(uint256 _amount, address _token) public onlyTokenOwner {\n        if (_transferTokensFrom(_token, msg.sender, address(this), _amount)) {\n            _newFeePaymentHasCompleted(msg.sender, _amount, _token);\n        }\n    }\n\n    function setupFee(uint256 _feeId, uint256 _amount, address _token, address _beneficiary) public {\n        require(_feeId > 0, \"AssetsTransformation: Invalid fee Id.\");\n        require(_amount > 0, \"AssetsTransformation: Invalid fee amount.\");\n        require(_beneficiary != address(0x0), \"AssetsTransformation: Invalid beneficiary of fee.\");\n        _setupFee(_feeId, _amount, _token, _beneficiary);\n    }\n\n    // Query current status of fees payment\n    function feePaymentStatus()\n        public\n        view\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        uint256 feeTokensLength = feeTokens.length;\n        uint256[] memory expectedAmounts = new uint256[](feeTokensLength);\n        uint256[] memory paidAmounts = new uint256[](feeTokensLength);\n\n        for (uint256 i = 0; i < feeTokensLength; i++) {\n            expectedAmounts[i] = tokenFeeAmounts[feeTokens[i]];\n            paidAmounts[i] = paidTokenFeeAmounts[feeTokens[i]];\n        }\n\n        return (feeTokens, expectedAmounts, paidAmounts);\n    }\n\n\n    function isCompletedFeesPayment()\n        public\n        view\n        returns (bool)\n    {\n        // default is true. Because, assume that there is no token fee -> user don't need to pay for any fee\n        bool isCompleted = true;\n        uint256 feeTokensLength = feeTokens.length;\n        if (feeTokensLength > 0) {\n            for (uint256 i = 0; i < feeTokensLength; i++) {\n                if (!_isCompletedFeePaymentWithToken(feeTokens[i])) {\n                    isCompleted = false;\n                    break;\n                }\n            }\n        }\n        return isCompleted;\n    }\n\n    // ============================ //\n    // Timing functions\n    // ============================ //\n    function getExpirationTime() public view returns (uint) {\n        return expirationTime;\n    }\n\n    function getCreatedTime() public view returns (uint) {\n        return createdTime;\n    }\n\n    function getState() public view returns (uint8) {\n        return uint8(state);\n    }\n\n    function validateExpirationTime() public returns (bool) {\n        // solium-disable-next-line\n        if (block.timestamp.sub(createdTime) >= expirationTime) {\n            state = State.Expired;\n            // solium-disable-next-line\n            emit ContractExpired(address(this), block.timestamp);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function expirationTimeLeft() public view returns (uint) {\n        // solium-disable-next-line\n        uint elapseTime = block.timestamp.sub(createdTime);\n        if (expirationTime > elapseTime) {\n            return expirationTime.sub(elapseTime);\n        } else {\n            return 0;\n        }\n    }\n    /**\n     */\n    function setExpirationTime(uint duration) public  onlyCreator {\n        expirationTime = duration;\n    }\n\n\n    function isExpired() public view returns (bool) {\n        // solium-disable-next-line\n        if (expirationTime > block.timestamp.sub(createdTime)) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n\n    /****************************/\n    // EXTERNAL FUNCS\n    /****************************/\n\n    /** CALL **/\n    function getBeneficiaryByFeeId(uint256 _feeId) public view returns (address) {\n        return requiredFees[bytes32(_feeId)].beneficiary;\n    }\n}\n"
    },
    "contracts/tokens/reconcile/TokenTopup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AssetsTransformation.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract TokenTopup is AssetsTransformation {\n\n    constructor(\n        address _creator,\n        string memory _refID,\n        address _owner,\n        uint8 _tokenType,\n        address _tokenAddress,\n        uint _amount,\n        uint _expTime\n    ) AssetsTransformation(\n        _creator,\n        _refID,\n        _owner,\n        _tokenType,\n        _tokenAddress,\n        _amount,\n        _expTime\n    ) {\n    }\n\n    event TopupCompleted(address indexed tokenOwner, uint amount, uint time);\n    event TopupCanceled(address indexed tokenOwner, uint amount, uint time);\n\n\n    // ============================ //\n    // Expiration time functions\n    // ============================ //\n    function submitExpirationRelease() public onlyCreator {\n        require(tokenType != TokenType.Unknown, \"TokenTopup: Token type is not specified.\");\n        require(isCompletedFeesPayment(), \"TokenTopup: Fee payment is not completed yet.\");\n        require(_inState(State.Expired) || isExpired(), \"TokenTopup: This function only for expired smart contract.\");\n        _topupTermination();\n        state = State.Expired;\n        emit ExpirationRelease(address(this), block.timestamp);\n    }\n\n    function cancel() public onlyCreator returns (bool) {\n        require(tokenType != TokenType.Unknown, \"TokenTopup: Token type is not specified.\");\n        require(isCompletedFeesPayment(), \"TokenTopup: Fee payment is not completed yet.\");\n        require(_notInState(State.Completed), \"TokenTopup: Not allowed for completed Topup.\");\n        _topupTermination();\n        state = State.Canceled;\n        emit TopupCanceled(tokenOwner, amount, block.timestamp);\n        return true;\n    }\n\n    function complete() public onlyCreator returns (bool) {\n        require(tokenType != TokenType.Unknown, \"TokenTopup: Token type is not specified.\");\n        require(isCompletedFeesPayment(), \"TokenTopup: Fee payment is not completed yet.\");\n        require(\n            _notInState(State.Expired) && _notInState(State.Canceled) && _notInState(State.Completed),\n            \"TokenTopup: Not allowed for expired or canceled/completed Topup.\"\n        );\n        _releaseTopup();\n        state = State.Completed;\n        emit TopupCompleted(tokenOwner, amount, block.timestamp);\n        return true;\n    }\n\n\n    // ============================ //\n    // INTERNAL functions\n    // ============================ //\n    function _topupTermination() internal {\n        ERC20Burnable(tokenAddress).burn(amount);\n        _releaseFees();\n    }\n\n    function _releaseTopup() internal {\n        ERC20Burnable(tokenAddress).transfer(tokenOwner, amount);\n        _releaseFees();\n    }\n}\n"
    },
    "contracts/tokens/reconcile/TokenTopupController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./TokenTopup.sol\";\nimport \"../../base/UntangledBase.sol\";\nimport \"../../storage/Registry.sol\";\nimport \"../../libraries/ConfigHelper.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n* Manage all of Topup requests from Barter Block, or other smart contract\n*/\ncontract TokenTopupController is UntangledBase {\n\n    enum TokenType { Unknown, Commodity, Fiat }\n\n    // List all of topup request\n    mapping(string => address) topups;\n    /**\n    * TODO: Need to customize this mapping when we support other organization to do withrawal for users\n    */\n\n    /** CONSTRUCTOR */\n    function initialize() public initializer {\n        __UntangledBase__init(_msgSender());\n    }\n\n    event NewTopupRequest(address indexed token, address from, uint amount, uint expTime);\n\n    function newTopup(\n        string memory _refID,\n        address _tokenOwner,\n        uint8 _tokenType,\n        address _tokenAddress,\n        uint _amount,\n        uint _expTime\n    ) public onlyRole(OWNER_ROLE) {\n        require(_tokenType != uint8(TokenType.Unknown), \"Unknown token type.\");\n        require(_tokenAddress != address(0), \"Invalid token address.\");\n        require(_amount != 0, \"Invalid withdrawal amount.\");\n        require(_expTime > 0, \"Invalid expiration time.\");\n\n        // Create new contract instance\n        TokenTopup topup = new TokenTopup(\n            msg.sender,\n            _refID,\n            _tokenOwner,\n            _tokenType,\n            _tokenAddress,\n            _amount,\n            _expTime\n        );\n        topups[_refID] = address(topup);\n        ERC20PresetMinterPauser(_tokenAddress).mint(address(topup), _amount);\n\n        emit NewTopupRequest(_tokenAddress, _tokenOwner, _amount, _expTime);\n    }\n\n    function contractAddressOf(string memory _refID) public view returns (address) {\n        return topups[_refID];\n    }\n\n}\n"
    },
    "contracts/tokens/ERC20/FiatToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol';\n\ncontract FiatToken is ERC20PresetMinterPauser {\n    uint8 internal _d;\n    constructor(\n        address minter,\n        string memory name,\n        string memory symbol,\n        uint8 _decimals\n    ) ERC20PresetMinterPauser(name, symbol) {\n        _d = _decimals;\n        _setupRole(MINTER_ROLE, minter);\n        renounceRole(MINTER_ROLE, _msgSender());\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _d;\n    }\n\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '../../interfaces/INoteToken.sol';\nimport './base/NAVCalculation.sol';\nimport './base/SecuritizationPoolServiceBase.sol';\nimport '../../interfaces/ICrowdSale.sol';\n\ncontract SecuritizationPoolValueService is\n    SecuritizationPoolServiceBase,\n    NAVCalculation,\n    ISecuritizationPoolValueService\n{\n    using ConfigHelper for Registry;\n\n    function _getPresentValueWithNAVCalculation(\n        address poolAddress,\n        uint256 totalDebt,\n        uint256 interestRate,\n        uint256 riskScoreIdx, // riskScoreIdx should be reduced 1 to be able to use because 0 means no specific riskScore\n        uint256 overdue,\n        Configuration.ASSET_PURPOSE assetPurpose\n    ) private view returns (uint256) {\n        uint256 riskScoresLength = ISecuritizationPool(poolAddress).getRiskScoresLength();\n        bool hasValidRiskScore = riskScoresLength > 0;\n        if (hasValidRiskScore) {\n            if (riskScoreIdx == 0) (hasValidRiskScore, riskScoreIdx) = getAssetRiskScoreIdx(poolAddress, overdue);\n            else riskScoreIdx = riskScoreIdx > riskScoresLength ? riskScoresLength - 1 : riskScoreIdx - 1;\n        }\n        if (!hasValidRiskScore) return totalDebt;\n        RiskScore memory riskscore = _getRiskScoreByIdx(poolAddress, riskScoreIdx);\n        return _calculateAssetValue(totalDebt, interestRate, overdue, riskscore, assetPurpose);\n    }\n\n    function getExpectedAssetValue(\n        address poolAddress,\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view returns (uint256) {\n        IUntangledERC721 loanAssetToken = IUntangledERC721(tokenAddress);\n        uint256 expirationTimestamp = loanAssetToken.getExpirationTimestamp(tokenId);\n\n        uint256 overdue = timestamp > expirationTimestamp ? timestamp - expirationTimestamp : 0;\n        uint256 totalDebt = loanAssetToken.getTotalExpectedRepaymentValue(tokenId, timestamp);\n\n        uint256 presentValue = _getPresentValueWithNAVCalculation(\n            poolAddress,\n            totalDebt,\n            loanAssetToken.getInterestRate(tokenId),\n            loanAssetToken.getRiskScore(tokenId),\n            overdue,\n            loanAssetToken.getAssetPurpose(tokenId)\n        );\n\n        if (timestamp < expirationTimestamp) {\n            totalDebt = loanAssetToken.getTotalExpectedRepaymentValue(tokenId, timestamp);\n        }\n\n        return presentValue < totalDebt ? presentValue : totalDebt;\n    }\n\n    function getExpectedAssetValues(\n        address poolAddress,\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        uint256 timestamp\n    ) external view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](tokenIds.length);\n        for (uint256 i; i < tokenIds.length; i++) {\n            balances[i] = getExpectedAssetValue(poolAddress, tokenAddresses[i], tokenIds[i], timestamp);\n        }\n        return balances;\n    }\n\n    function getAssetInterestRate(\n        address poolAddress,\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view returns (uint256) {\n        IUntangledERC721 loanAssetToken = IUntangledERC721(tokenAddress);\n        uint256 interestRate = loanAssetToken.getInterestRate(tokenId);\n\n        if (loanAssetToken.getAssetPurpose(tokenId) == Configuration.ASSET_PURPOSE.PLEDGE) {\n            uint256 riskScoresLength = ISecuritizationPool(poolAddress).getRiskScoresLength();\n\n            bool hasValidRiskScore = riskScoresLength > 0;\n            if (hasValidRiskScore) {\n                uint256 riskScoreIdx = loanAssetToken.getRiskScore(tokenId);\n\n                if (riskScoreIdx == 0) {\n                    uint256 expirationTimestamp = loanAssetToken.getExpirationTimestamp(tokenId);\n                    uint256 overdue = timestamp > expirationTimestamp ? timestamp - expirationTimestamp : 0;\n                    (hasValidRiskScore, riskScoreIdx) = getAssetRiskScoreIdx(poolAddress, overdue);\n                } else riskScoreIdx = riskScoreIdx > riskScoresLength ? riskScoresLength - 1 : riskScoreIdx - 1;\n\n                if (hasValidRiskScore) {\n                    RiskScore memory riskscore = _getRiskScoreByIdx(poolAddress, riskScoreIdx);\n                    return riskscore.interestRate;\n                }\n            }\n        }\n\n        return interestRate;\n    }\n\n    function getAssetInterestRates(\n        address poolAddress,\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        uint256 timestamp\n    ) external view returns (uint256[] memory) {\n        uint256[] memory interestRates = new uint256[](tokenIds.length);\n        for (uint256 i; i < tokenIds.length; i++) {\n            interestRates[i] = getAssetInterestRate(poolAddress, tokenAddresses[i], tokenIds[i], timestamp);\n        }\n        return interestRates;\n    }\n\n    function getExpectedERC20AssetValue(\n        address poolAddress,\n        address assetPoolAddress,\n        address tokenAddress,\n        uint256 interestRate,\n        uint256 timestamp\n    ) public view returns (uint256) {\n        uint256 expirationTimestamp = ISecuritizationPool(assetPoolAddress).openingBlockTimestamp() +\n            ISecuritizationPool(assetPoolAddress).termLengthInSeconds();\n\n        uint256 overdue = timestamp > expirationTimestamp ? timestamp - expirationTimestamp : 0;\n\n        uint256 totalDebt = registry.getDistributionAssessor().calcCorrespondingTotalAssetValue(\n            tokenAddress,\n            poolAddress,\n            timestamp\n        );\n\n        uint256 presentValue = _getPresentValueWithNAVCalculation(\n            poolAddress,\n            totalDebt,\n            interestRate,\n            0,\n            overdue,\n            Configuration.ASSET_PURPOSE.SALE\n        );\n\n        if (timestamp < expirationTimestamp) {\n            totalDebt = registry.getDistributionAssessor().calcCorrespondingTotalAssetValue(\n                tokenAddress,\n                poolAddress,\n                timestamp\n            );\n        }\n\n        return\n            _convertTokenValueToCurrencyAmount(\n                poolAddress,\n                tokenAddress,\n                presentValue < totalDebt ? presentValue : totalDebt\n            );\n    }\n\n    function getExpectedAssetsValue(address poolAddress, uint256 timestamp)\n        external\n        view\n        returns (uint256 expectedAssetsValue)\n    {\n        expectedAssetsValue = 0;\n        ISecuritizationPool securitizationPool = ISecuritizationPool(poolAddress);\n\n        for (uint256 i = 0; i < securitizationPool.getNFTAssetsLength(); ++i) {\n            (address assetTokenAddress, uint256 assetTokenId) = securitizationPool.nftAssets(i);\n            expectedAssetsValue =\n                expectedAssetsValue +\n                getExpectedAssetValue(poolAddress, assetTokenAddress, assetTokenId, timestamp);\n        }\n        for (uint256 i = 0; i < securitizationPool.getTokenAssetAddressesLength(); ++i) {\n            address tokenAddress = securitizationPool.tokenAssetAddresses(i);\n            INoteToken notesToken = INoteToken(tokenAddress);\n            if (notesToken.balanceOf(poolAddress) > 0) {\n                expectedAssetsValue =\n                    expectedAssetsValue +\n                    getExpectedERC20AssetValue(\n                        poolAddress,\n                        notesToken.poolAddress(),\n                        tokenAddress,\n                        Configuration.NOTE_TOKEN_TYPE(notesToken.noteTokenType()) ==\n                            Configuration.NOTE_TOKEN_TYPE.SENIOR\n                            ? ISecuritizationPool(notesToken.poolAddress()).interestRateSOT()\n                            : 0,\n                        timestamp\n                    );\n            }\n        }\n    }\n\n    function getAssetRiskScoreIdx(address poolAddress, uint256 overdue)\n        public\n        view\n        returns (bool hasValidRiskScore, uint256 riskScoreIdx)\n    {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(poolAddress);\n        uint256 riskScoresLength = securitizationPool.getRiskScoresLength();\n        for (riskScoreIdx = 0; riskScoreIdx < riskScoresLength; riskScoreIdx++) {\n            uint32 daysPastDue = _getDaysPastDueByIdx(securitizationPool, riskScoreIdx);\n            if (overdue < daysPastDue) return (false, 0);\n            else if (riskScoreIdx == riskScoresLength - 1) {\n                return (true, riskScoreIdx);\n            } else {\n                uint32 nextDaysPastDue = _getDaysPastDueByIdx(securitizationPool, riskScoreIdx + 1);\n                if (overdue < nextDaysPastDue) return (true, riskScoreIdx);\n            }\n        }\n    }\n\n    function _getDaysPastDueByIdx(ISecuritizationPool securitizationPool, uint256 idx) private view returns (uint32) {\n        (uint32 daysPastDue, , , , , , , , , ) = securitizationPool.riskScores(idx);\n        return daysPastDue;\n    }\n\n    function _getAdvanceRateByIdx(ISecuritizationPool securitizationPool, uint256 idx) private view returns (uint32) {\n        (, uint32 advanceRate, , , , , , , , ) = securitizationPool.riskScores(idx);\n        return advanceRate;\n    }\n\n    function _getPenaltyRateByIdx(ISecuritizationPool securitizationPool, uint256 idx) private view returns (uint32) {\n        (, , uint32 penaltyRate, , , , , , , ) = securitizationPool.riskScores(idx);\n        return penaltyRate;\n    }\n\n    function _getInterestRateByIdx(ISecuritizationPool securitizationPool, uint256 idx) private view returns (uint32) {\n        (, , , uint32 interestRate, , , , , , ) = securitizationPool.riskScores(idx);\n        return interestRate;\n    }\n\n    function _getProbabilityOfDefaultByIdx(ISecuritizationPool securitizationPool, uint256 idx)\n        private\n        view\n        returns (uint32)\n    {\n        (, , , , uint32 probabilityOfDefault, , , , , ) = securitizationPool.riskScores(idx);\n        return probabilityOfDefault;\n    }\n\n    function _getLossGivenDefaultByIdx(ISecuritizationPool securitizationPool, uint256 idx)\n        private\n        view\n        returns (uint32)\n    {\n        (, , , , , uint32 lossGivenDefault, , , , ) = securitizationPool.riskScores(idx);\n        return lossGivenDefault;\n    }\n\n    function _getGracePeriodByIdx(ISecuritizationPool securitizationPool, uint256 idx) private view returns (uint32) {\n        (, , , , , , uint32 gracePeriod, , , ) = securitizationPool.riskScores(idx);\n        return gracePeriod;\n    }\n\n    function _getCollectionPeriodByIdx(ISecuritizationPool securitizationPool, uint256 idx)\n        private\n        view\n        returns (uint32)\n    {\n        (, , , , , , , uint32 collectionPeriod, , ) = securitizationPool.riskScores(idx);\n        return collectionPeriod;\n    }\n\n    function _getWriteOffAfterGracePeriodByIdx(ISecuritizationPool securitizationPool, uint256 idx)\n        private\n        view\n        returns (uint32)\n    {\n        (, , , , , , , , uint32 writeOffAfterGracePeriod, ) = securitizationPool.riskScores(idx);\n        return writeOffAfterGracePeriod;\n    }\n\n    function _getWriteOffAfterCollectionPeriodByIdx(ISecuritizationPool securitizationPool, uint256 idx)\n        private\n        view\n        returns (uint32)\n    {\n        (, , , , , , , , , uint32 writeOffAfterCollectionPeriod) = securitizationPool.riskScores(idx);\n        return writeOffAfterCollectionPeriod;\n    }\n\n    function _getRiskScoreByIdx(address pool, uint256 idx) private view returns (RiskScore memory) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        return\n            RiskScore({\n                daysPastDue: _getDaysPastDueByIdx(securitizationPool, idx),\n                advanceRate: _getAdvanceRateByIdx(securitizationPool, idx),\n                penaltyRate: _getPenaltyRateByIdx(securitizationPool, idx),\n                interestRate: _getInterestRateByIdx(securitizationPool, idx),\n                probabilityOfDefault: _getProbabilityOfDefaultByIdx(securitizationPool, idx),\n                lossGivenDefault: _getLossGivenDefaultByIdx(securitizationPool, idx),\n                gracePeriod: _getGracePeriodByIdx(securitizationPool, idx),\n                collectionPeriod: _getCollectionPeriodByIdx(securitizationPool, idx),\n                writeOffAfterGracePeriod: _getWriteOffAfterGracePeriodByIdx(securitizationPool, idx),\n                writeOffAfterCollectionPeriod: _getWriteOffAfterCollectionPeriodByIdx(securitizationPool, idx)\n            });\n    }\n\n    function getOutstandingPrincipalCurrencyByInvestor(address pool, address investor) public view returns (uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        ICrowdSale crowdsale = ICrowdSale(securitizationPool.tgeAddress());\n\n        return\n            crowdsale.currencyRaisedByInvestor(investor) -\n            securitizationPool.paidPrincipalAmountSOTByInvestor(investor);\n    }\n\n    function getOutstandingPrincipalCurrencyByInvestors(address pool, address[] calldata investors)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 result = 0;\n        for (uint256 i = 0; i < investors.length; i++) {\n            result = result + getOutstandingPrincipalCurrencyByInvestor(pool, investors[i]);\n        }\n        return result;\n    }\n\n    function getOutstandingPrincipalCurrency(address pool) external view returns (uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        ICrowdSale crowdsale = ICrowdSale(securitizationPool.tgeAddress());\n\n        return crowdsale.currencyRaised() - securitizationPool.paidPrincipalAmountSOT();\n    }\n}\n"
    },
    "contracts/protocol/pool/base/NAVCalculation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../../libraries/UntangledMath.sol';\nimport '../../../libraries/Configuration.sol';\n\ncontract NAVCalculation {\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n    uint256 public constant ONE_HUNDRED_PERCENT = 100 * INTEREST_RATE_SCALING_FACTOR_PERCENT;\n\n    struct RiskScore {\n        uint32 daysPastDue;\n        uint32 advanceRate;\n        uint32 penaltyRate;\n        uint32 interestRate;\n        uint32 probabilityOfDefault;\n        uint32 lossGivenDefault;\n        uint32 writeOffAfterGracePeriod;\n        uint32 gracePeriod;\n        uint32 collectionPeriod;\n        uint32 writeOffAfterCollectionPeriod;\n    }\n\n    function _calculateAssetValue(\n        uint256 totalDebtAmt,\n        uint256 interestRate,\n        uint256 overdue,\n        RiskScore memory riskScore,\n        Configuration.ASSET_PURPOSE assetPurpose\n    ) internal pure returns (uint256) {\n        uint256 morePercentDecimal = UntangledMath.ONE / INTEREST_RATE_SCALING_FACTOR_PERCENT / 100;\n\n        if (assetPurpose == Configuration.ASSET_PURPOSE.PLEDGE) interestRate = riskScore.interestRate;\n\n        totalDebtAmt = (totalDebtAmt * riskScore.advanceRate) / ONE_HUNDRED_PERCENT;\n\n        if (overdue > riskScore.gracePeriod) {\n            totalDebtAmt =\n                (totalDebtAmt *\n                    (UntangledMath.ONE +\n                        UntangledMath.rpow(\n                            (interestRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                            riskScore.gracePeriod,\n                            UntangledMath.ONE\n                        ))) /\n                UntangledMath.ONE;\n\n            uint256 penaltyRate = (interestRate * riskScore.penaltyRate) / ONE_HUNDRED_PERCENT;\n\n            totalDebtAmt =\n                (totalDebtAmt *\n                    (UntangledMath.ONE +\n                        UntangledMath.rpow(\n                            (penaltyRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                            overdue - riskScore.gracePeriod,\n                            UntangledMath.ONE\n                        ))) /\n                UntangledMath.ONE;\n            uint256 writeOff = riskScore.writeOffAfterGracePeriod;\n            if (overdue > riskScore.collectionPeriod) writeOff = riskScore.writeOffAfterCollectionPeriod;\n\n            totalDebtAmt = (totalDebtAmt * (ONE_HUNDRED_PERCENT - writeOff)) / ONE_HUNDRED_PERCENT;\n        } else if (overdue > 0) {\n            totalDebtAmt =\n                (totalDebtAmt *\n                    (UntangledMath.ONE +\n                        UntangledMath.rpow(\n                            (interestRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                            overdue,\n                            UntangledMath.ONE\n                        ))) /\n                UntangledMath.ONE;\n        }\n\n        return\n            totalDebtAmt -\n            ((totalDebtAmt * riskScore.probabilityOfDefault * riskScore.lossGivenDefault) / ONE_HUNDRED_PERCENT**2);\n    }\n}\n"
    },
    "contracts/protocol/pool/base/SecuritizationPoolServiceBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../../base/UntangledBase.sol';\nimport '../../../interfaces/ISecuritizationPool.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '../../../libraries/ConfigHelper.sol';\n\ncontract SecuritizationPoolServiceBase is UntangledBase {\n    Registry public registry;\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init(_msgSender());\n\n        registry = _registry;\n    }\n\n    function _convertTokenValueToCurrencyAmount(\n        address pool,\n        address tokenAddress,\n        uint256 tokenValue\n    ) internal view returns (uint256) {\n        uint256 currencyDecimals = ERC20(ISecuritizationPool(pool).underlyingCurrency()).decimals();\n        uint256 tokenDecimals = ERC20(tokenAddress).decimals();\n\n        return\n            currencyDecimals > tokenDecimals\n                ? tokenValue * (10**(currencyDecimals - tokenDecimals))\n                : tokenValue / (10**(tokenDecimals - currencyDecimals));\n    }\n\n    function _convertCurrencyAmountToTokenValue(\n        address pool,\n        address tokenAddress,\n        uint256 currencyAmount\n    ) internal view returns (uint256) {\n        uint256 currencyDecimals = ERC20(ISecuritizationPool(pool).underlyingCurrency()).decimals();\n        uint256 tokenDecimals = ERC20(tokenAddress).decimals();\n\n        return\n            currencyDecimals > tokenDecimals\n                ? currencyAmount / (10**currencyDecimals - tokenDecimals)\n                : currencyAmount * (10**tokenDecimals - currencyDecimals);\n    }\n}\n"
    },
    "contracts/interfaces/ICrowdSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ICrowdSale {\n    mapping(address => uint256) public currencyRaisedByInvestor;\n\n    uint256 public currencyRaised;\n}\n"
    },
    "contracts/protocol/pool/DistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './base/SecuritizationPoolServiceBase.sol';\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\n\ncontract DistributionTranche is SecuritizationPoolServiceBase, IDistributionTranche {\n    using ConfigHelper for Registry;\n\n    modifier onlyOperator() {\n        require(_msgSender() == address(registry.getDistributionOperator()), 'DistributionTranche: Only Operator');\n        _;\n    }\n\n    function redeem(\n        address usr,\n        address pool,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external whenNotPaused nonReentrant onlyOperator {\n        if (tokenAmount > 0) {\n            require(IERC20(notesToken).transfer(pool, tokenAmount), 'DistributionTranche: token-transfer-failed');\n        }\n        ISecuritizationPool(pool).redeem(usr, notesToken, currencyAmount, tokenAmount);\n    }\n\n    function redeemToken(\n        address noteToken,\n        address usr,\n        uint256 tokenAmount\n    ) external whenNotPaused onlyOperator returns (bool) {\n        return IERC20(noteToken).transferFrom(usr, address(this), tokenAmount);\n    }\n}\n"
    },
    "contracts/protocol/pool/DistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport './base/SecuritizationPoolServiceBase.sol';\nimport '../../interfaces/INoteToken.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\ncontract DistributionOperator is SecuritizationPoolServiceBase, IDistributionOperator {\n    using ConfigHelper for Registry;\n\n    enum SettlementType {\n        FEE,\n        REDEEM,\n        PRINCIPAL_REDEEM,\n        INTEREST_REDEEM\n    }\n\n    struct DistributePercent {\n        address investor;\n        uint256 currencyDistribute;\n        uint256 tokenBurn;\n        uint256 paidInterestAmount;\n    }\n\n    event TokensRedeemed(\n        address indexed redeemer,\n        address indexed tokenAddress,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    );\n\n    function makeRedeemRequest(INoteToken noteToken, uint256 tokenAmount) external whenNotPaused nonReentrant {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(noteToken.poolAddress());\n        require(\n            registry.getNoteTokenFactory().isExistingTokens(address(noteToken)),\n            'DistributionOperator: Invalid NoteToken'\n        );\n\n        require(noteToken.balanceOf(_msgSender()) >= tokenAmount, 'DistributionOperator: Invalid token amount');\n\n        IDistributionTranche tranche = registry.getDistributionTranche();\n        require(\n            noteToken.allowance(_msgSender(), address(tranche)) >= tokenAmount,\n            'DistributionOperator: Invalid token allowance'\n        );\n\n        uint256 tokenPrice;\n        uint256 tokenToBeRedeemed;\n        uint256 currencyAmtToBeDistributed;\n        uint256 ONE_TOKEN = 10**uint256(noteToken.decimals());\n        if (securitizationPool.sotToken() == address(noteToken)) {\n            tokenPrice = registry.getDistributionAssessor().getSOTTokenPrice(\n                address(securitizationPool),\n                block.timestamp\n            );\n\n            tokenToBeRedeemed = Math.min(\n                (IERC20(securitizationPool.underlyingCurrency()).balanceOf(securitizationPool.pot()) * ONE_TOKEN) /\n                    tokenPrice,\n                tokenAmount\n            );\n            currencyAmtToBeDistributed = (tokenToBeRedeemed * tokenPrice) / ONE_TOKEN;\n\n            securitizationPool.increaseLockedDistributeBalance(\n                address(noteToken),\n                _msgSender(),\n                currencyAmtToBeDistributed,\n                tokenToBeRedeemed\n            );\n\n            tranche.redeemToken(address(noteToken), _msgSender(), tokenToBeRedeemed);\n        }\n    }\n\n    function redeemBatch(\n        address[] calldata redeemers,\n        address pool,\n        address tokenAddress\n    ) external whenNotPaused nonReentrant {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n\n        for (uint256 i = 0; i < redeemers.length; ++i) {\n            uint256 currencyLocked = securitizationPool.lockedDistributeBalances(tokenAddress, redeemers[i]);\n            uint256 tokenRedeem = securitizationPool.lockedRedeemBalances(tokenAddress, redeemers[i]);\n            if (currencyLocked > 0) {\n                _redeem(\n                    redeemers[i],\n                    pool,\n                    tokenAddress,\n                    tokenRedeem,\n                    currencyLocked,\n                    registry.getDistributionTranche(),\n                    securitizationPool\n                );\n            }\n        }\n    }\n\n    function redeem(\n        address redeemer,\n        address pool,\n        address tokenAddress\n    ) external whenNotPaused nonReentrant returns (uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n\n        uint256 currencyLocked = securitizationPool.lockedDistributeBalances(tokenAddress, redeemer);\n        uint256 tokenRedeem = securitizationPool.lockedRedeemBalances(tokenAddress, redeemer);\n        if (currencyLocked > 0) {\n            _redeem(\n                redeemer,\n                pool,\n                tokenAddress,\n                tokenRedeem,\n                currencyLocked,\n                registry.getDistributionTranche(),\n                securitizationPool\n            );\n        }\n\n        emit TokensRedeemed(redeemer, tokenAddress, currencyLocked, tokenRedeem);\n\n        return currencyLocked;\n    }\n\n    function _redeem(\n        address redeemer,\n        address pool,\n        address tokenAddress,\n        uint256 tokenAmount,\n        uint256 currencyAmount,\n        IDistributionTranche tranche,\n        ISecuritizationPool securitizationPool\n    ) internal {\n        securitizationPool.decreaseLockedDistributeBalance(tokenAddress, redeemer, currencyAmount, tokenAmount);\n\n        tranche.redeem(redeemer, pool, tokenAddress, currencyAmount, tokenAmount);\n    }\n\n    function _calculateAmountDistribute(\n        address investor,\n        address tokenAddress,\n        uint256 totalCurrencyToDistribute,\n        uint256 totalSupply,\n        ISecuritizationPool securitizationPool\n    ) internal view returns (uint256) {\n        uint256 currentToken = IERC20(tokenAddress).balanceOf(investor);\n\n        uint256 tokenRedeem = securitizationPool.lockedRedeemBalances(tokenAddress, investor);\n\n        return ((currentToken - tokenRedeem) * totalCurrencyToDistribute) / totalSupply;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/protocol/pool/DistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport './base/Interest.sol';\nimport './base/SecuritizationPoolServiceBase.sol';\nimport '../../interfaces/INoteToken.sol';\n\ncontract DistributionAssessor is Interest, SecuritizationPoolServiceBase, IDistributionAssessor {\n    using ConfigHelper for Registry;\n\n    // get current individual asset for SOT tranche\n    function getSOTTokenPrice(address pool, uint256 timestamp) public view override returns (uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        ERC20 noteToken = ERC20(securitizationPool.sotToken());\n\n        if (address(noteToken) == address(0) || noteToken.totalSupply() == 0) return 0;\n        uint256 ONE_SOT_DEFAULT_PRICE = _convertTokenValueToCurrencyAmount(\n            address(securitizationPool),\n            address(noteToken),\n            1 * 10**uint256(noteToken.decimals())\n        );\n        uint256 openingBlockTimestamp = securitizationPool.openingBlockTimestamp();\n\n        if (timestamp < openingBlockTimestamp) return ONE_SOT_DEFAULT_PRICE;\n\n        uint32 interestRateSOT = securitizationPool.interestRateSOT();\n\n        return ONE_SOT_DEFAULT_PRICE + _calculateInterestForDuration(ONE_SOT_DEFAULT_PRICE, interestRateSOT, timestamp - openingBlockTimestamp);\n    }\n\n    // get current individual asset for SOT tranche\n    function calcAssetValue(\n        address pool,\n        address tokenAddress,\n        address investor\n    ) external view override returns (uint256 principal, uint256 interest) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n\n        address sotToken = securitizationPool.sotToken();\n        address jotToken = securitizationPool.jotToken();\n\n        require(tokenAddress == sotToken || tokenAddress == jotToken, 'DistributionAssessor: unknown-tranche-address');\n\n        uint256 openingBlockTimestamp = securitizationPool.openingBlockTimestamp();\n\n        if (tokenAddress == sotToken) {\n            uint32 interestRateSOT = securitizationPool.interestRateSOT();\n            uint256 currentPrincipal = IERC20(tokenAddress).balanceOf(investor);\n            uint256 tokenRedeem = securitizationPool.lockedRedeemBalances(sotToken, investor);\n            return\n                _calcSeniorAssetValue(\n                    currentPrincipal - tokenRedeem,\n                    interestRateSOT,\n                    openingBlockTimestamp,\n                    block.timestamp\n                );\n        } else {\n            return _calcPrincipalInterestJOT(pool, jotToken, investor, block.timestamp);\n        }\n    }\n\n    function calcCorrespondingTotalAssetValue(\n        address tokenAddress,\n        address investor,\n        uint256 endTime\n    ) external view override returns (uint256) {\n        (uint256 principal, uint256 interest) = _calcCorrespondingAssetValue(tokenAddress, investor, endTime);\n        return principal + interest;\n    }\n\n    function calcCorrespondingAssetValue(\n        address tokenAddress,\n        address investor,\n        uint256 endTime\n    ) external view returns (uint256 principal, uint256 interest) {\n        return _calcCorrespondingAssetValue(tokenAddress, investor, endTime);\n    }\n\n    function _calcCorrespondingAssetValue(\n        address tokenAddress,\n        address investor,\n        uint256 endTime\n    ) internal view returns (uint256 principal, uint256 interest) {\n        INoteToken notesToken = INoteToken(tokenAddress);\n        ISecuritizationPool securitizationPool = ISecuritizationPool(notesToken.poolAddress());\n\n        if (Configuration.NOTE_TOKEN_TYPE(notesToken.noteTokenType()) == Configuration.NOTE_TOKEN_TYPE.SENIOR) {\n            uint256 openingBlockTimestamp = securitizationPool.openingBlockTimestamp();\n            uint32 interestRateSOT = securitizationPool.interestRateSOT();\n            return\n                _calcPrincipalInterestSOT(\n                    securitizationPool,\n                    tokenAddress,\n                    investor,\n                    interestRateSOT,\n                    openingBlockTimestamp,\n                    endTime\n                );\n        } else {\n            return _calcPrincipalInterestJOT(notesToken.poolAddress(), tokenAddress, investor, endTime);\n        }\n    }\n\n    function calcAssetValue(\n        address pool,\n        address tokenAddress,\n        address[] calldata investors\n    ) external view returns (uint256[] memory principals, uint256[] memory interests) {\n        principals = new uint256[](investors.length);\n        interests = new uint256[](investors.length);\n\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n\n        address sotToken = securitizationPool.sotToken();\n        address jotToken = securitizationPool.jotToken();\n        require(tokenAddress == sotToken || tokenAddress == jotToken, 'DistributionAssessor: unknown-tranche-address');\n\n        uint256 openingBlockTimestamp = securitizationPool.openingBlockTimestamp();\n\n        if (tokenAddress == sotToken) {\n            uint32 interestRateSOT = securitizationPool.interestRateSOT();\n\n            for (uint256 i = 0; i < investors.length; i++) {\n                (uint256 principal, uint256 interest) = _calcPrincipalInterestSOT(\n                    securitizationPool,\n                    sotToken,\n                    investors[i],\n                    interestRateSOT,\n                    openingBlockTimestamp,\n                    block.timestamp\n                );\n\n                principals[i] = principal;\n                interests[i] = interest;\n            }\n        } else {\n            for (uint256 i = 0; i < investors.length; i++) {\n                (uint256 principal, uint256 interest) = _calcPrincipalInterestJOT(\n                    pool,\n                    jotToken,\n                    investors[i],\n                    block.timestamp\n                );\n\n                principals[i] = principal;\n                interests[i] = interest;\n            }\n        }\n    }\n\n    function calcCorrespondingAssetValue(\n        address tokenAddress,\n        address[] calldata investors,\n        uint256 endTime\n    ) external view returns (uint256[] memory principals, uint256[] memory interests) {\n        principals = new uint256[](investors.length);\n        interests = new uint256[](investors.length);\n\n        for (uint256 i = 0; i < investors.length; i++) {\n            (principals[i], interests[i]) = _calcCorrespondingAssetValue(tokenAddress, investors[i], endTime);\n        }\n    }\n\n    function calcTokenPrice(address pool, address tokenAddress) external view override returns (uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        if (tokenAddress == securitizationPool.sotToken())\n            return getSOTTokenPrice(address(securitizationPool), block.timestamp);\n        else if (tokenAddress == securitizationPool.jotToken())\n            return getJOTTokenPrice(securitizationPool, block.timestamp);\n        return 0;\n    }\n\n    function getJOTTokenPrice(ISecuritizationPool securitizationPool, uint256 endTime) public view returns (uint256) {\n        address tokenAddress = securitizationPool.jotToken();\n        uint256 tokenSupply = INoteToken(tokenAddress).totalSupply();\n        if (tokenAddress == address(0) || tokenSupply == 0) {\n            return 0;\n        }\n\n        uint256 currencyDecimals = ERC20(securitizationPool.underlyingCurrency()).decimals();\n        uint256 tokenDecimals = ERC20(tokenAddress).decimals();\n\n        uint256 totalJotValue = _calcJuniorAssetValue(address(securitizationPool), endTime);\n        uint256 totalTokenRedeem = securitizationPool.totalLockedRedeemBalances(tokenAddress);\n        tokenSupply = tokenSupply - totalTokenRedeem;\n\n        return\n            currencyDecimals > tokenDecimals\n                ? (totalJotValue * Configuration.PRICE_SCALING_FACTOR) /\n                    (tokenSupply * 10**(currencyDecimals - tokenDecimals))\n                : (totalJotValue * 10**(tokenDecimals - currencyDecimals) * Configuration.PRICE_SCALING_FACTOR) /\n                    tokenSupply;\n    }\n\n    function calcSeniorAssetValue(address pool, uint256 timestamp) public view returns (address, uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        INoteToken sot = INoteToken(securitizationPool.sotToken());\n\n        uint256 price = getSOTTokenPrice(address(securitizationPool), timestamp);\n        uint256 totalSotSupply = sot.totalSupply();\n        uint256 ONE_SOT = 10**uint256(sot.decimals());\n\n        return (address(sot), (price * totalSotSupply) / ONE_SOT);\n    }\n\n    function getCashBalance(address pool) public view override returns (uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        return\n            IERC20(securitizationPool.underlyingCurrency()).balanceOf(securitizationPool.pot()) -\n            securitizationPool.totalLockedDistributeBalance();\n    }\n\n    function _calcJuniorAssetValue(address pool, uint256 timestamp) internal view returns (uint256) {\n        (, uint256 seniorAssetValue) = calcSeniorAssetValue(pool, timestamp);\n\n        uint256 available = registry.getSecuritizationPoolValueService().getExpectedAssetsValue(pool, timestamp) +\n            this.getCashBalance(pool);\n\n        // senior debt needs to be covered first\n        if (available > seniorAssetValue) {\n            return available - seniorAssetValue;\n        }\n        // currently junior would receive nothing\n        return 0;\n    }\n\n    function _calcPrincipalInterestSOT(\n        ISecuritizationPool securitizationPool,\n        address sotToken,\n        address investor,\n        uint32 interestRateSOT,\n        uint256 openingBlockTimestamp,\n        uint256 timestamp\n    ) internal view returns (uint256 principal, uint256 interest) {\n        uint256 tokenRedeem = securitizationPool.lockedRedeemBalances(sotToken, investor);\n\n        return\n            _calcSeniorAssetValue(\n                IERC20(sotToken).balanceOf(investor) - tokenRedeem,\n                interestRateSOT,\n                openingBlockTimestamp,\n                timestamp\n            );\n    }\n\n    function _calcPrincipalInterestJOT(\n        address pool,\n        address jotToken,\n        address investor,\n        uint256 termEndUnixTimestamp\n    ) internal view returns (uint256 principal, uint256 interest) {\n        uint256 tokenPrice = getJOTTokenPrice(ISecuritizationPool(pool), termEndUnixTimestamp);\n        uint256 currentPrincipal = IERC20(jotToken).balanceOf(investor);\n        if (tokenPrice > Configuration.PRICE_SCALING_FACTOR)\n            return (\n                currentPrincipal,\n                (currentPrincipal * tokenPrice) / Configuration.PRICE_SCALING_FACTOR - currentPrincipal\n            );\n        else return ((currentPrincipal * tokenPrice) / Configuration.PRICE_SCALING_FACTOR, 0);\n    }\n\n    function _getPrincipalLeftOfSOT(ISecuritizationPool securitizationPool, address sotToken)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalPrincipal = 0;\n        uint256 totalTokenRedeem = 0;\n        if (sotToken != address(0x0)) {\n            totalPrincipal = IERC20(sotToken).totalSupply();\n            totalTokenRedeem = securitizationPool.totalLockedRedeemBalances(sotToken);\n        }\n\n        return totalPrincipal - totalTokenRedeem;\n    }\n\n    function _calcSeniorAssetValue(\n        uint256 _currentPrincipalAmount,\n        uint256 _annualInterestRate,\n        uint256 _startTermTimestamp,\n        uint256 _timestamp\n    ) internal pure returns (uint256 principal, uint256 interest) {\n        principal = _currentPrincipalAmount;\n        interest = chargeLendingInterest(_currentPrincipalAmount, _annualInterestRate, _startTermTimestamp, _timestamp);\n    }\n}\n"
    },
    "contracts/protocol/pool/base/Interest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../../libraries/UntangledMath.sol';\n\ncontract Interest {\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n\n    // To convert an encoded interest rate into its equivalent multiplier\n    // (for purposes of calculating total interest), divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 0.01 interest multiplier\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_MULTIPLIER = INTEREST_RATE_SCALING_FACTOR_PERCENT * 100;\n\n    function chargeInterest(\n        uint256 principalAmount,\n        uint256 annualInterestRate,\n        uint256 startTermTimestamp,\n        uint256 timestamp\n    ) public pure returns (uint256) {\n        return _calculateInterestAmountToTimestamp(principalAmount, annualInterestRate, startTermTimestamp, timestamp);\n    }\n\n    function chargeLendingInterest(\n        uint256 _currentPrincipalAmount,\n        uint256 _annualInterestRate,\n        uint256 _startTermTimestamp,\n        uint256 _timestamp\n    ) public pure returns (uint256) {\n        return\n            _calculateInterestAmountToTimestamp(\n                _currentPrincipalAmount,\n                _annualInterestRate,\n                _startTermTimestamp,\n                _timestamp\n            );\n    }\n\n    // Calculate interest amount of fixed amount principal\n    function _calculateInterestAmountToTimestamp(\n        uint256 _principalAmount,\n        uint256 _annualInterestRate,\n        uint256 _startTermTimestamp,\n        uint256 _timestamp\n    ) internal pure returns (uint256) {\n        if (_timestamp <= _startTermTimestamp) {\n            return 0;\n        }\n        uint256 elapseTimeFromStart = _timestamp - _startTermTimestamp;\n\n        return _calculateInterestForDuration(_principalAmount, _annualInterestRate, elapseTimeFromStart);\n    }\n\n    // Calculate interest amount Debtor need to pay until current date\n    function _calculateInterestAmountToTimestamp(\n        uint256 _currentPrincipalAmount,\n        uint256 _paidInterestAmount,\n        uint256 _annualInterestRate,\n        uint256 _startTermTimestamp,\n        uint256 _lastRepayTimestamp,\n        uint256 _timestamp\n    ) internal pure returns (uint256) {\n        if (_timestamp <= _startTermTimestamp) {\n            return 0;\n        }\n        uint256 interest = 0;\n        uint256 elapseTimeFromLastRepay = _timestamp - _lastRepayTimestamp;\n        uint256 elapseTimeFromStart = _timestamp - _startTermTimestamp;\n\n        if (_paidInterestAmount > 0) {\n            // Has made at least 1 repayment\n            interest = _calculateInterestForDuration(\n                _currentPrincipalAmount,\n                _annualInterestRate,\n                elapseTimeFromLastRepay\n            );\n        } else {\n            // Haven't made any repayment\n            interest = _calculateInterestForDuration(_currentPrincipalAmount, _annualInterestRate, elapseTimeFromStart);\n        }\n\n        return interest;\n    }\n\n    // Calculate interest amount for a duration with specific Principal amount\n    function _calculateInterestForDuration(\n        uint256 _principalAmount,\n        uint256 _interestRate,\n        uint256 _durationLengthInSec\n    ) internal pure returns (uint256) {\n        return\n            (_principalAmount *\n                UntangledMath.rpow(\n                    UntangledMath.ONE +\n                        ((_interestRate * (UntangledMath.ONE / INTEREST_RATE_SCALING_FACTOR_PERCENT / 100)) /\n                            YEAR_LENGTH_IN_SECONDS),\n                    _durationLengthInSec,\n                    UntangledMath.ONE\n                )) /\n            UntangledMath.ONE -\n            _principalAmount;\n    }\n}\n"
    },
    "contracts/protocol/note-sale/fab/TokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../../base/UntangledBase.sol';\nimport '../../../interfaces/ITokenGenerationEventFactory.sol';\nimport '../../../libraries/ConfigHelper.sol';\nimport '../../../base/Factory.sol';\n\ncontract TokenGenerationEventFactory is ITokenGenerationEventFactory, UntangledBase, Factory {\n    using ConfigHelper for Registry;\n\n    enum SaleType {\n        MINTED_INCREASING_INTEREST,\n        NORMAL_SALE\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init(_msgSender());\n\n        registry = _registry;\n    }\n\n    modifier onlySecuritizationManager() {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()),\n            'SecuritizationPool: Only SecuritizationManager'\n        );\n        _;\n    }\n\n    function createNewSaleInstance(\n        address issuerTokenController,\n        address pool,\n        address token,\n        address currency,\n        uint8 saleType,\n        bool longSale\n    ) external override onlySecuritizationManager returns (address) {\n        address _tgeInstance;\n\n        if (saleType == uint8(SaleType.MINTED_INCREASING_INTEREST)) {\n            _tgeInstance = _newMintedIncreasingInterestSale(issuerTokenController, pool, token, currency, longSale);\n        } else if (saleType == uint8(SaleType.NORMAL_SALE)) {\n            _tgeInstance = _newNormalSale(issuerTokenController, pool, token, currency, longSale);\n        }\n        else{\n            revert('Unknown sale type');\n        }\n\n        return _tgeInstance;\n    }\n\n    function _newMintedIncreasingInterestSale(\n        address issuerTokenController,\n        address pool,\n        address token,\n        address currency,\n        bool longSale\n    ) private returns (address) {\n        address tgeAddress = deployMinimal(address(registry.getMintedIncreasingInterestTGE()));\n        MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAddress);\n\n        tge.initialize(registry, pool, token, currency, longSale);\n        tge.grantRole(tge.OWNER_ROLE(), issuerTokenController);\n        tge.renounceRole(tge.OWNER_ROLE(), address(this));\n\n        tgeAddresses.push(tgeAddress);\n        isExistingTge[tgeAddress] = true;\n\n        return tgeAddress;\n    }\n\n    function _newNormalSale(\n        address issuerTokenController,\n        address pool,\n        address token,\n        address currency,\n        bool longSale\n    ) private returns (address) {\n        address tgeAddress = deployMinimal(address(registry.getMintedNormalTGE()));\n        MintedNormalTGE tge = MintedNormalTGE(tgeAddress);\n\n        tge.initialize(registry, pool, token, currency, longSale);\n        tge.grantRole(tge.OWNER_ROLE(), issuerTokenController);\n        tge.renounceRole(tge.OWNER_ROLE(), address(this));\n\n        tgeAddresses.push(tgeAddress);\n        isExistingTge[tgeAddress] = true;\n\n        return tgeAddress;\n    }\n\n    function pauseUnpauseTge(address tgeAdress) external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(isExistingTge[tgeAdress], 'TokenGenerationEventFactory: tge does not exist');\n        MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAdress);\n        if (tge.paused()) tge.unpause();\n        tge.pause();\n    }\n\n    function pauseUnpauseAllTges() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < tgeAddresses.length; i++) {\n            MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAddresses[i]);\n            if (tge.paused()) tge.unpause();\n            else tge.pause();\n        }\n    }\n}\n"
    },
    "contracts/protocol/note-sale/fab/NoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../../base/UntangledBase.sol';\nimport '../../../interfaces/INoteTokenFactory.sol';\nimport '../../../libraries/ConfigHelper.sol';\n\ncontract NoteTokenFactory is UntangledBase, INoteTokenFactory {\n    using ConfigHelper for Registry;\n\n    modifier onlySecuritizationManager() {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()),\n            'SecuritizationPool: Only SecuritizationManager'\n        );\n        _;\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init(_msgSender());\n\n        registry = _registry;\n    }\n\n    function changeMinterRole(address tokenAddress, address newController) external override onlySecuritizationManager {\n        NoteToken token = NoteToken(tokenAddress);\n        token.grantRole(token.MINTER_ROLE(), newController);\n    }\n\n    function createToken(\n        address _poolAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteTokenType,\n        uint8 _nDecimals\n    ) external override whenNotPaused nonReentrant onlySecuritizationManager returns (address) {\n        string memory name;\n        string memory symbol;\n        if (_noteTokenType == Configuration.NOTE_TOKEN_TYPE.SENIOR) {\n            name = 'Senior Obligation Token';\n            symbol = 'SOT';\n        } else {\n            name = 'Junior Obligation Token';\n            symbol = 'JOT';\n        }\n        NoteToken token = new NoteToken(name, symbol, _nDecimals, _poolAddress, uint8(_noteTokenType));\n\n        tokens.push(token);\n        isExistingTokens[address(token)] = true;\n\n        return address(token);\n    }\n\n    function pauseUnpauseToken(address tokenAddress) external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(isExistingTokens[tokenAddress], 'NoteTokenFactory: token does not exist');\n        NoteToken token = NoteToken(tokenAddress);\n        if (token.paused()) {\n            token.unpause();\n        } else {\n            token.pause();\n        }\n    }\n\n    function pauseAllTokens() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!tokens[i].paused()) tokens[i].pause();\n        }\n    }\n\n    function unPauseAllTokens() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (tokens[i].paused()) tokens[i].unpause();\n        }\n    }\n}\n"
    },
    "contracts/protocol/loan/LoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../interfaces/ILoanRegistry.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../libraries/ConfigHelper.sol';\n\ncontract LoanRegistry is UntangledBase, ILoanRegistry {\n    using ConfigHelper for Registry;\n\n    /** CONSTRUCTOR */\n    function initialize(Registry _registry) public override initializer {\n        __UntangledBase__init(_msgSender());\n        registry = _registry;\n    }\n\n    modifier onlyLoanKernel() {\n        require(_msgSender() == address(registry.getLoanKernel()), 'LoanRegistry: Only LoanKernel');\n        _;\n    }\n\n    modifier onlyLoanInterestTermsContract() {\n        require(\n            _msgSender() == address(registry.getLoanInterestTermsContract()),\n            'Invoice Debt Registry: Only LoanInterestTermsContract'\n        );\n        _;\n    }\n\n    /**\n     * Record new Loan to blockchain\n     */\n    function insert(\n        bytes32 tokenId,\n        address termContract,\n        address debtor,\n        bytes32 termsContractParameter,\n        address pTokenAddress,\n        uint256 _salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] calldata assetPurposeAndRiskScore\n    ) external override whenNotPaused nonReentrant onlyLoanKernel returns (bool) {\n        require(termContract != address(0x0), 'LoanRegistry: Invalid term contract');\n        LoanEntry memory newEntry = LoanEntry({\n            loanTermContract: termContract,\n            debtor: debtor,\n            principalTokenAddress: pTokenAddress,\n            termsParam: termsContractParameter,\n            salt: _salt, //solium-disable-next-line security\n            issuanceBlockTimestamp: block.timestamp,\n            lastRepayTimestamp: 0,\n            expirationTimestamp: expirationTimestampInSecs,\n            assetPurpose: Configuration.ASSET_PURPOSE(assetPurposeAndRiskScore[0]),\n            riskScore: assetPurposeAndRiskScore[1]\n        });\n        entries[tokenId] = newEntry;\n        return true;\n    }\n\n    function getLoanDebtor(bytes32 tokenId) public view override returns (address) {\n        return entries[tokenId].debtor;\n    }\n\n    function getLoanTermParams(bytes32 tokenId) public view override returns (bytes32) {\n        LoanEntry memory entry = entries[tokenId];\n        return entry.termsParam;\n    }\n\n    function getPrincipalTokenAddress(bytes32 agreementId) public view override returns (address) {\n        return entries[agreementId].principalTokenAddress;\n    }\n\n    function getDebtor(bytes32 agreementId) public view override returns (address) {\n        return entries[agreementId].debtor;\n    }\n\n    function getTermContract(bytes32 agreementId) public view override returns (address) {\n        return entries[agreementId].loanTermContract;\n    }\n\n    function getRiskScore(bytes32 agreementId) public view override returns (uint8) {\n        return entries[agreementId].riskScore;\n    }\n\n    function getAssetPurpose(bytes32 agreementId) public view override returns (Configuration.ASSET_PURPOSE) {\n        return entries[agreementId].assetPurpose;\n    }\n\n    /**\n     * Returns the timestamp of the block at which a debt agreement was issued.\n     */\n    function getIssuanceBlockTimestamp(bytes32 agreementId) public view override returns (uint256 timestamp) {\n        return entries[agreementId].issuanceBlockTimestamp;\n    }\n\n    function getLastRepaymentTimestamp(bytes32 agreementId) public view override returns (uint256 timestamp) {\n        return entries[agreementId].lastRepayTimestamp;\n    }\n\n    /**\n     * Returns the terms contract parameters of a given issuance\n     */\n    function getTermsContractParameters(bytes32 agreementId) public view override returns (bytes32) {\n        return entries[agreementId].termsParam;\n    }\n\n    function getExpirationTimestamp(bytes32 agreementId) public view override returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        return entries[agreementId].expirationTimestamp;\n    }\n\n    // Update timestamp of the last repayment from Debtor\n    function updateLastRepaymentTimestamp(bytes32 agreementId, uint256 newTimestamp)\n        public\n        override\n        onlyLoanInterestTermsContract\n    {\n        entries[agreementId].lastRepayTimestamp = newTimestamp;\n    }\n\n    /// @dev Get principal payment info before start doing repayment\n    function principalPaymentInfo(bytes32 agreementId)\n        public\n        view\n        override\n        returns (address pTokenAddress, uint256 pAmount)\n    {\n        LoanEntry memory entry = entries[agreementId];\n        pTokenAddress = entry.principalTokenAddress;\n        pAmount = 0; // @TODO\n    }\n\n    function setCompletedLoan(bytes32 agreementId) public override whenNotPaused nonReentrant onlyLoanInterestTermsContract {\n        completedLoans[agreementId] = true;\n    }\n}\n"
    },
    "contracts/tokens/ERC721/LoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../interfaces/ILoanRegistry.sol';\nimport '../../interfaces/ILoanInterestTermsContract.sol';\nimport '../../interfaces/IUntangledERC721.sol';\nimport '../../libraries/ConfigHelper.sol';\n\n/**\n * LoanAssetToken: The representative for ownership of a Loan\n */\ncontract LoanAssetToken is IUntangledERC721 {\n    using ConfigHelper for Registry;\n\n    /** CONSTRUCTOR */\n    function initialize(\n        Registry _registry,\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) public initializer {\n        __UntangledERC721__init(name, symbol, baseTokenURI);\n\n        registry = _registry;\n\n        _setupRole(MINTER_ROLE, address(registry.getLoanKernel()));\n        renounceRole(MINTER_ROLE, _msgSender());\n    }\n\n    function getExpectedRepaymentValues(uint256 tokenId, uint256 timestamp)\n        public\n        view\n        returns (uint256 expectedPrincipal, uint256 expectedInterest)\n    {\n        bytes32 agreementId = bytes32(tokenId);\n        (expectedPrincipal, expectedInterest) = registry.getLoanInterestTermsContract().getExpectedRepaymentValues(\n            agreementId,\n            timestamp\n        );\n    }\n\n    function getExpirationTimestamp(uint256 _tokenId) public view override returns (uint256) {\n        return registry.getLoanRegistry().getExpirationTimestamp(bytes32(_tokenId));\n    }\n\n    function getRiskScore(uint256 _tokenId) public view override returns (uint8) {\n        return registry.getLoanRegistry().getRiskScore(bytes32(_tokenId));\n    }\n\n    function getAssetPurpose(uint256 _tokenId) public view override returns (Configuration.ASSET_PURPOSE) {\n        return registry.getLoanRegistry().getAssetPurpose(bytes32(_tokenId));\n    }\n\n    function getInterestRate(uint256 _tokenId) public view override returns (uint256 beneficiary) {\n        return registry.getLoanInterestTermsContract().getInterestRate(bytes32(_tokenId));\n    }\n\n    function getTotalExpectedRepaymentValue(uint256 agreementId, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 expectedRepaymentValue)\n    {\n        uint256 principalAmount;\n        uint256 interestAmount;\n        (principalAmount, interestAmount) = getExpectedRepaymentValues(agreementId, timestamp);\n        expectedRepaymentValue = principalAmount + interestAmount;\n    }\n}\n"
    },
    "contracts/protocol/loan/LoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '../../interfaces/ILoanInterestTermsContract.sol';\nimport '../../interfaces/ISecuritizationPool.sol';\nimport '../../interfaces/ILoanRegistry.sol';\nimport '../../interfaces/ILoanRepaymentRouter.sol';\nimport '../../libraries/ConfigHelper.sol';\n\n/**\n * Repayment Router smart contract for Loan\n */\ncontract LoanRepaymentRouter is ILoanRepaymentRouter {\n    using ConfigHelper for Registry;\n\n    function initialize(Registry _registry) public override initializer {\n        __UntangledBase__init(_msgSender());\n        registry = _registry;\n    }\n\n    function _assertRepaymentRequest(\n        bytes32 _agreementId,\n        address _payer,\n        uint256 _amount,\n        address _tokenAddress\n    ) private returns (bool) {\n        require(_tokenAddress != address(0), 'Token address must different with NULL.');\n        require(_amount > 0, 'Amount must greater than 0.');\n\n        // Ensure agreement exists.\n        if (registry.getLoanAssetToken().ownerOf(uint256(_agreementId)) == address(0)) {\n            emit LogError(uint8(Errors.DEBT_AGREEMENT_NONEXISTENT), _agreementId);\n            return false;\n        }\n\n        // Check payer has sufficient balance and has granted router sufficient allowance.\n        if (\n            IERC20(_tokenAddress).balanceOf(_payer) < _amount ||\n            IERC20(_tokenAddress).allowance(_payer, address(this)) < _amount\n        ) {\n            emit LogError(uint8(Errors.PAYER_BALANCE_OR_ALLOWANCE_INSUFFICIENT), _agreementId);\n            return false;\n        }\n        return true;\n    }\n\n    function _doRepay(\n        bytes32 _agreementId,\n        address _payer,\n        uint256 _amount,\n        address _tokenAddress\n    ) private returns (bool) {\n        // Notify terms contract\n\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n        address termsContract = loanRegistry.getTermContract(_agreementId);\n        address beneficiary = registry.getLoanAssetToken().ownerOf(uint256(_agreementId));\n\n        uint256 remains = ILoanInterestTermsContract(termsContract).registerRepayment(\n            _agreementId,\n            _payer,\n            beneficiary,\n            _amount,\n            _tokenAddress\n        );\n\n        // Transfer amount to creditor\n        if (_payer != address(0x0)) {\n            if (registry.getSecuritizationManager().isExistingPools(beneficiary))\n                beneficiary = ISecuritizationPool(beneficiary).pot();\n            require(\n                IERC20(_tokenAddress).transferFrom(_payer, beneficiary, _amount - remains),\n                'Unsuccessfully transferred repayment amount to Creditor.'\n            );\n        }\n\n        // Log event for repayment\n        emit LogRepayment(_agreementId, _payer, beneficiary, _amount, _tokenAddress);\n        return true;\n    }\n\n    function repayInBatch(\n        bytes32[] calldata agreementIds,\n        uint256[] calldata amounts,\n        address tokenAddress\n    ) external override whenNotPaused nonReentrant returns (bool) {\n        for (uint256 i = 0; i < agreementIds.length; i++) {\n            require(\n                _assertRepaymentRequest(agreementIds[i], _msgSender(), amounts[i], tokenAddress),\n                'LoanRepaymentRouter: Invalid repayment request'\n            );\n            require(\n                _doRepay(agreementIds[i], _msgSender(), amounts[i], tokenAddress),\n                'LoanRepaymentRouter: Repayment has failed'\n            );\n        }\n        emit LogRepayments(agreementIds, _msgSender(), amounts);\n        return true;\n    }\n}\n"
    },
    "contracts/protocol/loan/LoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../base/UntangledBase.sol';\nimport '../../interfaces/ILoanInterestTermsContract.sol';\nimport '../../libraries/UnpackLoanParamtersLib.sol';\nimport '../../libraries/UntangledMath.sol';\nimport '../../libraries/ConfigHelper.sol';\n\ncontract LoanInterestTermsContract is UntangledBase, ILoanInterestTermsContract {\n    using ConfigHelper for Registry;\n\n    uint256 public constant NUM_AMORTIZATION_UNIT_TYPES = 6;\n\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint256 public constant WEEK_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 7;\n    uint256 public constant MONTH_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 30;\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n\n    // To convert an encoded interest rate into its equivalent multiplier\n    // (for purposes of calculating total interest), divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 0.01 interest multiplier\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_MULTIPLIER = INTEREST_RATE_SCALING_FACTOR_PERCENT * 100;\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n\n        registry = _registry;\n    }\n\n    //////////////////////////////\n    // EVENTS                 ///\n    ////////////////////////////\n    event LogInterestTermStart(\n        bytes32 indexed agreementId,\n        address indexed principalToken,\n        uint256 principalAmount,\n        uint256 interestRate,\n        uint256 indexed amortizationUnitType,\n        uint256 termLengthInAmortizationUnits\n    );\n\n    event LogRegisterRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    );\n\n    event LogRegisterCompleteTerm(bytes32 agreementId);\n\n    //////////////////////////////\n    // MODIFIERS              ///\n    ////////////////////////////\n    modifier onlyKernel() {\n        require(_msgSender() == address(registry.getLoanKernel()), 'LoanInterestTermsContract: Only for LoanKernel.');\n        _;\n    }\n\n    modifier onlyRouter() {\n        require(\n            _msgSender() == address(registry.getLoanRepaymentRouter()),\n            'LoanInterestTermsContract: Only for Repayment Router.'\n        );\n        _;\n    }\n\n    modifier onlyHaventStartedLoan(bytes32 agreementId) {\n        require(!startedLoan[agreementId], 'LoanInterestTermsContract: Loan has started!');\n        _;\n    }\n\n    function _addRepaidPrincipalAmount(bytes32 agreementId, uint256 repaidAmount) private {\n        repaidPrincipalAmounts[agreementId] += repaidAmount;\n    }\n\n    function _addRepaidInterestAmount(bytes32 agreementId, uint256 repaidAmount) private {\n        repaidInterestAmounts[agreementId] += repaidAmount;\n    }\n\n    function _setCompletedRepayment(bytes32 agreementId) private {\n        completedRepayment[agreementId] = true;\n    }\n\n    // Register to start Loan term for batch of agreement Ids\n    function registerTermStart(bytes32 agreementId)\n        public\n        override\n        whenNotPaused\n        onlyKernel\n        onlyHaventStartedLoan(agreementId)\n        returns (bool)\n    {\n        startedLoan[agreementId] = true;\n        return true;\n    }\n\n    function registerConcludeLoan(bytes32 agreementId)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlyKernel\n        returns (bool)\n    {\n        require(completedRepayment[agreementId], 'Debtor has not completed repayment yet.');\n\n        registry.getLoanRegistry().setCompletedLoan(agreementId);\n\n        emit LogRegisterCompleteTerm(agreementId);\n        return true;\n    }\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  payer address. The address of the payer.\n    /// @param  beneficiary address. The address of the payment's beneficiary.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    function registerRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public override onlyRouter returns (uint256 remains) {\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n        require(\n            tokenAddress == loanRegistry.getPrincipalTokenAddress(agreementId),\n            'LoanTermsContract: Invalid token for repayment.'\n        );\n        require(\n            !loanRegistry.completedLoans(agreementId),\n            'LoanTermsContract: Completed Loan.'\n        );\n        require(\n            startedLoan[agreementId],\n            'LoanTermsContract: Loan has not started yet.'\n        );\n\n        uint256 currentTimestamp = block.timestamp;\n\n        uint256 expectedPrincipal;\n        uint256 expectedInterest;\n        // query total outstanding amounts\n        (expectedPrincipal, expectedInterest) = getExpectedRepaymentValues(agreementId, currentTimestamp);\n        // TODO: Currently only allow Debtor to repay with amount >= expectedInterest of that time\n        // Because, we haven't made any mechanism to manage outstanding interest amounts in the case when Debtor\n        // repaid with amount < expectedInterest (at that moment)\n        require(unitsOfRepayment >= expectedInterest, 'LoanTermsContract: Expected interest amount is minimum.');\n\n        // exceed expectation, Debtor can pay all at once\n        if (unitsOfRepayment >= expectedPrincipal + expectedInterest) {\n            _setCompletedRepayment(agreementId);\n            _addRepaidInterestAmount(agreementId, expectedInterest);\n            _addRepaidPrincipalAmount(agreementId, expectedPrincipal);\n            // put the remain to interest\n            remains = unitsOfRepayment - (expectedPrincipal + expectedInterest);\n        } else {\n            // if currently Debtor no need to repay for interest\n            if (expectedInterest == 0) {\n                _addRepaidPrincipalAmount(agreementId, unitsOfRepayment);\n            } else {\n                // if expectedInterest > 0 ( & unitsOfRepayment >= expectedInterest)\n                _addRepaidInterestAmount(agreementId, expectedInterest);\n                if (unitsOfRepayment - expectedInterest > 0) {\n                    // Debtor is not able to fulfill the expectedPrincipal as we already validated from first IF statement\n                    // -> there is no remains for adding to repaidInterestAmount\n                    _addRepaidPrincipalAmount(agreementId, unitsOfRepayment - expectedInterest);\n                }\n            }\n        }\n\n        // Update Debt registry record\n        loanRegistry.updateLastRepaymentTimestamp(agreementId, currentTimestamp);\n        // loanRegistry.selfEvaluateCollateralRatio(agreementId);\n\n        // Emit new event\n        emit LogRegisterRepayment(agreementId, payer, beneficiary, unitsOfRepayment, tokenAddress);\n\n        return remains;\n    }\n\n    function getValueRepaidToDate(bytes32 agreementId) public view override returns (uint256, uint256) {\n        return (repaidPrincipalAmounts[agreementId], repaidInterestAmounts[agreementId]);\n    }\n\n    function isCompletedRepayments(bytes32[] memory agreementIds) public view override returns (bool[] memory) {\n        bool[] memory result = new bool[](agreementIds.length);\n        for (uint256 i = 0; i < agreementIds.length; i++) {\n            result[i] = completedRepayment[agreementIds[i]];\n        }\n        return result;\n    }\n\n    /**\n     * Expected repayment value with Amortization of Interest and Principal\n     * (AMORTIZATION) - will be used for repayment from Debtor\n     */\n    function getExpectedRepaymentValues(bytes32 agreementId, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 expectedPrincipal, uint256 expectedInterest)\n    {\n        UnpackLoanParamtersLib.InterestParams memory params = _unpackParamsForAgreementID(agreementId);\n\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n\n        uint256 repaidPrincipalAmount = repaidPrincipalAmounts[agreementId];\n        uint256 repaidInterestAmount = repaidInterestAmounts[agreementId];\n        uint256 lastRepaymentTimestamp = loanRegistry.getLastRepaymentTimestamp(agreementId);\n\n        bool isManualInterestLoan = loanRegistry.manualInterestLoan(agreementId);\n        uint256 manualInterestAmountLoan;\n        if (isManualInterestLoan) {\n            manualInterestAmountLoan = loanRegistry.manualInterestAmountLoan(agreementId);\n        }\n\n        (expectedPrincipal, expectedInterest) = _getExpectedRepaymentValuesToTimestamp(\n            params,\n            lastRepaymentTimestamp,\n            timestamp,\n            repaidPrincipalAmount,\n            repaidInterestAmount,\n            isManualInterestLoan,\n            manualInterestAmountLoan\n        );\n    }\n\n    function getMultiExpectedRepaymentValues(bytes32[] memory agreementIds, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256[] memory expectedPrincipals = new uint256[](agreementIds.length);\n        uint256[] memory expectedInterests = new uint256[](agreementIds.length);\n        for (uint256 i = 0; i < agreementIds.length; i++) {\n            (uint256 expectedPrincipal, uint256 expectedInterest) = getExpectedRepaymentValues(\n                agreementIds[i],\n                timestamp\n            );\n            expectedPrincipals[i] = expectedPrincipal;\n            expectedInterests[i] = expectedInterest;\n        }\n        return (expectedPrincipals, expectedInterests);\n    }\n\n    function getInterestRate(bytes32 agreementId) public view override returns (uint256) {\n        return _unpackParamsForAgreementID(agreementId).interestRate;\n    }\n\n    function _getAmortizationUnitLengthInSeconds(UnpackLoanParamtersLib.AmortizationUnitType amortizationUnitType)\n        private\n        pure\n        returns (uint256)\n    {\n        if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.MINUTES) {\n            return MINUTE_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.HOURS) {\n            return HOUR_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.DAYS) {\n            return DAY_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.WEEKS) {\n            return WEEK_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.MONTHS) {\n            return MONTH_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.YEARS) {\n            return YEAR_LENGTH_IN_SECONDS;\n        } else {\n            revert('Unknown amortization unit type.');\n        }\n    }\n\n    /**\n     *   Get parameters by Agreement ID (commitment hash)\n     */\n    function _unpackParamsForAgreementID(bytes32 agreementId)\n        private\n        view\n        returns (UnpackLoanParamtersLib.InterestParams memory params)\n    {\n        bytes32 parameters;\n        uint256 issuanceBlockTimestamp = 0;\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n        issuanceBlockTimestamp = loanRegistry.getIssuanceBlockTimestamp(agreementId);\n        parameters = loanRegistry.getTermsContractParameters(agreementId);\n        // The principal amount denominated in the aforementioned token.\n        uint256 principalAmount;\n        // The interest rate accrued per amortization unit.\n        uint256 interestRate;\n        // The amortization unit in which the repayments installments schedule is defined.\n        uint256 rawAmortizationUnitType;\n        // The debt's entire term's length, denominated in the aforementioned amortization units\n        uint256 termLengthInAmortizationUnits;\n        uint256 gracePeriodInDays;\n\n        (\n            principalAmount,\n            interestRate,\n            rawAmortizationUnitType,\n            termLengthInAmortizationUnits,\n            gracePeriodInDays\n        ) = UnpackLoanParamtersLib.unpackParametersFromBytes(parameters);\n\n        UnpackLoanParamtersLib.AmortizationUnitType amortizationUnitType = UnpackLoanParamtersLib.AmortizationUnitType(\n            rawAmortizationUnitType\n        );\n\n        // Calculate term length base on Amortization Unit and number\n        uint256 termLengthInSeconds = termLengthInAmortizationUnits *\n            _getAmortizationUnitLengthInSeconds(amortizationUnitType);\n\n        return\n            UnpackLoanParamtersLib.InterestParams({\n                principalAmount: principalAmount,\n                interestRate: interestRate,\n                termStartUnixTimestamp: issuanceBlockTimestamp,\n                termEndUnixTimestamp: termLengthInSeconds + issuanceBlockTimestamp,\n                amortizationUnitType: amortizationUnitType,\n                termLengthInAmortizationUnits: termLengthInAmortizationUnits\n            });\n    }\n\n    // Calculate interest amount for a duration with specific Principal amount\n    function _calculateInterestForDuration(\n        uint256 _principalAmount,\n        uint256 _interestRate,\n        uint256 _durationLengthInSec\n    ) private pure returns (uint256) {\n        return\n            (_principalAmount *\n                UntangledMath.rpow(\n                    UntangledMath.ONE +\n                        (_interestRate * (UntangledMath.ONE / INTEREST_RATE_SCALING_FACTOR_PERCENT / 100)) /\n                        YEAR_LENGTH_IN_SECONDS,\n                    _durationLengthInSec,\n                    UntangledMath.ONE\n                )) /\n            UntangledMath.ONE -\n            _principalAmount;\n    }\n\n    /**\n     * Calculate values which Debtor need to pay to conclude current Loan\n     */\n    function _getExpectedRepaymentValuesToTimestamp(\n        UnpackLoanParamtersLib.InterestParams memory _params,\n        uint256 _lastRepaymentTimestamp, // timestamp of last repayment from debtor\n        uint256 _timestamp,\n        uint256 repaidPrincipalAmount,\n        uint256 repaidInterestAmount,\n        bool isManualInterestLoan,\n        uint256 manualInterestAmountLoan\n    ) private pure returns (uint256 expectedPrinciapal, uint256 expectedInterest) {\n        uint256 outstandingPrincipal = _params.principalAmount - repaidPrincipalAmount;\n\n        expectedPrinciapal = outstandingPrincipal;\n\n        if (isManualInterestLoan) {\n            expectedInterest = manualInterestAmountLoan;\n        } else {\n            expectedInterest = _calculateInterestAmountToTimestamp(\n                _params.principalAmount,\n                outstandingPrincipal,\n                repaidInterestAmount,\n                _params.interestRate,\n                _params.termStartUnixTimestamp,\n                _params.termEndUnixTimestamp,\n                _lastRepaymentTimestamp,\n                _timestamp\n            );\n        }\n    }\n\n    // Calculate interest amount Debtor need to pay until current date\n    function _calculateInterestAmountToTimestamp(\n        uint256 _principalAmount,\n        uint256 _currentPrincipalAmount,\n        uint256 _paidInterestAmount,\n        uint256 _annualInterestRate,\n        uint256 _startTermTimestamp,\n        uint256 _endTermTimestamp,\n        uint256 _lastRepayTimestamp,\n        uint256 _timestamp\n    ) private pure returns (uint256) {\n        if (_timestamp <= _startTermTimestamp) {\n            return 0;\n        }\n        uint256 interest = 0;\n        uint256 elapseTimeFromLastRepay = _timestamp - _lastRepayTimestamp;\n        uint256 elapseTimeFromStart = _timestamp - _startTermTimestamp;\n\n        // If still within the term length\n        if (_timestamp < _endTermTimestamp) {\n            // Have just made new repayment\n            if (elapseTimeFromLastRepay == 0 && _paidInterestAmount > 0) {\n                interest = 0;\n            } else {\n                if (_paidInterestAmount > 0) {\n                    // Has made at least 1 repayment\n                    interest = _calculateInterestForDuration(\n                        _currentPrincipalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromLastRepay\n                    );\n                } else {\n                    // Haven't made any repayment\n                    interest = _calculateInterestForDuration(\n                        _principalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromStart\n                    );\n                }\n            }\n        } else if (_timestamp >= _endTermTimestamp) {\n            // If debtor has made at least 1 repayment\n            if (_paidInterestAmount > 0) {\n                interest = _calculateInterestForDuration(\n                    _currentPrincipalAmount,\n                    _annualInterestRate,\n                    elapseTimeFromLastRepay\n                );\n            } else {\n                interest = _calculateInterestForDuration(_principalAmount, _annualInterestRate, elapseTimeFromStart);\n            }\n        } else {\n            interest = 0;\n        }\n        return interest;\n    }\n}\n"
    },
    "contracts/protocol/loan/LoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../interfaces/ILoanKernel.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../libraries/ConfigHelper.sol';\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\n\ncontract LoanKernel is ILoanKernel, UntangledBase {\n    using ConfigHelper for Registry;\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n\n        registry = _registry;\n    }\n\n    modifier validFillingOrderAddresses(address[] memory _orderAddresses) {\n        require(_orderAddresses[uint8(FillingAddressesIndex.CREDITOR)] != address(0x0), 'CREDITOR is zero address.');\n        require(_orderAddresses[uint8(FillingAddressesIndex.REPAYMENT_ROUTER)] != address(0x0), 'REPAYMENT_ROUTER is zero address.');\n        require(_orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)] != address(0x0), 'TERM_CONTRACT is zero address.');\n        require(_orderAddresses[uint8(FillingAddressesIndex.PRINCIPAL_TOKEN_ADDRESS)] != address(0x0), 'PRINCIPAL_TOKEN_ADDRESS is zero address.');\n        _;\n    }\n\n    //******************** */\n    // PRIVATE FUNCTIONS\n    //******************** */\n\n    /**\n     * Helper function that constructs a issuance structs from the given\n     * parameters.\n     */\n    function _getIssuance(\n        address[] memory _orderAddresses,\n        address[] memory _debtors,\n        bytes32[] memory _termsContractParameters,\n        uint256[] memory _salts\n    ) private pure returns (LoanIssuance memory _issuance) {\n        LoanIssuance memory issuance = LoanIssuance({\n            version: _orderAddresses[uint8(FillingAddressesIndex.REPAYMENT_ROUTER)],\n            debtors: _debtors,\n            termsContract: _orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)],\n            termsContractParameters: _termsContractParameters,\n            salts: _salts,\n            agreementIds: _genLoanAgreementIds(\n                _orderAddresses[uint8(FillingAddressesIndex.REPAYMENT_ROUTER)],\n                _debtors,\n                _orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)],\n                _termsContractParameters,\n                _salts\n            )\n        });\n\n        return issuance;\n    }\n\n    /**\n     * Returns the hash of the debt order.\n     */\n    function _getDebtOrderHash(\n        bytes32 agreementId,\n        uint256 principalAmount,\n        uint256 principalTokenIndex,\n        address relayer,\n        uint256 expirationTimestampInSec\n    ) private view returns (bytes32 _debtorMessageHash) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    address(this),\n                    agreementId,\n                    principalAmount,\n                    principalTokenIndex,\n                    relayer,\n                    expirationTimestampInSec\n                )\n            );\n    }\n\n    function _getDebtOrderHashes(LoanOrder memory debtOrder) private view returns (bytes32[] memory) {\n        uint256 _length = debtOrder.issuance.debtors.length;\n        bytes32[] memory orderHashses = new bytes32[](_length);\n        for (uint256 i = 0; i < _length; i++) {\n            orderHashses[i] = _getDebtOrderHash(\n                debtOrder.issuance.agreementIds[i],\n                debtOrder.principalAmounts[i],\n                debtOrder.principalTokenAddress,\n                debtOrder.relayer,\n                debtOrder.expirationTimestampInSecs[i]\n            );\n        }\n        return orderHashses;\n    }\n\n    function _getLoanOrder(\n        address[] memory _debtors,\n        address[] memory _orderAddresses,\n        uint256[] memory _orderValues,\n        bytes32[] memory _termContractParameters,\n        uint256[] memory _salts\n    ) private view returns (LoanOrder memory _debtOrder) {\n        bytes32[] memory emptyDebtOrderHashes = new bytes32[](_debtors.length);\n        LoanOrder memory debtOrder = LoanOrder({\n            issuance: _getIssuance(_orderAddresses, _debtors, _termContractParameters, _salts),\n            relayer: _orderAddresses[uint8(FillingAddressesIndex.RELAYER)],\n            principalTokenAddress: _orderAddresses[uint8(FillingAddressesIndex.PRINCIPAL_TOKEN_ADDRESS)],\n            principalAmounts: _principalAmountsFromOrderValues(_orderValues, _termContractParameters.length),\n            creditorFee: _orderValues[uint8(FillingNumbersIndex.CREDITOR_FEE)],\n            expirationTimestampInSecs: _expirationTimestampsFromOrderValues(\n                _orderValues,\n                _termContractParameters.length\n            ),\n            debtOrderHashes: emptyDebtOrderHashes,\n            riskScores: _riskScoresFromOrderValues(_orderValues, _termContractParameters.length),\n            assetPurpose: uint8(_orderValues[uint8(FillingNumbersIndex.ASSET_PURPOSE)])\n        });\n        debtOrder.debtOrderHashes = _getDebtOrderHashes(debtOrder);\n        return debtOrder;\n    }\n\n    //** Issue Loan to Farmers */\n    function _issueDebtAgreements(\n        bytes32 latTokenId,\n        address creditor,\n        address termContract,\n        address debtor,\n        bytes32 termsParam,\n        address principalTokenAddress,\n        uint256 salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] memory assetPurposeAndRiskScore\n    ) private {\n        // Mint debt tokens and finalize debt agreement\n\n        registry.getLoanAssetToken().mint(creditor, uint256(latTokenId));\n\n        registry.getLoanRegistry().insert(\n            latTokenId,\n            termContract,\n            debtor,\n            termsParam,\n            principalTokenAddress,\n            salt,\n            expirationTimestampInSecs,\n            assetPurposeAndRiskScore\n        );\n    }\n\n    /**\n     * 6 is fixed size of constant addresses list\n     */\n    function _debtorsFromOrderAddresses(address[] memory _orderAddresses, uint256 _length)\n        private\n        pure\n        returns (address[] memory)\n    {\n        address[] memory debtors = new address[](_length);\n        for (uint256 i = 5; i < (5 + _length); i++) {\n            debtors[i - 5] = _orderAddresses[i];\n        }\n        return debtors;\n    }\n\n    // Dettach principal amounts from order values\n    function _principalAmountsFromOrderValues(uint256[] memory _orderValues, uint256 _length)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory principalAmounts = new uint256[](_length);\n        for (uint256 i = 2; i < (2 + _length); i++) {\n            principalAmounts[i - 2] = _orderValues[i];\n        }\n        return principalAmounts;\n    }\n\n    function _expirationTimestampsFromOrderValues(uint256[] memory _orderValues, uint256 _length)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory expirationTimestamps = new uint256[](_length);\n        for (uint256 i = 2 + _length; i < (2 + _length * 2); i++) {\n            expirationTimestamps[i - 2 - _length] = _orderValues[i];\n        }\n        return expirationTimestamps;\n    }\n\n    function _saltFromOrderValues(uint256[] memory _orderValues, uint256 _length)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory salts = new uint256[](_length);\n        for (uint256 i = 2 + _length * 2; i < (2 + _length * 3); i++) {\n            salts[i - 2 - _length * 2] = _orderValues[i];\n        }\n        return salts;\n    }\n\n    function _riskScoresFromOrderValues(uint256[] memory _orderValues, uint256 _length)\n        private\n        pure\n        returns (uint8[] memory)\n    {\n        uint8[] memory riskScores = new uint8[](_length);\n        for (uint256 i = 2 + _length * 3; i < (2 + _length * 4); i++) {\n            riskScores[i - 2 - _length * 3] = uint8(_orderValues[i]);\n        }\n        return riskScores;\n    }\n\n    function _getAssetPurposeAndRiskScore(uint8 assetPurpose, uint8 riskScore) private pure returns (uint8[] memory) {\n        uint8[] memory assetPurposeAndRiskScore = new uint8[](2);\n        assetPurposeAndRiskScore[0] = assetPurpose;\n        assetPurposeAndRiskScore[1] = riskScore;\n        return assetPurposeAndRiskScore;\n    }\n\n    function _burnLoanAssetToken(bytes32 agreementId) private {\n        registry.getLoanAssetToken().burn(uint256(agreementId));\n    }\n\n    function _assertDebtExisting(bytes32 agreementId) private view returns (bool) {\n        return registry.getLoanAssetToken().ownerOf(uint256(agreementId)) != address(0);\n    }\n\n    function _assertCompletedRepayment(bytes32 agreementId) private view returns (bool) {\n        return registry.getLoanInterestTermsContract().completedRepayment(agreementId);\n    }\n\n    //Conclude a loan, stop lending/loan terms or allow the loan loss\n    function _concludeLoan(\n        address creditor,\n        bytes32 agreementId,\n        address termContract\n    ) private {\n        require(creditor != address(0), 'Invalid creditor account.');\n        require(agreementId != bytes32(0), 'Invalid agreement id.');\n        require(termContract != address(0), 'Invalid terms contract.');\n\n        if (!_assertDebtExisting(agreementId) || !_assertCompletedRepayment(agreementId)) {\n            revert('Debt does not exsits or Debtor have not completed repayment.');\n        }\n\n        bool isTermCompleted = ILoanInterestTermsContract(termContract).registerConcludeLoan(agreementId);\n\n        if (isTermCompleted) {\n            _burnLoanAssetToken(agreementId);\n        } else {\n            revert('Unable to conclude terms contract.');\n        }\n    }\n\n    /*********************** */\n    // EXTERNAL FUNCTIONS\n    /*********************** */\n\n    function concludeLoans(\n        address[] calldata creditors,\n        bytes32[] calldata agreementIds,\n        address termContract\n    ) external whenNotPaused nonReentrant {\n        for (uint256 i = 0; i < creditors.length; i++) {\n            _concludeLoan(creditors[i], agreementIds[i], termContract);\n        }\n    }\n\n    /**\n     * Filling new Debt Order\n     * Notice:\n     * - All Debt Order must to have same:\n     *   + TermContract\n     *   + Creditor Fee\n     *   + Debtor Fee\n     */\n    function fillDebtOrder(\n        address[] calldata orderAddresses, // 0-creditor, 1-principal token address, 2-repayment router, 3-term contract, 4-relayer,...\n        uint256[] calldata orderValues, //  0-creditorFee, 1-asset purpose,..., [x] principalAmounts, [x] expirationTimestampInSecs, [x] - salts, [x] - riskScores\n        bytes32[] calldata termsContractParameters, // Term contract parameters from different farmers, encoded as hash strings\n        bytes32[] calldata tokenIds // [x]-Loan liability token Id, [x]-Loan liability token Id\n    ) external whenNotPaused nonReentrant validFillingOrderAddresses(orderAddresses) {\n        require(termsContractParameters.length > 0, 'Loanernel: Invalid Term Contract params');\n\n        uint256[] memory salts = _saltFromOrderValues(orderValues, termsContractParameters.length);\n        LoanOrder memory debtOrder = _getLoanOrder(\n            _debtorsFromOrderAddresses(orderAddresses, termsContractParameters.length),\n            orderAddresses,\n            orderValues,\n            termsContractParameters,\n            salts\n        );\n\n        require(debtOrder.issuance.termsContract != address(0x0), 'LoanKernel: Invalid Term Contract.');\n\n        for (uint256 i = 0; i < debtOrder.issuance.agreementIds.length; i++) {\n            require(debtOrder.issuance.agreementIds[i] == tokenIds[i], 'LoanKernel: Invalid LAT Token Id');\n\n            _issueDebtAgreements(\n                tokenIds[i],\n                orderAddresses[uint8(FillingAddressesIndex.CREDITOR)],\n                orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)],\n                debtOrder.issuance.debtors[i],\n                termsContractParameters[i],\n                debtOrder.principalTokenAddress,\n                salts[i],\n                debtOrder.expirationTimestampInSecs[i],\n                _getAssetPurposeAndRiskScore(debtOrder.assetPurpose, debtOrder.riskScores[i])\n            );\n\n            require(\n                ILoanInterestTermsContract(debtOrder.issuance.termsContract).registerTermStart(tokenIds[i]),\n                'LoanKernel: Failed to register starting Loan terms.'\n            );\n\n            emit LogDebtOrderFilled(\n                debtOrder.issuance.agreementIds[i],\n                debtOrder.principalAmounts[i],\n                debtOrder.principalTokenAddress,\n                debtOrder.relayer\n            );\n        }\n    }\n\n    function _getDebtOrderHash(\n        bytes32 agreementId,\n        uint256 principalAmount,\n        address principalTokenAddress,\n        address relayer,\n        uint256 expirationTimestampInSec\n    ) private view returns (bytes32 _debtorMessageHash) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    address(this),\n                    agreementId,\n                    principalAmount,\n                    principalTokenAddress,\n                    relayer,\n                    expirationTimestampInSec\n                )\n            );\n    }\n\n    /**\n     * Helper function that returns an issuance's hash\n     */\n    function _getAgreementId(\n        address version,\n        address debtor,\n        address termsContract,\n        bytes32 termsContractParameters,\n        uint256 salt\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(version, debtor, termsContract, termsContractParameters, salt));\n    }\n\n    function _genInputLoanAgreementId(\n        address _version,\n        address _termsContract,\n        address _observerWallet,\n        address _inputSupplierWallet,\n        uint256 _salt\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_version, _termsContract, _observerWallet, _inputSupplierWallet, _salt));\n    }\n\n    function _genLoanAgreementIds(\n        address _version,\n        address[] memory _debtors,\n        address _termsContract,\n        bytes32[] memory _termsContractParameters,\n        uint256[] memory _salts\n    ) private pure returns (bytes32[] memory) {\n        bytes32[] memory agreementIds = new bytes32[](_salts.length);\n        for (uint256 i = 0; i < (0 + _salts.length); i++) {\n            agreementIds[i] = keccak256(\n                abi.encodePacked(_version, _debtors[i], _termsContract, _termsContractParameters[i], _salts[i])\n            );\n        }\n        return agreementIds;\n    }\n\n    /**\n     * Asserts that debt order meets all validity requirements described in\n     * the Kernel specification document.\n     */\n    function _assertDebtOrderValidityInvariants(\n        uint256 principalAmount,\n        uint256 debtorFee,\n        bytes32 debtOrderHash,\n        uint256 expirationTimestampInSec,\n        bytes32 agreementId\n    ) private returns (bool _orderIsValid) {\n        // Validate fee amount\n        // uint totalFees = debtOrder.creditorFee.add(debtOrder.debtorFee);\n\n        // Invariant: debtor is given enough principal to cover at least debtorFees\n        if (principalAmount < debtorFee) {\n            emit LogDebtKernelError(\n                uint8(Errors.ORDER_INVALID_INSUFFICIENT_PRINCIPAL),\n                debtOrderHash,\n                'Principal account must greater than Debtor fee.'\n            );\n            return false;\n        }\n\n        // Invariant: debt order must not be expired\n        // solhint-disable-next-line not-rely-on-time\n        if (expirationTimestampInSec < block.timestamp) {\n            emit LogDebtKernelError(\n                uint8(Errors.ORDER_EXPIRED),\n                debtOrderHash,\n                'Debt Kernel:  Expiration time lesser than current time.'\n            );\n            return false;\n        }\n\n        // Invariant: debt order's issuance must not already be minted as debt token\n        if (registry.getLoanAssetToken().ownerOf(uint256(agreementId)) != address(0)) {\n            emit LogDebtKernelError(\n                uint8(Errors.DEBT_ISSUED),\n                debtOrderHash,\n                \"Debt Kernel: Debt Order's Issuance was already minted.\"\n            );\n            return false;\n        }\n\n        // Invariant: debt order's issuance must not have been cancelled\n        if (issuanceCancelled[agreementId]) {\n            emit LogDebtKernelError(\n                uint8(Errors.ISSUANCE_CANCELLED),\n                debtOrderHash,\n                'Debt Kernel: Issuance is cancelled.'\n            );\n            return false;\n        }\n\n        // Invariant: debt order itself must not have been cancelled\n        if (debtOrderCancelled[debtOrderHash]) {\n            emit LogDebtKernelError(\n                uint8(Errors.ORDER_CANCELLED),\n                debtOrderHash,\n                'Debt Kernel: Debt Order is cancelled.'\n            );\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Helper function for querying an address' balance on a given token.\n     */\n    function _getBalance(address token, address owner) private view returns (uint256 _balance) {\n        // Limit gas to prevent reentrancy.\n        return ERC20(token).balanceOf(owner);\n    }\n\n    /**\n     * Helper function for querying an address' allowance to the 0x transfer proxy.\n     */\n    function _getAllowance(address token, address owner) private view returns (uint256 _allowance) {\n        // Limit gas to prevent reentrancy.\n        return IERC20(token).allowance(owner, address(this));\n    }\n\n    /**\n     * Helper function transfers a specified amount of tokens between two parties\n     * using the token transfer proxy contract.\n     */\n    function _transferTokensFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        return IERC20(token).transferFrom(from, to, amount);\n    }\n\n    // Transfer fee to beneficiaries\n    function _transferFeesToBeneficiaries(\n        address payer,\n        address from,\n        address token,\n        address[5] memory beneficiaries,\n        uint256[5] memory amounts\n    ) private {\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] > 0 && beneficiaries[i] != address(0x0)) {\n                _transferTokensFrom(token, from, beneficiaries[i], amounts[i]);\n                emit LogFeeTransfer(payer, token, amounts[i], beneficiaries[i]);\n            }\n        }\n    }\n\n    /**\n     * Assert that the creditor has a sufficient token balance and has\n     * granted the token transfer proxy contract sufficient allowance to suffice for the principal\n     * and creditor fee.\n     */\n    function _assertExternalBalanceAndAllowanceInvariants(\n        address creditor,\n        uint256 principalAmount,\n        address principalToken,\n        bytes32 debtOrderHash\n    ) private returns (bool _isBalanceAndAllowanceSufficient) {\n        uint256 totalCreditorPayment = principalAmount;\n\n        if (\n            _getBalance(principalToken, creditor) < totalCreditorPayment ||\n            _getAllowance(principalToken, creditor) < totalCreditorPayment\n        ) {\n            emit LogDebtKernelError(\n                uint8(Errors.CREDITOR_BALANCE_OR_ALLOWANCE_INSUFFICIENT),\n                debtOrderHash,\n                'Balance of allowance of Creditor is insufficient.'\n            );\n            return false;\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/interfaces/IMintedIncreasingInterestTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../storage/Registry.sol';\nimport '../base/UntangledBase.sol';\n\nabstract contract IMintedIncreasingInterestTGE is UntangledBase {\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _isLongSale\n    ) public virtual;\n\n    bool public finalized;\n\n    uint256 public currencyRaised;\n\n    function setupLongSale(\n        uint256 interestRate,\n        uint256 termLengthInSeconds,\n        uint256 timeStartEarningInterest\n    ) public virtual;\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) external virtual returns (uint256);\n}\n"
    },
    "contracts/BNCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract BNCoin is ERC20 {\n    constructor(string memory name,\n        string memory symbol,\n        uint256 initialSupply) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.10;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns guaranteed execution fee for the specified message\n  /// delivery to destination chain\n  /// @dev returns 0 fee on invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // extraArgs will evolve to support new features\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\n    bool strict; // See strict sequencing details below.\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"../../ConfirmedOwner.sol\";\n\n/// @title The OwnerIsCreator contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract OwnerIsCreator is ConfirmedOwner {\n  constructor() ConfirmedOwner(msg.sender) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271Upgradeable {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC5267Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267Upgradeable {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {\n    function __ERC1155Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC1155Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../extensions/ERC20BurnableUpgradeable.sol\";\nimport \"../extensions/ERC20PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {\n    function initialize(string memory name, string memory symbol) public virtual initializer {\n        __ERC20PresetMinterPauser_init(name, symbol);\n    }\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal onlyInitializing {\n        __ERC20_init_unchained(name, symbol);\n        __Pausable_init_unchained();\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init_unchained(string memory, string memory) internal onlyInitializing {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"../extensions/ERC721BurnableUpgradeable.sol\";\nimport \"../extensions/ERC721PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC721PresetMinterPauserAutoIdUpgradeable is\n    Initializable, ContextUpgradeable,\n    AccessControlEnumerableUpgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721BurnableUpgradeable,\n    ERC721PausableUpgradeable\n{\n    function initialize(string memory name, string memory symbol, string memory baseTokenURI) public virtual initializer {\n        __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);\n    }\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    CountersUpgradeable.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n     * See {ERC721-tokenURI}.\n     */\n    function __ERC721PresetMinterPauserAutoId_init(string memory name, string memory symbol, string memory baseTokenURI) internal onlyInitializing {\n        __ERC721_init_unchained(name, symbol);\n        __Pausable_init_unchained();\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __ERC721PresetMinterPauserAutoId_init_unchained(string memory, string memory, string memory baseTokenURI) internal onlyInitializing {\n        _baseTokenURI = baseTokenURI;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../interfaces/IERC5267Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:oz-renamed-from _HASHED_NAME\n    bytes32 private _hashedName;\n    /// @custom:oz-renamed-from _HASHED_VERSION\n    bytes32 private _hashedVersion;\n\n    string private _name;\n    string private _version;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n\n        // Reset prior values in storage if upgrading\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require(_hashedName == 0 && _hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../interfaces/IERC1271Upgradeable.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureCheckerUpgradeable {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSAUpgradeable.RecoverError error) = ECDSAUpgradeable.tryRecover(hash, signature);\n        return\n            (error == ECDSAUpgradeable.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271Upgradeable.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271Upgradeable.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165Upgradeable).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/base/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {TransparentUpgradeableProxy} from '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\nabstract contract Factory is Initializable, ContextUpgradeable {\n    address public factoryAdmin;\n\n    modifier onlyFactoryAdmin() {\n        require(msg.sender == factoryAdmin, 'Only factory admin');\n        _;\n    }\n\n    function __Factory__init(address _factoryAdmin) internal onlyInitializing {\n        __Context_init_unchained();\n        __Factory_init_unchained(_factoryAdmin);\n    }\n\n    function __Factory_init_unchained(address _factoryAdmin) internal onlyInitializing {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    function _setFactoryAdmin(address _factoryAdmin) internal {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    function _deployInstance(address _poolImplAddress, bytes memory _data) internal returns (address) {\n        TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(_poolImplAddress, factoryAdmin, _data);\n\n        return address(proxy);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/base/Factory2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/utils/Create2.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\n\nabstract contract Factory2 is Initializable {\n    using AddressUpgradeable for address;\n\n    address public factoryAdmin;\n\n    function __Factory__init(address _factoryAdmin) internal onlyInitializing {\n        __Factory__init_unchained(_factoryAdmin);\n    }\n\n    function __Factory__init_unchained(address _factoryAdmin) internal onlyInitializing {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    function _setFactoryAdmin(address _factoryAdmin) internal {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    // function getSelector(string memory _func) internal pure returns (bytes4) {\n    //     return bytes4(keccak256(bytes(_func)));\n    // }\n\n    function _deployInstance(address _poolImplAddress, bytes memory _data, bytes32 salt) internal returns (address) {\n        ITransparentUpgradeableProxy proxy = ITransparentUpgradeableProxy(\n            Create2.deploy(\n                0,\n                salt,\n                abi.encodePacked(\n                    type(TransparentUpgradeableProxy).creationCode,\n                    abi.encode(_poolImplAddress, address(this), '')\n                )\n            )\n        );\n\n        proxy.changeAdmin(factoryAdmin);\n        address(proxy).functionCall(_data);\n\n        return address(proxy);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/base/IPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IPauseable {\n    function pause() external;\n    function unpause() external;\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/base/PauseableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is ContextUpgradeable {\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation =\n        0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), 'Pausable: paused');\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), 'Pausable: not paused');\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/base/UntangledBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\n\nimport '../libraries/Configuration.sol';\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Abstract contract that serves as a base contract for other contracts in the Untangled system.\n *  It provides functionalities for contract initialization, pausing, and access control.\n * @author Untangled Team\n */\nabstract contract UntangledBase is\n    Initializable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\n\n    function isAdmin() public view virtual returns (bool) {\n        return hasRole(OWNER_ROLE, _msgSender());\n    }\n\n    modifier onlyAdmin() {\n        require(isAdmin(), 'UntangledBase: Must have admin role to perform this action');\n        _;\n    }\n\n    function __UntangledBase__init(address owner) internal onlyInitializing {\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n        __UntangledBase__init_unchained(owner);\n    }\n\n    function __UntangledBase__init_unchained(address owner) internal onlyInitializing {\n        if (owner == address(0)) owner = _msgSender();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(OWNER_ROLE, owner);\n\n        _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n    }\n\n    function getInitializedVersion() public view virtual returns (uint256) {\n        return _getInitializedVersion();\n    }\n\n    function pause() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/base/UpgradableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IERCProxy {\n    function proxyType() external pure returns (uint256 proxyTypeId);\n\n    function implementation() external view returns (address codeAddr);\n}\n\nabstract contract Proxy is IERCProxy {\n    function delegatedFwd(address implementation_) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation_, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    function proxyType() external pure virtual override returns (uint256 proxyTypeId) {\n        // Upgradeable proxy\n        proxyTypeId = 2;\n    }\n\n    function implementation() external view virtual override returns (address);\n}\n\ncontract UpgradableProxy is Proxy {\n    event ProxyUpdated(address indexed _new, address indexed _old);\n    event ProxyOwnerUpdate(address _new, address _old);\n\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(\"matic.network.proxy.implementation\");\n    bytes32 constant OWNER_SLOT = keccak256(\"matic.network.proxy.owner\");\n\n    constructor(address _proxyTo) {\n        setProxyOwner(msg.sender);\n        setImplementation(_proxyTo);\n    }\n\n    fallback() external payable {\n        delegatedFwd(loadImplementation());\n    }\n\n    receive() external payable {\n        delegatedFwd(loadImplementation());\n    }\n\n    modifier onlyProxyOwner() {\n        require(loadProxyOwner() == msg.sender, \"NOT_OWNER\");\n        _;\n    }\n\n    function proxyOwner() external view returns (address) {\n        return loadProxyOwner();\n    }\n\n    function loadProxyOwner() internal view returns (address) {\n        address _owner;\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            _owner := sload(position)\n        }\n        return _owner;\n    }\n\n    function implementation() external view override returns (address) {\n        return loadImplementation();\n    }\n\n    function loadImplementation() internal view returns (address) {\n        address _impl;\n        bytes32 position = IMPLEMENTATION_SLOT;\n        assembly {\n            _impl := sload(position)\n        }\n        return _impl;\n    }\n\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());\n        setProxyOwner(newOwner);\n    }\n\n    function setProxyOwner(address newOwner) private {\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            sstore(position, newOwner)\n        }\n    }\n\n    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\n\n        emit ProxyUpdated(_newProxyTo, loadImplementation());\n\n        setImplementation(_newProxyTo);\n    }\n\n    function updateAndCall(address _newProxyTo, bytes memory data) public payable onlyProxyOwner {\n        updateImplementation(_newProxyTo);\n\n        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);\n        require(success, string(returnData));\n    }\n\n    function setImplementation(address _newProxyTo) private {\n        bytes32 position = IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(position, _newProxyTo)\n        }\n    }\n\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly {\n            size := extcodesize(_target)\n        }\n        return size > 0;\n    }\n}"
    },
    "contracts/external/ERC1155PresetPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC1155} token, including a pauser role that allows to stop all token transfers\n * (including minting and burning).\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * Adapted from OZ's ERC1155PresetMinterPauserUpgradeable.sol: removed inheritance of\n * ERC1155BurnableUpgradeable; removed MINTER_ROLE; replaced DEFAULT_ADMIN_ROLE with OWNER_ROLE;\n * grants roles to owner param rather than `_msgSender()`; added `setURI()`, to give owner ability\n * to set the URI after initialization; added `isAdmin()` helper and `onlyAdmin` modifier.\n */\ncontract ERC1155PresetPauserUpgradeable is\n  Initializable,\n  ContextUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  ERC1155PausableUpgradeable\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /**\n   * @dev Grants `OWNER_ROLE` and `PAUSER_ROLE` to the account that\n   * deploys the contract.\n   */\n  function __ERC1155PresetPauser_init(address owner, string memory uri) internal onlyInitializing {\n    __Context_init_unchained();\n    __ERC165_init_unchained();\n    __AccessControl_init_unchained();\n    __AccessControlEnumerable_init_unchained();\n    __ERC1155_init_unchained(uri);\n    __Pausable_init_unchained();\n    __ERC1155Pausable_init_unchained();\n    __ERC1155PresetPauser_init_unchained(owner);\n  }\n\n  function __ERC1155PresetPauser_init_unchained(address owner) internal onlyInitializing {\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function setURI(string memory newuri) external onlyAdmin {\n    /// @dev Because the `newuri` is not id-specific, we do not emit a URI event here. See the comment\n    /// on `_setURI()`.\n    _setURI(newuri);\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC1155Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() public virtual {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC1155PresetPauser: must have pauser role to pause\"\n    );\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC1155Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() public virtual {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC1155PresetPauser: must have pauser role to unpause\"\n    );\n    _unpause();\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(AccessControlEnumerableUpgradeable, ERC1155Upgradeable)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n\n  function _beforeTokenTransfer(\n    address operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) internal virtual override(ERC1155PausableUpgradeable) {\n    super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/ICrowdSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ICrowdSale} from '../protocol/note-sale/crowdsale/ICrowdSale.sol';\n"
    },
    "contracts/interfaces/IDistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IDistributionAssessor} from '../protocol/pool/IDistributionAssessor.sol';\n"
    },
    "contracts/interfaces/IDistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IDistributionOperator} from '../protocol/pool/IDistributionOperator.sol';\n"
    },
    "contracts/interfaces/IDistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../protocol/pool/IDistributionTranche.sol';"
    },
    "contracts/interfaces/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IGo} from '../protocol/IGo.sol';\n"
    },
    "contracts/interfaces/ILoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanAssetToken} from '../tokens/ERC721/ILoanAssetToken.sol';\n"
    },
    "contracts/interfaces/ILoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanInterestTermsContract} from '../protocol/loan/ILoanInterestTermsContract.sol';\n"
    },
    "contracts/interfaces/ILoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanKernel} from '../protocol/loan/ILoanKernel.sol';\n"
    },
    "contracts/interfaces/ILoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanRegistry} from '../protocol/loan/ILoanRegistry.sol';\n"
    },
    "contracts/interfaces/ILoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../protocol/loan/ILoanRepaymentRouter.sol';"
    },
    "contracts/interfaces/INoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {INoteToken} from '../tokens/ERC20/INoteToken.sol';\n"
    },
    "contracts/interfaces/INoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {INoteTokenFactory} from './../protocol/note-sale/fab/INoteTokenFactory.sol';\n"
    },
    "contracts/interfaces/IRequiresUID.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IRequiresUID} from '../uid/IRequiresUID.sol';\n"
    },
    "contracts/interfaces/ISecuritizationAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport {ISecuritizationAccessControl} from '../protocol/pool/ISecuritizationAccessControl.sol';\n\n"
    },
    "contracts/interfaces/ISecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ISecuritizationManager} from '../protocol/pool/ISecuritizationManager.sol';\n"
    },
    "contracts/interfaces/ISecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport {ISecuritizationPool} from '../protocol/pool/ISecuritizationPool.sol';\n"
    },
    "contracts/interfaces/ISecuritizationPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport {ISecuritizationPoolStorage} from '../protocol/pool/ISecuritizationPoolStorage.sol';\n"
    },
    "contracts/interfaces/ISecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ISecuritizationPoolValueService} from '../protocol/pool/ISecuritizationPoolValueService.sol';\n"
    },
    "contracts/interfaces/ITokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ITokenGenerationEventFactory} from '../protocol/note-sale/fab/ITokenGenerationEventFactory.sol';\n"
    },
    "contracts/interfaces/IUntangledERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IUntangledERC721} from '../tokens/ERC721/IUntangledERC721.sol';\n"
    },
    "contracts/libraries/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IAccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol';\nimport {Registry} from '../storage/Registry.sol';\nimport {Configuration} from './Configuration.sol';\n\nimport {ISecuritizationManager} from '../interfaces/ISecuritizationManager.sol';\nimport {ISecuritizationPool} from '../interfaces/ISecuritizationPool.sol';\nimport {INoteTokenFactory} from '../interfaces/INoteTokenFactory.sol';\nimport {INoteToken} from '../interfaces/INoteToken.sol';\nimport {ITokenGenerationEventFactory} from '../interfaces/ITokenGenerationEventFactory.sol';\nimport {IUntangledERC721} from '../interfaces/IUntangledERC721.sol';\nimport {IDistributionOperator} from '../interfaces/IDistributionOperator.sol';\nimport {IDistributionTranche} from '../interfaces/IDistributionTranche.sol';\nimport {ILoanRegistry} from '../interfaces/ILoanRegistry.sol';\nimport {ILoanInterestTermsContract} from '../interfaces/ILoanInterestTermsContract.sol';\nimport {ILoanRepaymentRouter} from '../interfaces/ILoanRepaymentRouter.sol';\nimport {ILoanKernel} from '../interfaces/ILoanKernel.sol';\nimport {ILoanAssetToken} from '../interfaces/ILoanAssetToken.sol';\nimport {IDistributionAssessor} from '../interfaces/IDistributionAssessor.sol';\nimport {ISecuritizationPoolValueService} from '../interfaces/ISecuritizationPoolValueService.sol';\n\nimport {MintedIncreasingInterestTGE} from '../protocol/note-sale/MintedIncreasingInterestTGE.sol';\nimport {MintedNormalTGE} from '../protocol/note-sale/MintedNormalTGE.sol';\nimport {IGo} from '../interfaces/IGo.sol';\nimport \"../protocol/pool/IPoolNAVFactory.sol\";\n\nimport {POOL_ADMIN, OWNER_ROLE} from './types.sol';\nimport {INoteTokenVault} from \"../protocol/pool/INoteTokenVault.sol\";\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the Registry contract\n * @author Untangled Team\n */\nlibrary ConfigHelper {\n    function getAddress(Registry registry, Configuration.CONTRACT_TYPE contractType) internal view returns (address) {\n        return registry.getAddress(uint8(contractType));\n    }\n\n    function getSecuritizationManager(Registry registry) internal view returns (ISecuritizationManager) {\n        return ISecuritizationManager(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER));\n    }\n\n    function getSecuritizationPool(Registry registry) internal view returns (ISecuritizationPool) {\n        return ISecuritizationPool(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL));\n    }\n\n    function getNoteTokenFactory(Registry registry) internal view returns (INoteTokenFactory) {\n        return INoteTokenFactory(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY));\n    }\n\n    // function getNoteToken(Registry registry) internal view returns (INoteToken) {\n    //     return INoteToken(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN));\n    // }\n\n    function getTokenGenerationEventFactory(Registry registry) internal view returns (ITokenGenerationEventFactory) {\n        return\n            ITokenGenerationEventFactory(\n                getAddress(registry, Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY)\n            );\n    }\n\n    function getDistributionOperator(Registry registry) internal view returns (IDistributionOperator) {\n        return IDistributionOperator(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR));\n    }\n\n    function getLoanAssetToken(Registry registry) internal view returns (ILoanAssetToken) {\n        return ILoanAssetToken(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN));\n    }\n\n    function getLoanRegistry(Registry registry) internal view returns (ILoanRegistry) {\n        return ILoanRegistry(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REGISTRY));\n    }\n\n    function getLoanInterestTermsContract(Registry registry) internal view returns (ILoanInterestTermsContract) {\n        return\n            ILoanInterestTermsContract(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT));\n    }\n\n    function getLoanRepaymentRouter(Registry registry) internal view returns (ILoanRepaymentRouter) {\n        return ILoanRepaymentRouter(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER));\n    }\n\n    function getLoanKernel(Registry registry) internal view returns (ILoanKernel) {\n        return ILoanKernel(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_KERNEL));\n    }\n\n    function getDistributionTranche(Registry registry) internal view returns (IDistributionTranche) {\n        return IDistributionTranche(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE));\n    }\n\n    function getSecuritizationPoolValueService(\n        Registry registry\n    ) internal view returns (ISecuritizationPoolValueService) {\n        return\n            ISecuritizationPoolValueService(\n                getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE)\n            );\n    }\n\n    function getDistributionAssessor(Registry registry) internal view returns (IDistributionAssessor) {\n        return IDistributionAssessor(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR));\n    }\n\n    // function getMintedIncreasingInterestTGE(Registry registry) internal view returns (MintedIncreasingInterestTGE) {\n    //     return\n    //         MintedIncreasingInterestTGE(\n    //             getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE)\n    //         );\n    // }\n\n    // function getMintedNormalTGE(Registry registry) internal view returns (MintedNormalTGE) {\n    //     return MintedNormalTGE(getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE));\n    // }\n\n    function getGo(Registry registry) internal view returns (IGo) {\n        return IGo(getAddress(registry, Configuration.CONTRACT_TYPE.GO));\n    }\n\n    function getPoolNAVFactory(Registry registry) internal view returns (IPoolNAVFactory) {\n        return IPoolNAVFactory(getAddress(registry, Configuration.CONTRACT_TYPE.POOL_NAV_FACTORY));\n    }\n\n    function getNoteTokenVault(Registry registry) internal view returns (INoteTokenVault) {\n        return INoteTokenVault(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN_VAULT));\n    }\n\n    function requireDistributionOperator(Registry registry, address account) internal view {\n        require(account == address(getDistributionOperator(registry)), 'Registry: Only DistributionOperator');\n    }\n\n    function requirePoolAdmin(Registry registry, address account) internal view {\n        require(\n            IAccessControlUpgradeable(address(getSecuritizationManager(registry))).hasRole(POOL_ADMIN, account),\n            'Registry: Not an pool admin'\n        );\n    }\n\n    function requirePoolAdminOrOwner(Registry registry, address pool, address account) internal view {\n        require(\n            IAccessControlUpgradeable(address(getSecuritizationManager(registry))).hasRole(POOL_ADMIN, account) ||\n                IAccessControlUpgradeable(pool).hasRole(OWNER_ROLE, account),\n            'Registry: Not an pool admin or pool owner'\n        );\n    }\n\n    function requireSecuritizationManager(Registry registry, address account) internal view {\n        require(account == address(getSecuritizationManager(registry)), 'Registry: Only SecuritizationManager');\n    }\n\n    function requireLoanRepaymentRouter(Registry registry, address account) internal view {\n        require(account == address(getLoanRepaymentRouter(registry)), 'Registry: Only LoanRepaymentRouter');\n    }\n\n    function requireLoanKernel(Registry registry, address account) internal view {\n        require(account == address(getLoanKernel(registry)), 'Registry: Only LoanKernel');\n    }\n\n    function requireLoanInterestTermsContract(Registry registry, address account) internal view {\n        require(account == address(getLoanInterestTermsContract(registry)), 'Registry: Only LoanInterestTermsContract');\n    }\n}\n"
    },
    "contracts/libraries/Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Configuration\n/// @author Untangled Team\nlibrary Configuration {\n    uint256 public constant PRICE_SCALING_FACTOR = 10 ** 4;\n\n    // NEVER EVER CHANGE THE ORDER OF THESE!\n    // You can rename or append. But NEVER change the order.\n    enum CONTRACT_TYPE {\n        SECURITIZATION_MANAGER,\n        SECURITIZATION_POOL,\n        NOTE_TOKEN_FACTORY,\n        NOTE_TOKEN, // deprecated\n        TOKEN_GENERATION_EVENT_FACTORY,\n        DISTRIBUTION_OPERATOR,\n        DISTRIBUTION_ASSESSOR,\n        DISTRIBUTION_TRANCHE,\n        LOAN_ASSET_TOKEN,\n        ACCEPTED_INVOICE_TOKEN,\n        LOAN_REGISTRY,\n        LOAN_INTEREST_TERMS_CONTRACT,\n        LOAN_REPAYMENT_ROUTER,\n        LOAN_KERNEL,\n        ERC20_TOKEN_REGISTRY,\n        ERC20_TOKEN_TRANSFER_PROXY,\n        SECURITIZATION_MANAGEMENT_PROJECT,\n        SECURITIZATION_POOL_VALUE_SERVICE,\n        MINTED_INCREASING_INTEREST_TGE, // depreacated\n        MINTED_NORMAL_TGE, // depreacated\n        INVOICE_COLLATERALIZER,\n        INVOICE_DEBT_REGISTRY,\n        INVOICE_FINANCE_INTEREST_TERMS_CONTRACT,\n        INVOICE_LOAN_KERNEL,\n        INVOICE_LOAN_REPAYMENT_ROUTER,\n        GO,\n        POOL_NAV_FACTORY,\n        NOTE_TOKEN_VAULT\n    }\n\n    enum NOTE_TOKEN_TYPE {\n        SENIOR,\n        JUNIOR\n    }\n\n    enum ASSET_PURPOSE {\n        LOAN,\n        INVOICE\n    }\n}\n"
    },
    "contracts/libraries/types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nbytes32 constant POOL_ADMIN = keccak256('POOL_CREATOR');\nbytes32 constant OWNER_ROLE = keccak256('OWNER_ROLE');"
    },
    "contracts/libraries/UnpackLoanParamtersLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.10;\n\nlibrary UnpackLoanParamtersLib {\n    struct InterestParams {\n        uint256 principalAmount;\n        uint256 termStartUnixTimestamp;\n        uint256 termEndUnixTimestamp;\n        AmortizationUnitType amortizationUnitType;\n        uint256 termLengthInAmortizationUnits;\n        // interest rates can, at a maximum, have 4 decimal places of precision.\n        uint256 interestRate;\n    }\n\n    enum AmortizationUnitType {\n        MINUTES, // 0 - since 1.0.13\n        HOURS, // 1\n        DAYS, // 2\n        WEEKS, // 3\n        MONTHS, // 4\n        YEARS // 5\n    }\n\n    /**\n     *\n     * Notice: * uint256 (a) reinterprets a as 256-bit unsigned integer. As long as 256 bit = 32 bytes\n     */\n    function _bitShiftRight(bytes32 value, uint256 amount) internal pure returns (uint256) {\n        return uint256(value) / 2**amount;\n    }\n\n    /**\n     * Unpack parameters from packed bytes32 data\n     */\n    function _unpackLoanTermsParametersFromBytes(bytes32 parameters)\n        internal\n        pure\n        returns (\n            uint256 _principalAmount,\n            uint256 _interestRate,\n            uint256 _amortizationUnitType,\n            uint256 _termLengthInAmortizationUnits,\n            uint256 _gracePeriodInDays\n        )\n    {\n        // The subsequent 12 bytes of the parameters encode the PRINCIPAL AMOUNT.\n        bytes32 principalAmountShifted = parameters &\n            0x00ffffffffffffffffffffffff00000000000000000000000000000000000000;\n        // The subsequent 3 bytes of the parameters encode the INTEREST RATE.\n        bytes32 interestRateShifted = parameters & 0x00000000000000000000000000ffffff00000000000000000000000000000000;\n        // The subsequent 4 bits (half byte) encode the AMORTIZATION UNIT TYPE code.\n        bytes32 amortizationUnitTypeShifted = parameters &\n            0x00000000000000000000000000000000f0000000000000000000000000000000;\n        // The subsequent 12 bytes encode the term length, as denominated in\n        // the encoded amortization unit.\n        bytes32 termLengthInAmortizationUnitsShifted = parameters &\n            0x000000000000000000000000000000000ffffffffffffffffffffffff0000000;\n\n        bytes32 gracePeriodInDaysShifted = parameters &\n            0x000000000000000000000000000000000000000000000000000000000ff00000;\n\n        return (\n            _bitShiftRight(principalAmountShifted, 152),\n            _bitShiftRight(interestRateShifted, 128),\n            _bitShiftRight(amortizationUnitTypeShifted, 124),\n            _bitShiftRight(termLengthInAmortizationUnitsShifted, 28),\n            _bitShiftRight(gracePeriodInDaysShifted, 20)\n        );\n    }\n\n    /**\n     * Unpack data from hex string which including informations about Loan\n     */\n    function unpackParametersFromBytes(bytes32 parameters)\n        internal\n        pure\n        returns (\n            uint256 _principalAmount,\n            uint256 _interestRate,\n            uint256 _amortizationUnitType,\n            uint256 _termLengthInAmortizationUnits,\n            uint256 _gracePeriodInDays\n        )\n    {\n        return _unpackLoanTermsParametersFromBytes(parameters);\n    }\n}\n"
    },
    "contracts/libraries/UntangledMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title UntangledMath\n/// @author Untangled Team\nlibrary UntangledMath {\n    uint256 public constant ONE = 10**27;\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    function uncheckedInc(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + 1;\n        }\n    }\n}\n"
    },
    "contracts/protocol/ccip/chainlink-upgradeable/CCIPReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport {Client} from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\nimport {IAny2EVMMessageReceiver} from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol';\n\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiverUpgradeable is Initializable, IAny2EVMMessageReceiver, ERC165Upgradeable {\n    address internal i_router;\n\n    function __CCIPReceiver__init(address router) internal onlyInitializing {\n        __ERC165_init_unchained();\n        __CCIPReceiver__init_unchained(router);\n    }\n\n    function __CCIPReceiver__init_unchained(address router) internal onlyInitializing {\n        if (router == address(0)) revert InvalidRouter(address(0));\n        i_router = router;\n    }\n\n    /// @notice IERC165 supports an interfaceId\n    /// @param interfaceId The interfaceId to check\n    /// @return true if the interfaceId is supported\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAny2EVMMessageReceiver).interfaceId ||\n            ERC165Upgradeable.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IAny2EVMMessageReceiver\n    function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n        _ccipReceive(message);\n    }\n\n    /// @notice Override this function in your implementation.\n    /// @param message Any2EVMMessage\n    function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n    /////////////////////////////////////////////////////////////////////\n    // Plumbing\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the current router\n    /// @return i_router address\n    function getRouter() public view returns (address) {\n        return address(i_router);\n    }\n\n    error InvalidRouter(address router);\n\n    /// @dev only calls from the set router are accepted.\n    modifier onlyRouter() {\n        if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\n        _;\n    }\n\n    // deployed ...\n    // uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/ccip/ICommandData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nenum MessageType {\n    LenderBuysTokens\n}\n\nstruct ICommandData {\n    MessageType messageType;\n    bytes data;\n}\n"
    },
    "contracts/protocol/ccip/interfaces/IUntangledBridgeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {MessageType} from '../ICommandData.sol';\n\ninterface IUntangledBridgeRouter {\n    function processMessage(MessageType messageType, bytes calldata data) external;\n}\n"
    },
    "contracts/protocol/ccip/mock/CCIPReceiverStorageV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ICommandData, MessageType} from '../ICommandData.sol';\n\nabstract contract CCIPReceiverStorageV2 {\n    event MessageReceived(bytes32 indexed messageId, uint64 indexed sourceChainSelector, address sender, bytes data);\n\n    error BridgeRouterExecutedFailed(MessageType messageType, bytes data);\n\n    address untangledBridgeRouter;\n    bytes32 public lastReceivedMessageId;\n    ICommandData public lastReceivedData;\n    mapping(bytes32 => ICommandData) public messageDataGroup;\n    mapping(bytes32 => ICommandData) public failedMessageDataGroup;\n\n    uint256 test;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/ccip/mock/UntangledReceiverV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Client} from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport {IAny2EVMMessageReceiver} from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol';\n\nimport {CCIPReceiverUpgradeable} from '../chainlink-upgradeable/CCIPReceiverUpgradeable.sol';\nimport {ICommandData} from '../ICommandData.sol';\nimport '../../../base/UntangledBase.sol';\nimport {CCIPReceiverStorageV2} from './CCIPReceiverStorageV2.sol';\n\ncontract UntangledReceiverV2 is UntangledBase, CCIPReceiverUpgradeable, CCIPReceiverStorageV2 {\n    function initialize(address router) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n        __CCIPReceiver__init_unchained(router);\n    }\n\n    /// handle a received message\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        lastReceivedMessageId = any2EvmMessage.messageId;\n        lastReceivedData = abi.decode(any2EvmMessage.data, (ICommandData));\n\n        emit MessageReceived(\n            any2EvmMessage.messageId,\n            any2EvmMessage.sourceChainSelector,\n            abi.decode(any2EvmMessage.sender, (address)),\n            any2EvmMessage.data\n        );\n\n        // execute external contract, no exception\n        // Address.functionCallWithValue(lastReceivedData.target, lastReceivedData.data);\n    }\n\n    function getLastReceivedMessageDetails() external view returns (bytes32 messageId, ICommandData memory command) {\n        return (lastReceivedMessageId, lastReceivedData);\n    }\n\n    function hello() public pure returns (string memory greeting) {\n        return 'Hello world';\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        override(AccessControlEnumerableUpgradeable, CCIPReceiverUpgradeable)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IAny2EVMMessageReceiver).interfaceId ||\n            interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n}\n"
    },
    "contracts/protocol/ccip/storage/CCIPReceiverStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ICommandData, MessageType} from '../ICommandData.sol';\n\nabstract contract CCIPReceiverStorage {\n    event MessageReceived(bytes32 indexed messageId, uint64 indexed sourceChainSelector, address sender, bytes data);\n\n    error BridgeRouterExecutedFailed(MessageType messageType, bytes data);\n\n    address untangledBridgeRouter;\n    bytes32 public lastReceivedMessageId;\n    ICommandData public lastReceivedData;\n    mapping(bytes32 => ICommandData) public messageDataGroup;\n    mapping(bytes32 => ICommandData) public failedMessageDataGroup;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/ccip/storage/CCIPSenderStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ICommandData, MessageType} from '../ICommandData.sol';\nimport {IRouterClient} from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol';\nimport {LinkTokenInterface} from '@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol';\nimport {ICommandData} from '../ICommandData.sol';\n\nabstract contract CCIPSenderStorage {\n    // Event emitted when a message is sent to another chain.\n    event MessageSent(\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\n        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\n        address receiver, // The address of the receiver on the destination chain.\n        ICommandData data, // The text being sent.\n        address feeToken, // the token address used to pay CCIP fees.\n        uint256 fees // The fees paid for sending the CCIP message.\n    );\n\n    event UpdateWhitelistSelector(MessageType indexed target, bytes4 indexed functionSignature, bool isAllow);\n\n    IRouterClient public router;\n    LinkTokenInterface public linkToken;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/ccip/UntangledBridgeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../base/UntangledBase.sol';\nimport {MessageType} from './ICommandData.sol';\nimport {IUntangledBridgeRouter} from './interfaces/IUntangledBridgeRouter.sol';\n\ncontract UntangledBridgeRouter is UntangledBase, IUntangledBridgeRouter {\n    bytes32 public constant CCIP_RECEIVER_ROLE = keccak256('CCIP_RECEIVER_ROLE');\n\n    function initialize(address owner) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n        _setupRole(CCIP_RECEIVER_ROLE, owner);\n    }\n\n    function processMessage(MessageType messageType, bytes calldata data) external onlyRole(CCIP_RECEIVER_ROLE) {}\n}\n"
    },
    "contracts/protocol/ccip/UntangledReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Client} from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\nimport {AccessControlEnumerableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport {IAny2EVMMessageReceiver} from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol';\nimport {CCIPReceiverUpgradeable} from './chainlink-upgradeable/CCIPReceiverUpgradeable.sol';\nimport {ICommandData} from './ICommandData.sol';\nimport {CCIPReceiverStorage} from './storage/CCIPReceiverStorage.sol';\nimport {IUntangledBridgeRouter} from './interfaces/IUntangledBridgeRouter.sol';\nimport '../../base/UntangledBase.sol';\n\ncontract UntangledReceiver is UntangledBase, CCIPReceiverUpgradeable, CCIPReceiverStorage {\n    function initialize(address _router, address _untangledBridgeRouter) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n        __CCIPReceiver__init_unchained(_router);\n\n        untangledBridgeRouter = _untangledBridgeRouter;\n    }\n\n    function setBridgeRouter(address _untangledBridgeRouter) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        untangledBridgeRouter = _untangledBridgeRouter;\n    }\n\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        lastReceivedMessageId = any2EvmMessage.messageId;\n        lastReceivedData = abi.decode(any2EvmMessage.data, (ICommandData));\n        messageDataGroup[lastReceivedMessageId] = lastReceivedData;\n\n        emit MessageReceived(\n            any2EvmMessage.messageId,\n            any2EvmMessage.sourceChainSelector,\n            abi.decode(any2EvmMessage.sender, (address)),\n            any2EvmMessage.data\n        );\n\n        (bool success, ) = untangledBridgeRouter.call(\n            abi.encodeWithSignature('processMessage(uint8,bytes)', lastReceivedData.messageType, lastReceivedData.data)\n        );\n\n        if (!success) {\n            failedMessageDataGroup[lastReceivedMessageId] = lastReceivedData;\n            revert BridgeRouterExecutedFailed(lastReceivedData.messageType, lastReceivedData.data);\n        }\n    }\n\n    function getLastReceivedMessageDetails() external view returns (bytes32 messageId, ICommandData memory command) {\n        return (lastReceivedMessageId, lastReceivedData);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(AccessControlEnumerableUpgradeable, CCIPReceiverUpgradeable)\n        returns (bool)\n    {\n        return\n            AccessControlEnumerableUpgradeable.supportsInterface(interfaceId) ||\n            CCIPReceiverUpgradeable.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/protocol/ccip/UntangledSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {OwnerIsCreator} from '@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol';\nimport {Client} from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\nimport {LinkTokenInterface} from '@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol';\nimport {IRouterClient} from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol';\nimport {CCIPSenderStorage} from './storage/CCIPSenderStorage.sol';\n\nimport {ICommandData, MessageType} from './ICommandData.sol';\nimport {UntangledBase} from '../../base/UntangledBase.sol';\n\ncontract UntangledSender is UntangledBase, CCIPSenderStorage {\n    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance.\n\n    function initialize(IRouterClient router_, LinkTokenInterface link_) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n        __UntangledSender_init_unchained(router_, link_);\n    }\n\n    function __UntangledSender_init_unchained(\n        IRouterClient router_,\n        LinkTokenInterface link_\n    ) internal onlyInitializing {\n        router = router_;\n        linkToken = link_;\n    }\n\n    function sendMessage(\n        uint64 destinationChainSelector,\n        address receiver,\n        ICommandData calldata data,\n        uint256 gasLimit\n    ) external returns (bytes32 messageId) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(data), // ABI-encoded struct\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n            extraArgs: Client._argsToBytes(\n                // Additional arguments, setting gas limit and non-strict sequencing mode\n                Client.EVMExtraArgsV1({gasLimit: gasLimit, strict: false})\n            ),\n            // Set the feeToken  address, indicating LINK will be used for fees\n            feeToken: address(linkToken)\n        });\n\n        // Get the fee required to send the message\n        uint256 fees = router.getFee(destinationChainSelector, evm2AnyMessage);\n\n        if (fees > linkToken.balanceOf(address(this))) {\n            revert NotEnoughBalance(linkToken.balanceOf(address(this)), fees);\n        }\n\n        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK\n        require(linkToken.approve(address(router), fees), 'UntangledSender: LinkToken approval failed');\n\n        // Send the message through the router and store the returned message ID\n        messageId = router.ccipSend(destinationChainSelector, evm2AnyMessage);\n\n        // Emit an event with message details\n        emit MessageSent(messageId, destinationChainSelector, receiver, data, address(linkToken), fees);\n\n        // Return the message ID\n        return messageId;\n    }\n}\n"
    },
    "contracts/protocol/factory/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\n"
    },
    "contracts/protocol/Go.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\nimport {IGo} from './IGo.sol';\nimport {IUniqueIdentity} from '../uid/IUniqueIdentity.sol';\nimport {Registry} from '../storage/Registry.sol';\nimport {ConfigHelper} from '../libraries/ConfigHelper.sol';\n\n/// @title Go\n/// @author Untangled Team\n/// @dev Provides functions with UID\ncontract Go is IGo, AccessControlEnumerableUpgradeable {\n    bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\n    bytes32 public constant ZAPPER_ROLE = keccak256('ZAPPER_ROLE');\n\n    IUniqueIdentity public override uniqueIdentity;\n\n    uint256[11] public allIdTypes;\n\n    modifier onlyAdmin() {\n        require(hasRole(OWNER_ROLE, _msgSender()), 'Must have admin role to perform this action');\n        _;\n    }\n\n    function initialize(address owner, IUniqueIdentity _uniqueIdentity) public initializer {\n        require(\n            owner != address(0) && address(_uniqueIdentity) != address(0),\n            'Owner and config and UniqueIdentity addresses cannot be empty'\n        );\n        __AccessControl_init_unchained();\n        _setupRole(OWNER_ROLE, owner);\n        _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n        _performUpgrade();\n        uniqueIdentity = _uniqueIdentity;\n    }\n\n    /// @dev Update allIdTypes values\n    function performUpgrade() external onlyAdmin {\n        return _performUpgrade();\n    }\n\n    function _performUpgrade() internal {\n        allIdTypes[0] = ID_TYPE_0;\n        allIdTypes[1] = ID_TYPE_1;\n        allIdTypes[2] = ID_TYPE_2;\n        allIdTypes[3] = ID_TYPE_3;\n        allIdTypes[4] = ID_TYPE_4;\n        allIdTypes[5] = ID_TYPE_5;\n        allIdTypes[6] = ID_TYPE_6;\n        allIdTypes[7] = ID_TYPE_7;\n        allIdTypes[8] = ID_TYPE_8;\n        allIdTypes[9] = ID_TYPE_9;\n        allIdTypes[10] = ID_TYPE_10;\n    }\n\n    /**\n     * @notice Returns whether the provided account is:\n     * 1. go-listed for use of the Goldfinch protocol for any of the provided UID token types\n     * 2. is allowed to act on behalf of the go-listed EOA initiating this transaction\n     * Go-listed is defined as: whether `balanceOf(account, id)` on the UniqueIdentity\n     * contract is non-zero (where `id` is a supported token id on UniqueIdentity), falling back to the\n     * account's status on the legacy go-list maintained on GoldfinchConfig.\n     * @dev If tx.origin is 0x0 (e.g. in blockchain explorers such as Etherscan) this function will\n     *      throw an error if the account is not go listed.\n     * @param account The account whose go status to obtain\n     * @param onlyIdTypes Array of id types to check balances\n     * @return The account's go status\n     */\n    function goOnlyIdTypes(address account, uint256[] memory onlyIdTypes) public view override returns (bool) {\n        require(account != address(0), 'Zero address is not go-listed');\n\n        if (hasRole(ZAPPER_ROLE, account)) {\n            return true;\n        }\n\n        for (uint256 i = 0; i < onlyIdTypes.length; ++i) {\n            uint256 idType = onlyIdTypes[i];\n\n            uint256 accountIdBalance = uniqueIdentity.balanceOf(account, idType);\n            if (accountIdBalance > 0) {\n                return true;\n            }\n\n            /* \n       * Check if tx.origin has the UID, and has delegated that to `account`\n       * tx.origin should only ever be used for access control - it should never be used to determine\n       * the target address for any economic actions\n       * e.g. tx.origin should never be used as the source of truth for the target address to\n       * credit/debit/mint/burn any tokens to/from\n       * WARNING: If tx.origin is 0x0 (e.g. in blockchain explorers such as Etherscan) this function will\n       * throw an error if the account is not go listed.\n      /* solhint-disable avoid-tx-origin */\n            uint256 txOriginIdBalance = uniqueIdentity.balanceOf(tx.origin, idType);\n            if (txOriginIdBalance > 0) {\n                return uniqueIdentity.isApprovedForAll(tx.origin, account);\n            }\n            /* solhint-enable avoid-tx-origin */\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Returns a dynamic array of all UID types\n     */\n    function getAllIdTypes() public view returns (uint256[] memory) {\n        // create a dynamic array and copy the fixed array over so we return a dynamic array\n        uint256[] memory _allIdTypes = new uint256[](allIdTypes.length);\n        for (uint256 i = 0; i < allIdTypes.length; i++) {\n            _allIdTypes[i] = allIdTypes[i];\n        }\n\n        return _allIdTypes;\n    }\n\n    /**\n     * @notice Returns whether the provided account is go-listed for any UID type\n     * @param account The account whose go status to obtain\n     * @return The account's go status\n     */\n    function go(address account) public view override returns (bool) {\n        return goOnlyIdTypes(account, getAllIdTypes());\n    }\n\n    function initZapperRole() external onlyAdmin {\n        _setRoleAdmin(ZAPPER_ROLE, OWNER_ROLE);\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/protocol/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IUniqueIdentity} from \"../uid/IUniqueIdentity.sol\";\n\nabstract contract IGo {\n  uint256 public constant ID_TYPE_0 = 0; // non-US individual\n  uint256 public constant ID_TYPE_1 = 1; // US accredited individual\n  uint256 public constant ID_TYPE_2 = 2; // US non accredited individual\n  uint256 public constant ID_TYPE_3 = 3; // US entity\n  uint256 public constant ID_TYPE_4 = 4; // non-US entity\n  uint256 public constant ID_TYPE_5 = 5;\n  uint256 public constant ID_TYPE_6 = 6;\n  uint256 public constant ID_TYPE_7 = 7;\n  uint256 public constant ID_TYPE_8 = 8;\n  uint256 public constant ID_TYPE_9 = 9;\n  uint256 public constant ID_TYPE_10 = 10;\n\n  /// @notice Returns the address of the UniqueIdentity contract.\n  function uniqueIdentity() external virtual returns (IUniqueIdentity);\n\n  function go(address account) public view virtual returns (bool);\n\n  function goOnlyIdTypes(\n    address account,\n    uint256[] memory onlyIdTypes\n  ) public view virtual returns (bool);\n}\n"
    },
    "contracts/protocol/loan/ILoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport \"../../libraries/UnpackLoanParamtersLib.sol\";\n\nabstract contract ILoanInterestTermsContract {\n    Registry public registry;\n\n    mapping(bytes32 => bool) public startedLoan;\n\n    mapping(bytes32 => uint256) public repaidPrincipalAmounts;\n    mapping(bytes32 => uint256) public repaidInterestAmounts;\n\n    mapping(bytes32 => bool) public completedRepayment;\n\n    /// @notice register the start of a loan term\n    function registerTermStart(bytes32 agreementId) public virtual returns (bool);\n\n    /// @notice the total amount of principal and interest repaid for a given loan agreement\n    function getValueRepaidToDate(bytes32 agreementId) public view virtual returns (uint256, uint256);\n\n    /// @notice checks whether the repayments for a batch of loan agreements have been completed\n    function isCompletedRepayments(bytes32[] memory agreementIds) public view virtual returns (bool[] memory);\n\n    /**\n     * Expected repayment value with Amortization of Interest and Principal\n     * (AMORTIZATION) - will be used for repayment from Debtor\n     */\n    /// @notice calculates the expected repayment values (principal and interest) for a given loan agreement and timestamp\n    /// @param agreementId loan asset token in bytes32 format\n    /// @param timestamp unix timestamp\n    /// @return expectedPrincipal value of loan at a specific time\n    /// @return expectedInterest interest value at a specific time\n    function getExpectedRepaymentValues(\n        bytes32 agreementId,\n        uint256 timestamp\n    ) public view virtual returns (uint256 expectedPrincipal, uint256 expectedInterest);\n\n    /// @notice calculates the expected repayment values (principal and interest) for a batch of loan agreements and a given timestamp\n    function getMultiExpectedRepaymentValues(\n        bytes32[] memory agreementIds,\n        uint256 timestamp\n    ) public view virtual returns (uint256[] memory, uint256[] memory);\n\n    /// @dev set loan as repaid\n    function registerConcludeLoan(bytes32 agreementId) external virtual returns (bool);\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @notice register a loan repayment\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  payer address. The address of the payer.\n    /// @param  beneficiary address. The address of the payment's beneficiary.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    function registerRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public virtual returns (uint256 remains);\n\n    /// @notice the interest rate for a given loan agreement\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    function getInterestRate(bytes32 agreementId) public view virtual returns (uint256);\n\n    function unpackParamsForAgreementID(bytes32 agreementId)\n    public\n    view\n    virtual\n    returns (UnpackLoanParamtersLib.InterestParams memory params);\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/protocol/loan/ILoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport '../../tokens/ERC721/types.sol';\n\nabstract contract ILoanKernel {\n    Registry public registry;\n\n    /****************** */\n    // CONSTANTS\n    /****************** */\n    enum Errors {\n        // Debt has been already been issued\n        DEBT_ISSUED, // 0\n        // Order has already expired\n        ORDER_EXPIRED, // 1\n        // Debt issuance associated with order has been cancelled\n        ISSUANCE_CANCELLED, // 2\n        // Order has been cancelled\n        ORDER_CANCELLED, // 3\n        // Order parameters specify amount of creditor / debtor fees\n        // that is not equivalent to the amount of underwriter / relayer fees\n        ORDER_INVALID_INSUFFICIENT_OR_EXCESSIVE_FEES, // 4\n        // Order parameters specify insufficient principal amount for\n        // debtor to at least be able to meet his fees\n        ORDER_INVALID_INSUFFICIENT_PRINCIPAL, // 5\n        // Order parameters specify non zero fee for an unspecified recipient\n        ORDER_INVALID_UNSPECIFIED_FEE_RECIPIENT, // 6\n        // Order signatures are mismatched / malformed\n        ORDER_INVALID_NON_CONSENSUAL, // 7\n        // Insufficient balance or allowance for principal token transfer\n        CREDITOR_BALANCE_OR_ALLOWANCE_INSUFFICIENT, // 8\n        // Debt doesn't exists\n        DEBT_NOT_EXISTS, // 9\n        // Debtor it not completed repayment yet\n        NOT_COMPLETED_REPAYMENT // 10\n    }\n\n    enum FillingAddressesIndex {\n        SECURITIZATION_POOL,\n        PRINCIPAL_TOKEN_ADDRESS,\n        REPAYMENT_ROUTER,\n        TERM_CONTRACT,\n        RELAYER\n    }\n\n    enum FillingNumbersIndex {\n        CREDITOR_FEE,\n        ASSET_PURPOSE\n    }\n\n    bytes32 public constant NULL_ISSUANCE_HASH = bytes32(0);\n    bytes16 public constant NULL_COLLATERAL_INFO_HASH = bytes16(0);\n    address public constant NULL_ADDRESS = address(0x0);\n    //********************************************************* */\n\n    //****** */\n    // EVENTS\n    //****** */\n    event LogDebtKernelError(uint8 indexed _errorId, bytes32 indexed _orderHash, string desc);\n\n    event LogFeeTransfer(address indexed payer, address token, uint256 amount, address indexed beneficiary);\n\n    event IssuedNewInputLoans(address[] debtor, uint256[] loanTokenIds);\n\n    event LogDebtOrderFilled(bytes32 _agreementId, uint256 _principal, address _principalToken, address _relayer);\n\n    //********************************************************* */\n\n    /*********** */\n    // STRUCTURES\n    /*********** */\n\n    struct LoanIssuance {\n        address version;\n        address termsContract;\n        address[] debtors;\n        bytes32[] termsContractParameters; // for different loans\n        bytes32[] agreementIds;\n        uint256[] salts;\n    }\n\n    struct LoanOrder {\n        LoanIssuance issuance;\n        address principalTokenAddress;\n        uint256[] principalAmounts;\n        uint256 creditorFee;\n        address relayer;\n        uint256[] expirationTimestampInSecs;\n        bytes32[] debtOrderHashes;\n        uint8[] riskScores;\n        uint8 assetPurpose;\n    }\n\n    struct FillDebtOrderParam {\n        address[] orderAddresses; // 0-pool, 1-principal token address, 2-repayment router, 3-term contract, 4-relayer,...\n        uint256[] orderValues; //  0-creditorFee, 1-asset purpose,..., [x] principalAmounts, [x] expirationTimestampInSecs, [x] - salts, [x] - riskScores\n        bytes32[] termsContractParameters; // Term contract parameters from different farmers, encoded as hash strings\n        LoanAssetInfo[] latInfo;\n    }\n\n    /*********** */\n    // VARIABLES\n    /*********** */\n    mapping(bytes32 => bool) public issuanceCancelled;\n    mapping(bytes32 => bool) public debtOrderCancelled;\n    mapping(bytes32 => bool) public debtOrderCompleted;\n\n    /// @notice conclude a loan by stopping lending/loan terms or allowing the loan loss. It takes the creditor, agreement ID, and term contract as input\n    function concludeLoan(address creditor, bytes32 agreementId, address termContract) public virtual;\n}\n"
    },
    "contracts/protocol/loan/ILoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\n\nabstract contract ILoanRegistry {\n    Registry public registry;\n\n    // loan -> debtors\n    struct LoanEntry {\n        address loanTermContract;\n        address debtor;\n        address principalTokenAddress;\n        bytes32 termsParam; // actually inside this param was already included P token address\n        uint256 salt;\n        uint256 issuanceBlockTimestamp;\n        uint256 lastRepayTimestamp;\n        uint256 expirationTimestamp;\n        uint8 riskScore;\n        Configuration.ASSET_PURPOSE assetPurpose;\n    }\n\n    event UpdateLoanEntry(bytes32 indexed tokenId, LoanEntry entry);\n    event UpdateCompleteLoan(bytes32 indexed tokenId, bool status);\n\n    mapping(bytes32 => LoanEntry) public entries;\n\n    mapping(bytes32 => bool) public manualInterestLoan;\n    mapping(bytes32 => uint256) public manualInterestAmountLoan;\n\n    mapping(bytes32 => bool) public completedLoans;\n\n    function initialize(Registry _registry) public virtual;\n\n    /**\n     * Record new External Loan to blockchain\n     */\n    function insert(\n        bytes32 tokenId,\n        address termContract,\n        address debtor,\n        bytes32 termsContractParameter,\n        address pTokenAddress,\n        uint256 _salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] calldata assetPurposeAndRiskScore\n    ) external virtual returns (bool);\n\n    /// @notice retrieves loan information\n    function getEntry(bytes32 agreementId) public view virtual returns (LoanEntry memory);\n\n    /// @notice retrieves the debtor's address for a given loan\n    function getLoanDebtor(bytes32 tokenId) public view virtual returns (address);\n\n    /// @notice retrieves the term contract parameters for a given loan\n    function getLoanTermParams(bytes32 tokenId) public view virtual returns (bytes32);\n\n    /// @notice retrieves the principal token address for a given loan agreement ID\n    function getPrincipalTokenAddress(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the debtor's address for a given loan agreement ID\n    function getDebtor(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the term contract address for a given loan agreement ID\n    function getTermContract(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the risk score for a given loan agreement ID\n    function getRiskScore(bytes32 agreementId) public view virtual returns (uint8);\n\n    /// @notice retrieves the asset purpose for a given loan agreement ID\n    function getAssetPurpose(bytes32 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n\n    /// @notice retrieves the timestamp of the block at which a debt agreement was issued\n    function getIssuanceBlockTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    /// @notice retrieves the timestamp of the last repayment made for a given loan agreement ID\n    function getLastRepaymentTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    /// @notice retrieves the terms contract parameters for a given loan agreement ID\n    function getTermsContractParameters(bytes32 agreementId) public view virtual returns (bytes32);\n\n    /// @notice retrieves the expiration timestamp for a given loan agreement ID\n    function getExpirationTimestamp(bytes32 agreementId) public view virtual returns (uint256);\n\n    /// @notice updates the timestamp of the last repayment made for a given loan agreement ID\n    function updateLastRepaymentTimestamp(bytes32 agreementId, uint256 newTimestamp) public virtual;\n\n    /// @notice retrieves information about the principal payment for a given loan agreement ID\n    /// @dev Get principal payment info before start doing repayment\n    function principalPaymentInfo(\n        bytes32 agreementId\n    ) public view virtual returns (address pTokenAddress, uint256 pAmount);\n\n    /// @notice marks a loan agreement as completed by setting the completedLoans mapping entry to true for a given agreement ID\n    function setCompletedLoan(bytes32 agreementId) public virtual;\n}\n"
    },
    "contracts/protocol/loan/ILoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {UntangledBase} from '../../base/UntangledBase.sol';\nimport {Registry} from '../../storage/Registry.sol';\n\nabstract contract ILoanRepaymentRouter is UntangledBase {\n    Registry public registry;\n\n    enum Errors {\n        DEBT_AGREEMENT_NONEXISTENT,\n        PAYER_BALANCE_OR_ALLOWANCE_INSUFFICIENT,\n        REPAYMENT_REJECTED_BY_TERMS_CONTRACT\n    }\n\n    event LogOutputSubmit(bytes32 indexed _agreementId, uint256 indexed _tokenIndex, uint256 _totalAmount);\n\n    function initialize(Registry _registry) public virtual;\n\n    event LogRepayment(\n        bytes32 indexed _agreementId,\n        address indexed _payer,\n        address indexed _beneficiary,\n        uint256 _amount,\n        address _token\n    );\n\n    event LogRepayments(bytes32[] _agreementIds, address _payer, uint256[] _amounts);\n\n    event LogError(uint8 indexed _errorId, bytes32 indexed _agreementId);\n\n    /// @notice allows batch repayment of multiple loans by iterating over the given agreement IDs and amounts\n    /// @dev calls _assertRepaymentRequest and _doRepay for each repayment, and emits the LogRepayments event to indicate the successful batch repayment\n    function repayInBatch(\n        bytes32[] calldata agreementIds,\n        uint256[] calldata amounts,\n        address tokenAddress\n    ) external virtual returns (bool);\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/loan/LoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../base/UntangledBase.sol';\nimport '../../interfaces/ILoanInterestTermsContract.sol';\nimport '../../libraries/UnpackLoanParamtersLib.sol';\nimport '../../libraries/UntangledMath.sol';\nimport '../../libraries/ConfigHelper.sol';\n\n/// @title LoanKernel\n/// @author Untangled Team\n/// @dev Upload loan and conclude loan\ncontract LoanInterestTermsContract is UntangledBase, ILoanInterestTermsContract {\n    using ConfigHelper for Registry;\n\n    uint256 public constant NUM_AMORTIZATION_UNIT_TYPES = 6;\n\n    /// @dev Represents the number of days in a year\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    /// @dev Represents the number of seconds in a minute\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint256 public constant WEEK_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 7;\n    uint256 public constant MONTH_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * 30;\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n\n    // To convert an encoded interest rate into its equivalent multiplier\n    // (for purposes of calculating total interest), divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 0.01 interest multiplier\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_MULTIPLIER = INTEREST_RATE_SCALING_FACTOR_PERCENT * 100;\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n\n        registry = _registry;\n    }\n\n    //////////////////////////////\n    // EVENTS                 ///\n    ////////////////////////////\n    event LogInterestTermStart(\n        bytes32 indexed agreementId,\n        address indexed principalToken,\n        uint256 principalAmount,\n        uint256 interestRate,\n        uint256 indexed amortizationUnitType,\n        uint256 termLengthInAmortizationUnits\n    );\n\n    event LogRegisterRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    );\n\n    event LogRegisterCompleteTerm(bytes32 agreementId);\n\n    //////////////////////////////\n    // MODIFIERS              ///\n    ////////////////////////////\n    modifier onlyKernel() {\n        require(_msgSender() == address(registry.getLoanKernel()), 'LoanInterestTermsContract: Only for LoanKernel.');\n        _;\n    }\n\n    modifier onlyRouter() {\n        require(\n            _msgSender() == address(registry.getLoanRepaymentRouter()),\n            'LoanInterestTermsContract: Only for Repayment Router.'\n        );\n        _;\n    }\n\n    modifier onlyHaventStartedLoan(bytes32 agreementId) {\n        require(!startedLoan[agreementId], 'LoanInterestTermsContract: Loan has started!');\n        _;\n    }\n\n    function _addRepaidPrincipalAmount(bytes32 agreementId, uint256 repaidAmount) private {\n        repaidPrincipalAmounts[agreementId] += repaidAmount;\n    }\n\n    function _addRepaidInterestAmount(bytes32 agreementId, uint256 repaidAmount) private {\n        repaidInterestAmounts[agreementId] += repaidAmount;\n    }\n\n    function _setCompletedRepayment(bytes32 agreementId) private {\n        completedRepayment[agreementId] = true;\n    }\n\n    // Register to start Loan term for batch of agreement Ids\n    /// @inheritdoc ILoanInterestTermsContract\n    function registerTermStart(bytes32 agreementId)\n        public\n        override\n        whenNotPaused\n        onlyKernel\n        onlyHaventStartedLoan(agreementId)\n        returns (bool)\n    {\n        startedLoan[agreementId] = true;\n        return true;\n    }\n\n    /// @inheritdoc ILoanInterestTermsContract\n    function registerConcludeLoan(bytes32 agreementId) external override whenNotPaused nonReentrant returns (bool) {\n        registry.requireLoanKernel(_msgSender());\n        registry.getLoanRegistry().setCompletedLoan(agreementId);\n\n        emit LogRegisterCompleteTerm(agreementId);\n        return true;\n    }\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  payer address. The address of the payer.\n    /// @param  beneficiary address. The address of the payment's beneficiary.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    /// @inheritdoc ILoanInterestTermsContract\n    function registerRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public override onlyRouter returns (uint256 remains) {\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n        require(\n            tokenAddress == loanRegistry.getPrincipalTokenAddress(agreementId),\n            'LoanTermsContract: Invalid token for repayment.'\n        );\n        require(!loanRegistry.completedLoans(agreementId), 'LoanTermsContract: Completed Loan.');\n        require(startedLoan[agreementId], 'LoanTermsContract: Loan has not started yet.');\n\n        uint256 currentTimestamp = block.timestamp;\n\n        uint256 expectedPrincipal;\n        uint256 expectedInterest;\n        // query total outstanding amounts\n        (expectedPrincipal, expectedInterest) = getExpectedRepaymentValues(agreementId, currentTimestamp);\n        // TODO: Currently only allow Debtor to repay with amount >= expectedInterest of that time\n        // Because, we haven't made any mechanism to manage outstanding interest amounts in the case when Debtor\n        // repaid with amount < expectedInterest (at that moment)\n        require(unitsOfRepayment >= expectedInterest, 'LoanTermsContract: Expected interest amount is minimum.');\n\n        // exceed expectation, Debtor can pay all at once\n        if (unitsOfRepayment >= expectedPrincipal + expectedInterest) {\n            _setCompletedRepayment(agreementId);\n            _addRepaidInterestAmount(agreementId, expectedInterest);\n            _addRepaidPrincipalAmount(agreementId, expectedPrincipal);\n            // put the remain to interest\n            remains = unitsOfRepayment - (expectedPrincipal + expectedInterest);\n        } else {\n            // if currently Debtor no need to repay for interest\n            if (expectedInterest == 0) {\n                _addRepaidPrincipalAmount(agreementId, unitsOfRepayment);\n            } else {\n                // if expectedInterest > 0 ( & unitsOfRepayment >= expectedInterest)\n                _addRepaidInterestAmount(agreementId, expectedInterest);\n                if (unitsOfRepayment - expectedInterest > 0) {\n                    // Debtor is not able to fulfill the expectedPrincipal as we already validated from first IF statement\n                    // -> there is no remains for adding to repaidInterestAmount\n                    _addRepaidPrincipalAmount(agreementId, unitsOfRepayment - expectedInterest);\n                }\n            }\n        }\n\n        // Update Debt registry record\n        loanRegistry.updateLastRepaymentTimestamp(agreementId, currentTimestamp);\n        // loanRegistry.selfEvaluateCollateralRatio(agreementId);\n\n        // Emit new event\n        emit LogRegisterRepayment(agreementId, payer, beneficiary, unitsOfRepayment, tokenAddress);\n\n        return remains;\n    }\n\n    /// @inheritdoc ILoanInterestTermsContract\n    function getValueRepaidToDate(bytes32 agreementId) public view override returns (uint256, uint256) {\n        return (repaidPrincipalAmounts[agreementId], repaidInterestAmounts[agreementId]);\n    }\n\n    /// @inheritdoc ILoanInterestTermsContract\n    function isCompletedRepayments(bytes32[] memory agreementIds) public view override returns (bool[] memory) {\n        bool[] memory result = new bool[](agreementIds.length);\n        uint256 aagreementIdsLength = agreementIds.length;\n        for (uint256 i = 0; i < aagreementIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            result[i] = completedRepayment[agreementIds[i]];\n        }\n        return result;\n    }\n\n    /**\n     * Expected repayment value with Amortization of Interest and Principal\n     * (AMORTIZATION) - will be used for repayment from Debtor\n     */\n    /// @inheritdoc ILoanInterestTermsContract\n    function getExpectedRepaymentValues(\n        bytes32 agreementId,\n        uint256 timestamp\n    ) public view override returns (uint256 expectedPrincipal, uint256 expectedInterest) {\n        UnpackLoanParamtersLib.InterestParams memory params = unpackParamsForAgreementID(agreementId);\n\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n\n        uint256 repaidPrincipalAmount = repaidPrincipalAmounts[agreementId];\n        uint256 repaidInterestAmount = repaidInterestAmounts[agreementId];\n        uint256 lastRepaymentTimestamp = loanRegistry.getLastRepaymentTimestamp(agreementId);\n\n        bool isManualInterestLoan = loanRegistry.manualInterestLoan(agreementId);\n        uint256 manualInterestAmountLoan = 0;\n        if (isManualInterestLoan) {\n            manualInterestAmountLoan = loanRegistry.manualInterestAmountLoan(agreementId);\n        }\n\n        (expectedPrincipal, expectedInterest) = _getExpectedRepaymentValuesToTimestamp(\n            params,\n            lastRepaymentTimestamp,\n            timestamp,\n            repaidPrincipalAmount,\n            repaidInterestAmount,\n            isManualInterestLoan,\n            manualInterestAmountLoan\n        );\n    }\n\n    /// @inheritdoc ILoanInterestTermsContract\n    function getMultiExpectedRepaymentValues(bytes32[] memory agreementIds, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256[] memory expectedPrincipals = new uint256[](agreementIds.length);\n        uint256[] memory expectedInterests = new uint256[](agreementIds.length);\n        uint256 agreementIdsLength = agreementIds.length;\n        for (uint256 i = 0; i < agreementIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            (uint256 expectedPrincipal, uint256 expectedInterest) = getExpectedRepaymentValues(\n                agreementIds[i],\n                timestamp\n            );\n            expectedPrincipals[i] = expectedPrincipal;\n            expectedInterests[i] = expectedInterest;\n        }\n        return (expectedPrincipals, expectedInterests);\n    }\n\n    /// @inheritdoc ILoanInterestTermsContract\n    function getInterestRate(bytes32 agreementId) public view override returns (uint256) {\n        return unpackParamsForAgreementID(agreementId).interestRate;\n    }\n\n    /// @param amortizationUnitType AmortizationUnitType enum\n    /// @return the corresponding length of the unit in seconds\n    function _getAmortizationUnitLengthInSeconds(UnpackLoanParamtersLib.AmortizationUnitType amortizationUnitType)\n        private\n        pure\n        returns (uint256)\n    {\n        if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.MINUTES) {\n            return MINUTE_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.HOURS) {\n            return HOUR_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.DAYS) {\n            return DAY_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.WEEKS) {\n            return WEEK_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.MONTHS) {\n            return MONTH_LENGTH_IN_SECONDS;\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.YEARS) {\n            return YEAR_LENGTH_IN_SECONDS;\n        } else {\n            revert('Unknown amortization unit type.');\n        }\n    }\n\n    /**\n     *   Get parameters by Agreement ID (commitment hash)\n     */\n    function unpackParamsForAgreementID(\n        bytes32 agreementId\n    ) public view override returns (UnpackLoanParamtersLib.InterestParams memory params) {\n        bytes32 parameters;\n        uint256 issuanceBlockTimestamp = 0;\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n        issuanceBlockTimestamp = loanRegistry.getIssuanceBlockTimestamp(agreementId);\n        parameters = loanRegistry.getTermsContractParameters(agreementId);\n        // The principal amount denominated in the aforementioned token.\n        uint256 principalAmount;\n        // The interest rate accrued per amortization unit.\n        uint256 interestRate;\n        // The amortization unit in which the repayments installments schedule is defined.\n        uint256 rawAmortizationUnitType;\n        // The debt's entire term's length, denominated in the aforementioned amortization units\n        uint256 termLengthInAmortizationUnits;\n        uint256 gracePeriodInDays;\n\n        (\n            principalAmount,\n            interestRate,\n            rawAmortizationUnitType,\n            termLengthInAmortizationUnits,\n            gracePeriodInDays\n        ) = UnpackLoanParamtersLib.unpackParametersFromBytes(parameters);\n\n        UnpackLoanParamtersLib.AmortizationUnitType amortizationUnitType = UnpackLoanParamtersLib.AmortizationUnitType(\n            rawAmortizationUnitType\n        );\n\n        // Calculate term length base on Amortization Unit and number\n        uint256 termLengthInSeconds = termLengthInAmortizationUnits *\n            _getAmortizationUnitLengthInSeconds(amortizationUnitType);\n\n        return\n            UnpackLoanParamtersLib.InterestParams({\n                principalAmount: principalAmount,\n                interestRate: interestRate,\n                termStartUnixTimestamp: issuanceBlockTimestamp,\n                termEndUnixTimestamp: termLengthInSeconds + issuanceBlockTimestamp,\n                amortizationUnitType: amortizationUnitType,\n                termLengthInAmortizationUnits: termLengthInAmortizationUnits\n            });\n    }\n\n    // Calculate interest amount for a duration with specific Principal amount\n    function _calculateInterestForDuration(\n        uint256 _principalAmount,\n        uint256 _interestRate,\n        uint256 _durationLengthInSec\n    ) private pure returns (uint256) {\n\n        // x = 10 ** 27 + IR * (10 ** 27 / 10 ** 4 / 100) / YLIR\n        uint256 x = UntangledMath.ONE +\n                        (_interestRate * UntangledMath.ONE / INTEREST_RATE_SCALING_FACTOR_PERCENT / 100) /\n                        YEAR_LENGTH_IN_SECONDS;\n\n        return\n            (_principalAmount *\n                UntangledMath.rpow(x,\n                    _durationLengthInSec,\n                    UntangledMath.ONE\n                )) /\n            UntangledMath.ONE -\n            _principalAmount;\n    }\n\n    /**\n     * Calculate values which Debtor need to pay to conclude current Loan\n     */\n    /// @dev calculates the expected principal and interest amounts that the debtor needs to pay to conclude the current loan\n    /// It takes into account the repayment history, timestamps, and additional parameters specific to manual interest loans\n    function _getExpectedRepaymentValuesToTimestamp(\n        UnpackLoanParamtersLib.InterestParams memory _params,\n        uint256 _lastRepaymentTimestamp, // timestamp of last repayment from debtor\n        uint256 _timestamp,\n        uint256 repaidPrincipalAmount,\n        uint256 repaidInterestAmount,\n        bool isManualInterestLoan,\n        uint256 manualInterestAmountLoan\n    ) private pure returns (uint256 expectedPrinciapal, uint256 expectedInterest) {\n        uint256 outstandingPrincipal = _params.principalAmount - repaidPrincipalAmount;\n\n        expectedPrinciapal = outstandingPrincipal;\n\n        if (isManualInterestLoan) {\n            expectedInterest = manualInterestAmountLoan;\n        } else {\n            expectedInterest = _calculateInterestAmountToTimestamp(\n                _params.principalAmount,\n                outstandingPrincipal,\n                repaidInterestAmount,\n                _params.interestRate,\n                _params.termStartUnixTimestamp,\n                _params.termEndUnixTimestamp,\n                _lastRepaymentTimestamp,\n                _timestamp\n            );\n        }\n    }\n\n    // Calculate interest amount Debtor need to pay until current date\n    function _calculateInterestAmountToTimestamp(\n        uint256 _principalAmount,\n        uint256 _currentPrincipalAmount,\n        uint256 _paidInterestAmount,\n        uint256 _annualInterestRate,\n        uint256 _startTermTimestamp,\n        uint256 _endTermTimestamp,\n        uint256 _lastRepayTimestamp,\n        uint256 _timestamp\n    ) private pure returns (uint256) {\n        if (_timestamp <= _startTermTimestamp) {\n            return 0;\n        }\n        uint256 interest = 0;\n\n        // dangerous-strict-equalities\n        uint256 elapseTimeFromLastRepay = _timestamp < _lastRepayTimestamp ? 0 : (_timestamp - _lastRepayTimestamp);\n        uint256 elapseTimeFromStart = _timestamp < _startTermTimestamp ? 0 : (_timestamp - _startTermTimestamp);\n\n        // If still within the term length\n        if (_timestamp < _endTermTimestamp) {\n            // Have just made new repayment\n            if (\n                _timestamp <= _lastRepayTimestamp && _paidInterestAmount > 0) {\n                interest = 0;\n            } else {\n                if (_paidInterestAmount > 0) {\n                    // Has made at least 1 repayment\n                    interest = _calculateInterestForDuration(\n                        _currentPrincipalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromLastRepay\n                    );\n                } else {\n                    // Haven't made any repayment\n                    interest = _calculateInterestForDuration(\n                        _principalAmount,\n                        _annualInterestRate,\n                        elapseTimeFromStart\n                    );\n                }\n            }\n        } else {\n            // If debtor has made at least 1 repayment\n            if (_paidInterestAmount > 0) {\n                interest = _calculateInterestForDuration(\n                    _currentPrincipalAmount,\n                    _annualInterestRate,\n                    elapseTimeFromLastRepay\n                );\n            } else {\n                interest = _calculateInterestForDuration(_principalAmount, _annualInterestRate, elapseTimeFromStart);\n            }\n        }\n\n        return interest;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/loan/LoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ERC165CheckerUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol';\n\nimport '../../interfaces/ILoanKernel.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../libraries/ConfigHelper.sol';\nimport '../../libraries/UntangledMath.sol';\nimport '../../tokens/ERC721/types.sol';\nimport {ISecuritizationPool} from '../pool/ISecuritizationPool.sol';\nimport {ISecuritizationTGE} from '../pool/ISecuritizationTGE.sol';\n\n/// @title LoanKernel\n/// @author Untangled Team\n/// @notice Upload loan and conclude loan\ncontract LoanKernel is ILoanKernel, UntangledBase {\n    using ConfigHelper for Registry;\n    using ERC165CheckerUpgradeable for address;\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init_unchained(_msgSender());\n        registry = _registry;\n    }\n\n    modifier validFillingOrderAddresses(address[] memory _orderAddresses) {\n        require(\n            _orderAddresses[uint8(FillingAddressesIndex.SECURITIZATION_POOL)] != address(0x0),\n            'SECURITIZATION_POOL is zero address.'\n        );\n\n        require(\n            _orderAddresses[uint8(FillingAddressesIndex.REPAYMENT_ROUTER)] != address(0x0),\n            'REPAYMENT_ROUTER is zero address.'\n        );\n        require(\n            _orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)] != address(0x0),\n            'TERM_CONTRACT is zero address.'\n        );\n        require(\n            _orderAddresses[uint8(FillingAddressesIndex.PRINCIPAL_TOKEN_ADDRESS)] != address(0x0),\n            'PRINCIPAL_TOKEN_ADDRESS is zero address.'\n        );\n        _;\n    }\n\n    //******************** */\n    // PRIVATE FUNCTIONS\n    //******************** */\n\n    /**\n     * Helper function that constructs a issuance structs from the given\n     * parameters.\n     */\n    function _getIssuance(\n        address[] memory _orderAddresses,\n        address[] memory _debtors,\n        bytes32[] memory _termsContractParameters,\n        uint256[] memory _salts\n    ) private pure returns (LoanIssuance memory _issuance) {\n        LoanIssuance memory issuance = LoanIssuance({\n            version: _orderAddresses[uint8(FillingAddressesIndex.REPAYMENT_ROUTER)],\n            debtors: _debtors,\n            termsContract: _orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)],\n            termsContractParameters: _termsContractParameters,\n            salts: _salts,\n            agreementIds: _genLoanAgreementIds(\n                _orderAddresses[uint8(FillingAddressesIndex.REPAYMENT_ROUTER)],\n                _debtors,\n                _orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)],\n                _termsContractParameters,\n                _salts\n            )\n        });\n\n        return issuance;\n    }\n\n    function _getDebtOrderHashes(LoanOrder memory debtOrder) private view returns (bytes32[] memory) {\n        uint256 _length = debtOrder.issuance.debtors.length;\n        bytes32[] memory orderHashses = new bytes32[](_length);\n        for (uint256 i = 0; i < _length; i = UntangledMath.uncheckedInc(i)) {\n            orderHashses[i] = _getDebtOrderHash(\n                debtOrder.issuance.agreementIds[i],\n                debtOrder.principalAmounts[i],\n                debtOrder.principalTokenAddress,\n                debtOrder.relayer,\n                debtOrder.expirationTimestampInSecs[i]\n            );\n        }\n        return orderHashses;\n    }\n\n    function _getLoanOrder(\n        address[] memory _debtors,\n        address[] memory _orderAddresses,\n        uint256[] memory _orderValues,\n        bytes32[] memory _termContractParameters,\n        uint256[] memory _salts\n    ) private view returns (LoanOrder memory _debtOrder) {\n        bytes32[] memory emptyDebtOrderHashes = new bytes32[](_debtors.length);\n        LoanOrder memory debtOrder = LoanOrder({\n            issuance: _getIssuance(_orderAddresses, _debtors, _termContractParameters, _salts),\n            relayer: _orderAddresses[uint8(FillingAddressesIndex.RELAYER)],\n            principalTokenAddress: _orderAddresses[uint8(FillingAddressesIndex.PRINCIPAL_TOKEN_ADDRESS)],\n            principalAmounts: _principalAmountsFromOrderValues(_orderValues, _termContractParameters.length),\n            creditorFee: _orderValues[uint8(FillingNumbersIndex.CREDITOR_FEE)],\n            expirationTimestampInSecs: _expirationTimestampsFromOrderValues(\n                _orderValues,\n                _termContractParameters.length\n            ),\n            debtOrderHashes: emptyDebtOrderHashes,\n            riskScores: _riskScoresFromOrderValues(_orderValues, _termContractParameters.length),\n            assetPurpose: uint8(_orderValues[uint8(FillingNumbersIndex.ASSET_PURPOSE)])\n        });\n        debtOrder.debtOrderHashes = _getDebtOrderHashes(debtOrder);\n        return debtOrder;\n    }\n\n    //** Issue Loan to Farmers */\n    function _issueDebtAgreements(\n        uint256 tokenId,\n        address termContract,\n        address debtor,\n        bytes32 termsParam,\n        address principalTokenAddress,\n        uint256 salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] memory assetPurposeAndRiskScore\n    ) private {\n        require(\n            registry.getLoanRegistry().insert(\n                bytes32(tokenId),\n                termContract,\n                debtor,\n                termsParam,\n                principalTokenAddress,\n                salt,\n                expirationTimestampInSecs,\n                assetPurposeAndRiskScore\n            ),\n            'LoanKernel: insert failure'\n        );\n    }\n\n    /**\n     * 6 is fixed size of constant addresses list\n     */\n    function _debtorsFromOrderAddresses(\n        address[] memory _orderAddresses,\n        uint256 _length\n    ) private pure returns (address[] memory) {\n        address[] memory debtors = new address[](_length);\n        for (uint256 i = 5; i < (5 + _length); i = UntangledMath.uncheckedInc(i)) {\n            debtors[i - 5] = _orderAddresses[i];\n        }\n        return debtors;\n    }\n\n    // Dettach principal amounts from order values\n    function _principalAmountsFromOrderValues(\n        uint256[] memory _orderValues,\n        uint256 _length\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory principalAmounts = new uint256[](_length);\n        for (uint256 i = 2; i < (2 + _length); i = UntangledMath.uncheckedInc(i)) {\n            principalAmounts[i - 2] = _orderValues[i];\n        }\n        return principalAmounts;\n    }\n\n    function _expirationTimestampsFromOrderValues(\n        uint256[] memory _orderValues,\n        uint256 _length\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory expirationTimestamps = new uint256[](_length);\n        for (uint256 i = 2 + _length; i < (2 + _length * 2); i = UntangledMath.uncheckedInc(i)) {\n            expirationTimestamps[i - 2 - _length] = _orderValues[i];\n        }\n        return expirationTimestamps;\n    }\n\n    function _saltFromOrderValues(\n        uint256[] memory _orderValues,\n        uint256 _length\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory salts = new uint256[](_length);\n        for (uint256 i = 2 + _length * 2; i < (2 + _length * 3); i = UntangledMath.uncheckedInc(i)) {\n            salts[i - 2 - _length * 2] = _orderValues[i];\n        }\n        return salts;\n    }\n\n    function _riskScoresFromOrderValues(\n        uint256[] memory _orderValues,\n        uint256 _length\n    ) private pure returns (uint8[] memory) {\n        uint8[] memory riskScores = new uint8[](_length);\n        for (uint256 i = 2 + _length * 3; i < (2 + _length * 4); i = UntangledMath.uncheckedInc(i)) {\n            riskScores[i - 2 - _length * 3] = uint8(_orderValues[i]);\n        }\n        return riskScores;\n    }\n\n    function _getAssetPurposeAndRiskScore(uint8 assetPurpose, uint8 riskScore) private pure returns (uint8[] memory) {\n        uint8[] memory assetPurposeAndRiskScore = new uint8[](2);\n        assetPurposeAndRiskScore[0] = assetPurpose;\n        assetPurposeAndRiskScore[1] = riskScore;\n        return assetPurposeAndRiskScore;\n    }\n\n    function _burnLoanAssetToken(bytes32 agreementId) private {\n        registry.getLoanAssetToken().burn(uint256(agreementId));\n    }\n\n    function _assertDebtExisting(bytes32 agreementId) private view returns (bool) {\n        return registry.getLoanAssetToken().ownerOf(uint256(agreementId)) != address(0);\n    }\n\n    function _assertCompletedRepayment(bytes32 agreementId) private view returns (bool) {\n        return registry.getLoanInterestTermsContract().completedRepayment(agreementId);\n    }\n\n    /// @inheritdoc ILoanKernel\n    /// @dev A loan, stop lending/loan terms or allow the loan loss\n    function concludeLoan(address creditor, bytes32 agreementId, address termContract) public override whenNotPaused {\n        require(_msgSender() == address(registry.getLoanRepaymentRouter()), 'LoanKernel: Only LoanRepaymentRouter');\n        require(creditor != address(0), 'Invalid creditor account.');\n        require(agreementId != bytes32(0), 'Invalid agreement id.');\n        require(termContract != address(0), 'Invalid terms contract.');\n\n        if (!_assertDebtExisting(agreementId)) {\n            revert('Debt does not exsits');\n        }\n\n        require(\n            ILoanInterestTermsContract(termContract).registerConcludeLoan(agreementId),\n            'Cannot register conclude loan.'\n        );\n\n        _burnLoanAssetToken(agreementId);\n    }\n\n    /*********************** */\n    // EXTERNAL FUNCTIONS\n    /*********************** */\n\n    function concludeLoans(\n        address[] calldata creditors,\n        bytes32[] calldata agreementIds,\n        address termContract\n    ) external whenNotPaused nonReentrant {\n        uint256 creditorsLength = creditors.length;\n        for (uint256 i = 0; i < creditorsLength; i = UntangledMath.uncheckedInc(i)) {\n            concludeLoan(creditors[i], agreementIds[i], termContract);\n        }\n    }\n\n    /**\n     * Filling new Debt Order\n     * Notice:\n     * - All Debt Order must to have same:\n     *   + TermContract\n     *   + Creditor Fee\n     *   + Debtor Fee\n     */\n    function fillDebtOrder(\n        FillDebtOrderParam calldata fillDebtOrderParam\n    ) external whenNotPaused nonReentrant validFillingOrderAddresses(fillDebtOrderParam.orderAddresses) {\n        address poolAddress = fillDebtOrderParam.orderAddresses[uint8(FillingAddressesIndex.SECURITIZATION_POOL)];\n        require(fillDebtOrderParam.termsContractParameters.length > 0, 'LoanKernel: Invalid Term Contract params');\n\n        uint256[] memory salts = _saltFromOrderValues(\n            fillDebtOrderParam.orderValues,\n            fillDebtOrderParam.termsContractParameters.length\n        );\n        LoanOrder memory debtOrder = _getLoanOrder(\n            _debtorsFromOrderAddresses(\n                fillDebtOrderParam.orderAddresses,\n                fillDebtOrderParam.termsContractParameters.length\n            ),\n            fillDebtOrderParam.orderAddresses,\n            fillDebtOrderParam.orderValues,\n            fillDebtOrderParam.termsContractParameters,\n            salts\n        );\n\n        uint x = 0;\n        uint256 expectedAssetsValue = 0;\n\n        // Mint to pool\n        for (uint i = 0; i < fillDebtOrderParam.latInfo.length; i = UntangledMath.uncheckedInc(i)) {\n            registry.getLoanAssetToken().safeMint(poolAddress, fillDebtOrderParam.latInfo[i]);\n\n            for (uint j = 0; j < fillDebtOrderParam.latInfo[i].tokenIds.length; j = UntangledMath.uncheckedInc(j)) {\n                require(\n                    debtOrder.issuance.agreementIds[x] == bytes32(fillDebtOrderParam.latInfo[i].tokenIds[j]),\n                    'LoanKernel: Invalid LAT Token Id'\n                );\n\n                _issueDebtAgreements(\n                    fillDebtOrderParam.latInfo[i].tokenIds[j],\n                    fillDebtOrderParam.orderAddresses[uint8(FillingAddressesIndex.TERM_CONTRACT)],\n                    debtOrder.issuance.debtors[x],\n                    fillDebtOrderParam.termsContractParameters[x],\n                    debtOrder.principalTokenAddress,\n                    salts[x],\n                    debtOrder.expirationTimestampInSecs[x],\n                    _getAssetPurposeAndRiskScore(debtOrder.assetPurpose, debtOrder.riskScores[x])\n                );\n\n                require(\n                    ILoanInterestTermsContract(debtOrder.issuance.termsContract).registerTermStart(\n                        bytes32(fillDebtOrderParam.latInfo[i].tokenIds[j])\n                    ),\n                    'Cannot register term start'\n                );\n\n                emit LogDebtOrderFilled(\n                    debtOrder.issuance.agreementIds[x],\n                    debtOrder.principalAmounts[x],\n                    debtOrder.principalTokenAddress,\n                    debtOrder.relayer\n                );\n\n                x = UntangledMath.uncheckedInc(x);\n            }\n\n            expectedAssetsValue += ISecuritizationPool(poolAddress).collectAssets(\n                fillDebtOrderParam.latInfo[i].tokenIds\n            );\n        }\n\n        // Start collect asset checkpoint and withdraw\n        ISecuritizationTGE(poolAddress).withdraw(_msgSender(), expectedAssetsValue);\n    }\n\n    function _getDebtOrderHash(\n        bytes32 agreementId,\n        uint256 principalAmount,\n        address principalTokenAddress,\n        address relayer,\n        uint256 expirationTimestampInSec\n    ) private view returns (bytes32 _debtorMessageHash) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    address(this),\n                    agreementId,\n                    principalAmount,\n                    principalTokenAddress,\n                    relayer,\n                    expirationTimestampInSec\n                )\n            );\n    }\n\n    function _genLoanAgreementIds(\n        address _version,\n        address[] memory _debtors,\n        address _termsContract,\n        bytes32[] memory _termsContractParameters,\n        uint256[] memory _salts\n    ) private pure returns (bytes32[] memory) {\n        bytes32[] memory agreementIds = new bytes32[](_salts.length);\n        for (uint256 i = 0; i < (0 + _salts.length); i = UntangledMath.uncheckedInc(i)) {\n            agreementIds[i] = keccak256(\n                abi.encodePacked(_version, _debtors[i], _termsContract, _termsContractParameters[i], _salts[i])\n            );\n        }\n        return agreementIds;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/loan/LoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport {UntangledBase} from '../../base/UntangledBase.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {ILoanRegistry} from './ILoanRegistry.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\n\n/// @title LoanRegistry\n/// @author Untangled Team\n/// @dev Store LoanAssetToken information\ncontract LoanRegistry is UntangledBase, ILoanRegistry {\n    using ConfigHelper for Registry;\n\n    /** CONSTRUCTOR */\n    function initialize(Registry _registry) public override initializer {\n        __UntangledBase__init(_msgSender());\n        registry = _registry;\n    }\n\n    modifier onlyLoanKernel() {\n        require(_msgSender() == address(registry.getLoanKernel()), 'LoanRegistry: Only LoanKernel');\n        _;\n    }\n\n    modifier onlyLoanInterestTermsContract() {\n        require(\n            _msgSender() == address(registry.getLoanInterestTermsContract()),\n            'Invoice Debt Registry: Only LoanInterestTermsContract'\n        );\n        _;\n    }\n\n    /**\n     * Record new Loan to blockchain\n     */\n    /// @dev Records a new loan entry by inserting loan details into the entries mapping\n    function insert(\n        bytes32 tokenId,\n        address termContract,\n        address debtor,\n        bytes32 termsContractParameter,\n        address pTokenAddress,\n        uint256 _salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] calldata assetPurposeAndRiskScore\n    ) external override whenNotPaused onlyLoanKernel returns (bool) {\n        require(termContract != address(0x0), 'LoanRegistry: Invalid term contract');\n        LoanEntry memory newEntry = LoanEntry({\n            loanTermContract: termContract,\n            debtor: debtor,\n            principalTokenAddress: pTokenAddress,\n            termsParam: termsContractParameter,\n            salt: _salt, //solium-disable-next-line security\n            issuanceBlockTimestamp: block.timestamp,\n            lastRepayTimestamp: 0,\n            expirationTimestamp: expirationTimestampInSecs,\n            assetPurpose: Configuration.ASSET_PURPOSE(assetPurposeAndRiskScore[0]),\n            riskScore: assetPurposeAndRiskScore[1]\n        });\n        entries[tokenId] = newEntry;\n\n        emit UpdateLoanEntry(tokenId, newEntry);\n        return true;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getLoanDebtor(bytes32 tokenId) public view override returns (address) {\n        return entries[tokenId].debtor;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getLoanTermParams(bytes32 tokenId) public view override returns (bytes32) {\n        LoanEntry memory entry = entries[tokenId];\n        return entry.termsParam;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getPrincipalTokenAddress(bytes32 agreementId) public view override returns (address) {\n        return entries[agreementId].principalTokenAddress;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getDebtor(bytes32 agreementId) public view override returns (address) {\n        return entries[agreementId].debtor;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getTermContract(bytes32 agreementId) public view override returns (address) {\n        return entries[agreementId].loanTermContract;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getRiskScore(bytes32 agreementId) public view override returns (uint8) {\n        return entries[agreementId].riskScore;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getAssetPurpose(bytes32 agreementId) public view override returns (Configuration.ASSET_PURPOSE) {\n        return entries[agreementId].assetPurpose;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getEntry(bytes32 agreementId) public view override returns (LoanEntry memory) {\n        return entries[agreementId];\n    }\n\n    /**\n     * Returns the timestamp of the block at which a debt agreement was issued.\n     */\n    /// @inheritdoc ILoanRegistry\n    function getIssuanceBlockTimestamp(bytes32 agreementId) public view override returns (uint256 timestamp) {\n        return entries[agreementId].issuanceBlockTimestamp;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getLastRepaymentTimestamp(bytes32 agreementId) public view override returns (uint256 timestamp) {\n        return entries[agreementId].lastRepayTimestamp;\n    }\n\n    /**\n     * Returns the terms contract parameters of a given issuance\n     */\n    /// @inheritdoc ILoanRegistry\n    function getTermsContractParameters(bytes32 agreementId) public view override returns (bytes32) {\n        return entries[agreementId].termsParam;\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function getExpirationTimestamp(bytes32 agreementId) public view override returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        return entries[agreementId].expirationTimestamp;\n    }\n\n    // Update timestamp of the last repayment from Debtor\n    /// @inheritdoc ILoanRegistry\n    function updateLastRepaymentTimestamp(\n        bytes32 agreementId,\n        uint256 newTimestamp\n    ) public override onlyLoanInterestTermsContract {\n        entries[agreementId].lastRepayTimestamp = newTimestamp;\n        emit UpdateLoanEntry(agreementId, entries[agreementId]);\n    }\n\n    /// @dev Get principal payment info before start doing repayment\n    function principalPaymentInfo(\n        bytes32 agreementId\n    ) public view override returns (address pTokenAddress, uint256 pAmount) {\n        LoanEntry memory entry = entries[agreementId];\n        pTokenAddress = entry.principalTokenAddress;\n        pAmount = 0; // @TODO\n    }\n\n    /// @inheritdoc ILoanRegistry\n    function setCompletedLoan(bytes32 agreementId) public override whenNotPaused onlyLoanInterestTermsContract {\n        completedLoans[agreementId] = true;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/loan/LoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\nimport {ISecuritizationPool} from '../pool/ISecuritizationPool.sol';\nimport {ILoanInterestTermsContract} from '../../interfaces/ILoanInterestTermsContract.sol';\nimport {ILoanRegistry} from '../../interfaces/ILoanRegistry.sol';\n\nimport {ILoanRepaymentRouter} from './ILoanRepaymentRouter.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {ISecuritizationTGE} from '../pool/ISecuritizationTGE.sol';\nimport {IPoolNAV} from '../pool/IPoolNAV.sol';\nimport {ISecuritizationPoolStorage} from '../pool/ISecuritizationPoolStorage.sol';\n\n/// @title LoanRepaymentRouter\n/// @author Untangled Team\n/// @dev Repay for loan\ncontract LoanRepaymentRouter is ILoanRepaymentRouter {\n    using ConfigHelper for Registry;\n\n    function initialize(Registry _registry) public override initializer {\n        __UntangledBase__init(_msgSender());\n        registry = _registry;\n    }\n\n    /// @dev performs various checks to validate the repayment request, including ensuring that the token address is not null,\n    /// the amount is greater than zero, and the debt agreement exists\n    function _assertRepaymentRequest(bytes32 _agreementId, address _tokenAddress) private returns (bool) {\n        require(_tokenAddress != address(0), 'Token address must different with NULL.');\n\n        // Ensure agreement exists.\n        if (registry.getLoanAssetToken().ownerOf(uint256(_agreementId)) == address(0)) {\n            emit LogError(uint8(Errors.DEBT_AGREEMENT_NONEXISTENT), _agreementId);\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev executes the loan repayment by notifying the terms contract about the repayment,\n    /// transferring the repayment amount to the creditor, and handling additional logic related to securitization pools\n    /// and completed repayments\n    function _doRepay(\n        bytes32 _agreementId,\n        address _payer,\n        uint256 _amount,\n        address _tokenAddress\n    ) private returns (bool) {\n        // Notify terms contract\n\n        ILoanRegistry loanRegistry = registry.getLoanRegistry();\n        address termsContract = loanRegistry.getTermContract(_agreementId);\n        address beneficiary = registry.getLoanAssetToken().ownerOf(uint256(_agreementId));\n\n        ISecuritizationPoolStorage poolInstance = ISecuritizationPoolStorage(beneficiary);\n        IPoolNAV poolNAV = IPoolNAV(ISecuritizationPoolStorage(poolInstance).poolNAV());\n        uint256 repayAmount = poolNAV.repayLoan(uint256(_agreementId), _amount);\n        uint256 outstandingAmount = poolNAV.debt(uint256(_agreementId));\n        ISecuritizationTGE poolTGE = ISecuritizationTGE(beneficiary);\n\n        if (registry.getSecuritizationManager().isExistingPools(beneficiary)) beneficiary = poolInstance.pot();\n        require(\n            IERC20Upgradeable(_tokenAddress).transferFrom(_payer, beneficiary, repayAmount),\n            'Unsuccessfully transferred repayment amount to Creditor.'\n        );\n        poolTGE.increaseTotalAssetRepaidCurrency(repayAmount);\n\n        if (outstandingAmount == 0) {\n            // Burn LAT token when repay completely\n            registry.getLoanKernel().concludeLoan(beneficiary, _agreementId, termsContract);\n        }\n\n        // Log event for repayment\n        emit LogRepayment(_agreementId, _payer, beneficiary, _amount, _tokenAddress);\n        return true;\n    }\n\n    /// @inheritdoc ILoanRepaymentRouter\n    function repayInBatch(\n        bytes32[] calldata agreementIds,\n        uint256[] calldata amounts,\n        address tokenAddress\n    ) external override whenNotPaused nonReentrant returns (bool) {\n        uint256 agreementIdsLength = agreementIds.length;\n        for (uint256 i = 0; i < agreementIdsLength; i++) {\n            require(\n                _assertRepaymentRequest(agreementIds[i], tokenAddress),\n                'LoanRepaymentRouter: Invalid repayment request'\n            );\n            require(\n                _doRepay(agreementIds[i], _msgSender(), amounts[i], tokenAddress),\n                'LoanRepaymentRouter: Repayment has failed'\n            );\n        }\n        emit LogRepayments(agreementIds, _msgSender(), amounts);\n        return true;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/loan/LoanTyping.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ncontract LoanTyping {\n\n    enum LoanTypes {\n        WAREHOUSE_RECEIPT,\n        INPUT_FINANCE,\n        INVOICE_FINANCE,\n        INVENTORY_FINANCE\n    }\n}"
    },
    "contracts/protocol/note-sale/base/LongSaleInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../libraries/UntangledMath.sol';\n\n/// @title LongSaleInterest\n/// @author Untangled Team\n/// @dev Define some constant for interest calculation\ncontract LongSaleInterest {\n    /// @dev represents the number of days in a year\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    /// @dev represents the number of seconds in a minute\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    /// @dev represents the number of seconds in an hour\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    /// @dev represents the number of seconds in a day\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    /// @dev represents the number of seconds in a year\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    /// @dev A constant used to convert an encoded interest rate into its equivalent in percentage.\n    /// To convert an encoded interest rate to a percentage, divide it by this scaling factor\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n    /// @dev represents the scaling factor for the purchase price calculation\n    uint256 public constant PURCHASE_PRICE_SCALING_FACTOR = 10**4;\n\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/Crowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\n\nimport '../../../base/UntangledBase.sol';\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '../../pool/ISecuritizationPool.sol';\nimport {ISecuritizationTGE} from '../../pool/ISecuritizationTGE.sol';\n\nimport {ConfigHelper} from '../../../libraries/ConfigHelper.sol';\nimport '../../../interfaces/INoteToken.sol';\nimport '../../../interfaces/ICrowdSale.sol';\nimport {ISecuritizationPoolStorage} from '../../pool/ISecuritizationPoolStorage.sol';\n\nabstract contract Crowdsale is UntangledBase, ICrowdSale {\n    using ConfigHelper for Registry;\n\n    event UpdateTotalCap(uint256 totalCap);\n    event UpdateMinBidAmount(uint256 minBidAmount);\n\n    Registry public registry;\n\n    // decimal calculating for rate\n    uint256 public constant RATE_SCALING_FACTOR = 10 ** 4;\n\n    /// @dev Pool address which this sale belongs to\n    address public override pool;\n\n    /// @dev The token being sold\n    address public override token;\n\n    /// @dev The token being sold\n    address public currency;\n\n    // How many token units a buyer gets per currency.\n    uint256 public rate; // support by RATE_SCALING_FACTOR decimal numbers\n    bool public hasStarted;\n    uint64 public firstNoteTokenMintedTimestamp; // Timestamp at which the first asset is collected to pool\n\n    /// @dev Amount of currency raised\n    uint256 internal _currencyRaised;\n\n    /// @dev Amount of token raised\n    uint256 public tokenRaised;\n\n    /// @dev Target raised currency amount\n    uint256 public totalCap;\n\n    /// @dev Minimum currency bid amount for note token\n    uint256 public minBidAmount;\n\n    mapping(address => uint256) public _currencyRaisedByInvestor;\n\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    function __Crowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __UntangledBase__init_unchained(_msgSender());\n        registry = _registry;\n        pool = _pool;\n        token = _token;\n        currency = _currency;\n    }\n\n    modifier securitizationPoolRestricted() {\n        require(_msgSender() == pool, 'Crowdsale: Caller must be pool');\n        _;\n    }\n\n    modifier smpRestricted() {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: Caller must be securitization manager'\n        );\n        _;\n    }\n\n    function currencyRaisedByInvestor(address investor) public view returns (uint256) {\n        return _currencyRaisedByInvestor[investor];\n    }\n\n    /// @notice add funding amount to be added to the total cap\n    function addFunding(uint256 additionalCap) public nonReentrant whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: caller must be owner or pool'\n        );\n        require(additionalCap > 0, 'Crowdsale: total cap is 0');\n\n        totalCap = additionalCap + totalCap;\n\n        emit UpdateTotalCap(totalCap);\n    }\n\n    /// @notice Setup minimum bid amount in currency for note token\n    /// @param _minBidAmount Expected minimum amount\n    function setMinBidAmount(uint256 _minBidAmount) external whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or pool'\n        );\n        minBidAmount = _minBidAmount;\n        emit UpdateMinBidAmount(_minBidAmount);\n    }\n\n    /// @notice Set hasStarted variable\n    function setHasStarted(bool _hasStarted) public {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: caller must be owner or manager'\n        );\n        hasStarted = _hasStarted;\n\n        emit SetHasStarted(hasStarted);\n    }\n\n    /// @notice Sets the rate variable to the new rate\n    function _newSaleRound(uint256 newRate) internal {\n        require(!hasStarted, 'Crowdsale: Sale round overflow');\n\n        rate = newRate;\n    }\n\n    /// @notice  Allows users to buy note token\n    /// @param payee pay for purchase\n    /// @param beneficiary wallet receives note token\n    /// @param currencyAmount amount of currency used for purchase\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public virtual whenNotPaused nonReentrant smpRestricted returns (uint256) {\n        require(currencyAmount >= minBidAmount, 'Crowdsale: Less than minBidAmount');\n        uint256 tokenAmount = getTokenAmount(currencyAmount);\n\n        _preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n\n        // update state\n        _currencyRaised += currencyAmount;\n        _currencyRaisedByInvestor[beneficiary] += currencyAmount;\n\n        ISecuritizationTGE securitizationPool = ISecuritizationTGE(pool);\n        require(securitizationPool.isDebtCeilingValid(), 'Crowdsale: Exceeds Debt Ceiling');\n        tokenRaised += tokenAmount;\n\n        _claimPayment(payee, currencyAmount);\n        _processPurchase(beneficiary, tokenAmount);\n        emit TokensPurchased(_msgSender(), beneficiary, currencyAmount, tokenAmount);\n\n        _forwardFunds(ISecuritizationPoolStorage(pool).pot(), currencyAmount);\n\n        return tokenAmount;\n    }\n\n    /// @notice Check if the total amount of currency raised is equal to the total cap\n    function isDistributedFully() public view returns (bool) {\n        return _currencyRaised == totalCap;\n    }\n\n    /// @notice Catch event redeem token\n    /// @param currencyAmount amount of currency investor want to redeem\n    function onRedeem(uint256 currencyAmount) public virtual override {\n        require(\n            _msgSender() == address(registry.getDistributionOperator()),\n            'Crowdsale: Caller must be distribution operator'\n        );\n        _currencyRaised -= currencyAmount;\n    }\n\n    /// @notice Retrieves the remaining token balance held by the crowdsale contract\n    function getTokenRemainAmount() public view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    /// @notice Calculates the remaining amount of currency available for purchase\n    function getCurrencyRemainAmount() public view virtual returns (uint256) {\n        return totalCap - _currencyRaised;\n    }\n\n    /// @notice Determines whether the current sale round is a long sale\n    /// @dev This is an abstract function that needs to be implemented in derived contracts\n    function isLongSale() public view virtual returns (bool);\n\n    /// @notice Calculates the corresponding token amount based on the currency amount and the current rate\n    /// @dev This is an abstract function that needs to be implemented in derived contracts\n    function getTokenAmount(uint256 currencyAmount) public view virtual returns (uint256);\n\n    /// @notice Requires that the currency amount does not exceed the total cap\n    function _defaultPreValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view {\n        require(beneficiary != address(0), 'Crowdsale: beneficiary is zero address');\n        //        require(currencyAmount != 0, \"currency amount is 0\");\n        require(tokenAmount != 0, 'Crowdsale: token amount is 0');\n        require(hasStarted, 'Crowdsale: sale not started');\n        require(isUnderTotalCap(currencyAmount), 'Crowdsale: cap exceeded');\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view virtual {\n        _defaultPreValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n    }\n\n    /// @dev Mints and delivers tokens to the beneficiary\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\n        INoteToken noteToken = INoteToken(token);\n        if (noteToken.noteTokenType() == uint8(Configuration.NOTE_TOKEN_TYPE.SENIOR) && noteToken.totalSupply() == 0) {\n            firstNoteTokenMintedTimestamp = uint64(block.timestamp);\n            ISecuritizationPool(pool).setUpOpeningBlockTimestamp();\n        }\n        noteToken.mint(beneficiary, tokenAmount);\n    }\n\n    /// @dev Burns and delivers tokens to the beneficiary\n    function _ejectTokens(uint256 tokenAmount) internal {\n        INoteToken(token).burn(tokenAmount);\n    }\n\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\n        _deliverTokens(beneficiary, tokenAmount);\n    }\n\n    /// @dev Transfers the currency from the payer to the crowdsale contract\n    function _claimPayment(address payee, uint256 currencyAmount) internal {\n        require(\n            IERC20(currency).transferFrom(payee, address(this), currencyAmount),\n            'Fail to transfer currency from payee to contract'\n        );\n    }\n\n    // function getTokenAmount(uint256 currencyAmount) public view returns (uint256) {\n    //     require(rate > 0, 'Crowdsale: rate is 0');\n    //     uint256 TEN = 10;\n    //     return\n    //         (currencyAmount * rate * TEN**ERC20(token).decimals()) /\n    //         (RATE_SCALING_FACTOR * TEN**ERC20(currency).decimals());\n    // }\n\n    /// @dev Transfers the currency funds from the crowdsale contract to the specified beneficiary\n    function _forwardFunds(address beneficiary, uint256 currencyAmount) internal {\n        require(IERC20(currency).transfer(beneficiary, currencyAmount), 'Fail to transfer currency to Beneficiary');\n    }\n\n    /// @dev Sets the total cap to the specified amount\n    function _setTotalCap(uint256 cap) internal {\n        require(cap > 0, 'Crowdsale: cap is 0');\n        require(cap >= _currencyRaised, 'Crowdsale: cap is bellow currency raised');\n\n        totalCap = cap;\n\n        emit UpdateTotalCap(totalCap);\n    }\n\n    /// @notice Checks if the total amount of currency raised is greater than or equal to the total cap\n    function totalCapReached() public view returns (bool) {\n        return _currencyRaised >= totalCap;\n    }\n\n    /// @notice Checks if the sum of the current currency raised and the specified currency amount is less than or equal to the total cap\n    function isUnderTotalCap(uint256 currencyAmount) public view returns (bool) {\n        return _currencyRaised + currencyAmount <= totalCap;\n    }\n\n    function currencyRaised() public view virtual override returns (uint256) {\n        return _currencyRaised;\n    }\n\n    uint256[40] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/FinalizableCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './IFinalizableCrowdsale.sol';\nimport './TimedCrowdsale.sol';\n\n/// @title FinalizableCrowdsale\n/// @author Untangled Team\n/// @dev An abstract contract define finalize function for sale\nabstract contract FinalizableCrowdsale is IFinalizableCrowdsale, TimedCrowdsale {\n    bool internal _finalized;\n\n    function finalized() public view virtual override returns (bool) {\n        return _finalized;\n    }\n\n    /// @dev Validates that the crowdsale has not already been finalized and that it has either closed or reached the total cap\n    /// @param claimRemainToken claim remaining token or not\n    /// @param remainTokenRecipient Wallet will receive remaining token\n    function finalize(bool claimRemainToken, address remainTokenRecipient) public whenNotPaused {\n        require(_msgSender() == pool, 'FinalizableCrowdsale: Only pool contract can finalize');\n        require(!finalized(), 'FinalizableCrowdsale: already finalized');\n        require(hasClosed() || totalCapReached(), 'FinalizableCrowdsale: not closed');\n        _finalized = true;\n\n        if (!isDistributedFully() && !isLongSale()) {\n            uint256 tokenRemain = 0;\n            tokenRemain = getTokenAmount(getCurrencyRemainAmount());\n\n            if (claimRemainToken) {\n                _processPurchase(remainTokenRecipient, tokenRemain);\n            } else {\n                _ejectTokens(tokenRemain);\n            }\n        }\n\n        _finalization();\n        emit CrowdsaleFinalized();\n    }\n\n    /// @dev This function is meant to be overridden in derived contracts to implement specific finalization logic\n    function _finalization() internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/ICrowdSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ICrowdSale {\n    event SetHasStarted(bool hasStarted);\n\n    function pool() external view returns (address);\n\n    function token() external view returns (address);\n\n    function currencyRaisedByInvestor(address investor) external view returns (uint256);\n\n    function currencyRaised() external view returns (uint256);\n\n    function firstNoteTokenMintedTimestamp() external view returns (uint64);\n\n    function buyTokens(address payee, address beneficiary, uint256 currencyAmount) external returns (uint256);\n\n    function onRedeem(uint256 currencyAmount) external;\n\n    function setHasStarted(bool _hasStarted) external;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/IFinalizableCrowdsale.sol": {
      "content": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IFinalizableCrowdsale {\n    event CrowdsaleFinalized();\n\n    function finalized() external view returns (bool);\n\n    function finalize(bool claimRemainToken, address remainTokenRecipient) external;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/IncreasingInterestCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './FinalizableCrowdsale.sol';\nimport '../IInterestRate.sol';\n\n/// @title IncreasingInterestCrowdsale\n/// @author Untangled Team\nabstract contract IncreasingInterestCrowdsale is IInterestRate, FinalizableCrowdsale {\n    using ConfigHelper for Registry;\n\n    event UpdateInterestRange(uint32 initialInterest, uint32 finalInterest, uint32 timeInterval, uint32 amountChangeEachInterval);\n\n    uint32 public initialInterest;\n    uint32 public finalInterest;\n    uint32 public timeInterval;\n    uint32 public amountChangeEachInterval;\n    uint32 public override pickedInterest;\n\n    function setInterestRange(\n        uint32 _initialInterest,\n        uint32 _finalInterest,\n        uint32 _timeInterval,\n        uint32 _amountChangeEachInterval\n    ) public whenNotPaused {\n        require(hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()), \"IncreasingInterestCrowdsale: Caller must be owner or pool\");\n        require(!hasStarted, 'IncreasingInterestCrowdsale: sale already started');\n        require(\n            _initialInterest <= _finalInterest,\n            'IncreasingInterestCrowdsale: initial interest is not less than final interest'\n        );\n        require(_timeInterval > 0, 'IncreasingInterestCrowdsale: time interval is 0');\n\n        initialInterest = _initialInterest;\n        finalInterest = _finalInterest;\n        timeInterval = _timeInterval;\n        amountChangeEachInterval = _amountChangeEachInterval;\n\n        emit UpdateInterestRange(\n            initialInterest,\n            finalInterest,\n            timeInterval,\n            amountChangeEachInterval\n        );\n    }\n\n    function getCurrentInterest() public view returns (uint32) {\n        if (block.timestamp < openingTime) {\n            return 0;\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint256 elapsedTime = block.timestamp - openingTime;\n        // uint256 numberInterval = elapsedTime / timeInterval;\n        // uint32 currentInterest = uint32(amountChangeEachInterval * numberInterval + initialInterest);\n        uint32 currentInterest = uint32((amountChangeEachInterval * elapsedTime) / timeInterval + initialInterest);\n\n        if (currentInterest > finalInterest) {\n            return finalInterest;\n        } else {\n            return currentInterest;\n        }\n    }\n\n    /// @dev Override _finalization function. In Auction note sale, interest of token determined when the auction ends\n    function _finalization() internal override {\n        super._finalization();\n\n        pickedInterest = getCurrentInterest();\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view override {\n        super._preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n        require(timeInterval > 0, 'IncreasingInterestCrowdsale: time interval not set');\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/mock/FinalizableCrowdsaleMock.sol": {
      "content": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport { Registry } from '../../../../storage/Registry.sol';\nimport { FinalizableCrowdsale } from '../FinalizableCrowdsale.sol';\n\ncontract FinalizableCrowdsaleMock is FinalizableCrowdsale {\n    function isLongSale() public view virtual override returns (bool) {}\n    function getTokenAmount(uint256 currencyAmount) public view virtual override returns (uint256) {}\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) public initializer {\n        __TimedCrowdsale__init(\n            _registry,\n            _pool,\n            _token,\n            _currency\n        );\n    }\n}"
    },
    "contracts/protocol/note-sale/crowdsale/mock/TimedCrowdsaleMock.sol": {
      "content": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport { Registry } from '../../../../storage/Registry.sol';\nimport { TimedCrowdsale } from '../TimedCrowdsale.sol';\n\ncontract TimedCrowdsaleMock is TimedCrowdsale {\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) public initializer {\n        __TimedCrowdsale__init(\n            _registry,\n            _pool,\n            _token,\n            _currency\n        );\n    }\n\n    function checkOnlyWhileOpen() public onlyWhileOpen {\n        \n    }\n\n    function getTokenAmount(uint256 currencyAmount) public view override virtual returns (uint256) {\n        return 0; // ignore\n    }\n\n    function isLongSale() public view override virtual returns (bool) {\n        return false; // ignore\n    }\n}"
    },
    "contracts/protocol/note-sale/crowdsale/TimedCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './Crowdsale.sol';\n\n/// @title TimedCrowdsale\n/// @author Untangled Team\n/// @dev Note sale that has open time and close time\nabstract contract TimedCrowdsale is Crowdsale {\n    using ConfigHelper for Registry;\n    uint256 public openingTime;\n    uint256 public closingTime;\n\n    bool public isEnableTimeLimit;\n\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\n    event UpdateUsingTimeLimit(bool isEnableTimeLimit);\n    event UpdateSaleRoundTime(uint256 newOpeningTime, uint256 newClosingTime);\n\n    function __TimedCrowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        isEnableTimeLimit = true;\n    }\n\n    modifier onlyWhileOpen() {\n        require(isOpen() || isLongSale(), 'TimedCrowdsale: not open');\n        _;\n    }\n\n    function isOpen() public view returns (bool) {\n        if (!isEnableTimeLimit) {\n            return true;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp >= openingTime && block.timestamp <= closingTime;\n    }\n\n    function hasClosed() public view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > closingTime;\n    }\n\n    /// @notice Updates the closing time with the new closing time\n    function extendTime(uint256 newClosingTime) external whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        require(newClosingTime > closingTime, 'TimedCrowdsale: new closing time is before current closing time');\n\n        emit TimedCrowdsaleExtended(closingTime, newClosingTime);\n        closingTime = newClosingTime;\n    }\n\n    /// @notice Updates the opening time and closing time accordingly\n    function newSaleRoundTime(uint256 newOpeningTime, uint256 newClosingTime) public whenNotPaused {\n        require(hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()), \"Crowdsale: Caller must be owner or pool\");\n        require(newClosingTime >= newOpeningTime, 'TimedCrowdsale: opening time is not before closing time');\n        // not accept opening time in the past\n        if (newOpeningTime < block.timestamp) {\n            newOpeningTime = block.timestamp;\n        }\n\n        if (newClosingTime <= newOpeningTime) {\n            newClosingTime = newOpeningTime + 1;\n        }\n\n        openingTime = newOpeningTime;\n        closingTime = newClosingTime;\n\n        emit UpdateSaleRoundTime(newOpeningTime, newClosingTime);\n    }\n\n    /// @dev Sets the isEnableTimeLimit variable to the specified value\n    function setUsingTimeLimit(bool usingTimeLimit) public whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        isEnableTimeLimit = usingTimeLimit;\n        emit UpdateUsingTimeLimit(usingTimeLimit);\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/fab/INoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../storage/Registry.sol';\nimport '../../../interfaces/INoteToken.sol';\n\ninterface INoteTokenFactory {\n    event TokenCreated(\n        address indexed token,\n        address indexed poolAddress,\n        Configuration.NOTE_TOKEN_TYPE indexed tokenType,\n        uint8 decimals,\n        string ticker\n    );\n\n    event UpdateNoteTokenImplementation(address indexed newAddress);\n\n    function tokens(uint256 idx) external view returns (INoteToken);\n\n    function isExistingTokens(address tokenAddress) external view returns (bool);\n\n    function changeMinterRole(address token, address newController) external;\n\n    function setNoteTokenImplementation(address newAddress) external;\n\n    function noteTokenImplementation() external view returns (address);\n\n    /// @notice Creates a new NoteToken contract instance with the specified parameters\n    /// Initializes the token with the provided parameters, including the pool address and note token type\n    function createToken(\n        address poolAddress,\n        Configuration.NOTE_TOKEN_TYPE noteTokenType,\n        uint8 _nDecimals,\n        string calldata ticker\n    ) external returns (address);\n}\n"
    },
    "contracts/protocol/note-sale/fab/ITokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../storage/Registry.sol';\nimport '../../../interfaces/INoteToken.sol';\n\nabstract contract ITokenGenerationEventFactory {\n    enum SaleType {\n        MINTED_INCREASING_INTEREST_SOT,\n        NORMAL_SALE_JOT,\n        NORMAL_SALE_SOT\n    }\n\n    event UpdateTGEImplAddress(SaleType indexed tgeType, address newImpl);\n    event TokenGenerationEventCreated(address indexed tgeInstance);\n\n    Registry public registry;\n    address[] public tgeAddresses;\n    mapping(address => bool) public isExistingTge;\n    mapping(SaleType => address) public TGEImplAddress;\n\n    /// @notice creates a new TGE instance based on the provided parameters and the sale type\n    function createNewSaleInstance(\n        address issuerTokenController,\n        // address pool,\n        address token,\n        address currency,\n        uint8 saleType,\n        bool longSale\n    ) external virtual returns (address);\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/fab/NoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IPauseable} from '../../../base/IPauseable.sol';\nimport '../../../base/UntangledBase.sol';\nimport '../../../base/Factory.sol';\nimport '../../../interfaces/INoteTokenFactory.sol';\nimport '../../../libraries/ConfigHelper.sol';\nimport '../../../libraries/UntangledMath.sol';\nimport {MINTER_ROLE} from '../../../tokens/ERC20/types.sol';\n\ncontract NoteTokenFactory is UntangledBase, Factory, INoteTokenFactory {\n    using ConfigHelper for Registry;\n\n    bytes4 constant TOKEN_INIT_FUNC_SELECTOR = bytes4(keccak256('initialize(string,string,uint8,address,uint8)'));\n\n    Registry public registry;\n\n    INoteToken[] public override tokens;\n\n    mapping(address => bool) public override isExistingTokens;\n\n    address public override noteTokenImplementation;\n\n    modifier onlySecuritizationManager() {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()),\n            'SecuritizationPool: Only SecuritizationManager'\n        );\n        _;\n    }\n\n    function initialize(Registry _registry, address _factoryAdmin) public reinitializer(3) {\n        __UntangledBase__init(_msgSender());\n        __Factory__init(_factoryAdmin);\n\n        registry = _registry;\n    }\n\n    function setFactoryAdmin(address _factoryAdmin) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setFactoryAdmin(_factoryAdmin);\n    }\n\n    function changeMinterRole(address tokenAddress, address newController) external override onlySecuritizationManager {\n        IAccessControlUpgradeable token = IAccessControlUpgradeable(tokenAddress);\n        token.grantRole(MINTER_ROLE, newController);\n    }\n\n    function setNoteTokenImplementation(address newAddress) external onlyAdmin {\n        require(newAddress != address(0), 'NoteTokenFactory: new address cannot be zero');\n        noteTokenImplementation = newAddress;\n        emit UpdateNoteTokenImplementation(newAddress);\n    }\n\n    function createToken(\n        address _poolAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteTokenType,\n        uint8 _nDecimals,\n        string calldata ticker\n    ) external override whenNotPaused nonReentrant onlySecuritizationManager returns (address) {\n        string memory name;\n        string memory symbol;\n        if (_noteTokenType == Configuration.NOTE_TOKEN_TYPE.SENIOR) {\n            name = 'Senior Obligation Token';\n            symbol = string.concat(ticker, '_SOT');\n        } else {\n            name = 'Junior Obligation Token';\n            symbol = string.concat(ticker, '_JOT');\n        }\n\n        bytes memory _initialData = abi.encodeWithSelector(\n            TOKEN_INIT_FUNC_SELECTOR,\n            name,\n            symbol,\n            _nDecimals,\n            _poolAddress,\n            uint8(_noteTokenType)\n        );\n\n        address ntAddress = _deployInstance(noteTokenImplementation, _initialData);\n\n        INoteToken token = INoteToken(ntAddress);\n\n        tokens.push(token);\n        isExistingTokens[address(token)] = true;\n\n        emit TokenCreated(address(token), _poolAddress, _noteTokenType, _nDecimals, ticker);\n\n        return address(token);\n    }\n\n    function pauseUnpauseToken(address tokenAddress) external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(isExistingTokens[tokenAddress], 'NoteTokenFactory: token does not exist');\n        IPauseable token = IPauseable(tokenAddress);\n        if (token.paused()) {\n            token.unpause();\n        } else {\n            token.pause();\n        }\n    }\n\n    function pauseAllTokens() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 tokensLength = tokens.length;\n        for (uint256 i = 0; i < tokensLength; i = UntangledMath.uncheckedInc(i)) {\n            if (!tokens[i].paused()) tokens[i].pause();\n        }\n    }\n\n    function unPauseAllTokens() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 tokensLength = tokens.length;\n        for (uint256 i = 0; i < tokensLength; i = UntangledMath.uncheckedInc(i)) {\n            if (tokens[i].paused()) tokens[i].unpause();\n        }\n    }\n\n    uint256[46] private __gap0;\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/fab/TokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {UntangledBase} from '../../../base/UntangledBase.sol';\nimport {ITokenGenerationEventFactory} from './ITokenGenerationEventFactory.sol';\nimport {ConfigHelper} from '../../../libraries/ConfigHelper.sol';\nimport {Factory} from '../../../base/Factory.sol';\nimport {Registry} from '../../../storage/Registry.sol';\nimport {UntangledMath} from '../../../libraries/UntangledMath.sol';\nimport {MintedIncreasingInterestTGE} from '../MintedIncreasingInterestTGE.sol';\nimport {MintedNormalTGE} from '../MintedNormalTGE.sol';\nimport {Registry} from '../../../storage/Registry.sol';\n\ninterface INoteTokenLike {\n    function poolAddress() external view returns (address);\n}\n\ncontract TokenGenerationEventFactory is ITokenGenerationEventFactory, UntangledBase, Factory {\n    using ConfigHelper for Registry;\n\n    bytes4 constant TGE_INIT_FUNC_SELECTOR = bytes4(keccak256('initialize(address,address,address,address,bool)'));\n\n    function __TokenGenerationEventFactory_init(Registry _registry, address _factoryAdmin) internal onlyInitializing {\n        __UntangledBase__init(_msgSender());\n        __Factory__init(_factoryAdmin);\n\n        registry = _registry;\n    }\n\n    function initialize(Registry _registry, address _factoryAdmin) public initializer {\n        __TokenGenerationEventFactory_init(_registry, _factoryAdmin);\n    }\n\n    function initializeV2(Registry _registry, address _factoryAdmin) public reinitializer(2) {\n        __TokenGenerationEventFactory_init(_registry, _factoryAdmin);\n    }\n\n    function setFactoryAdmin(address _factoryAdmin) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setFactoryAdmin(_factoryAdmin);\n    }\n\n    function setTGEImplAddress(SaleType tgeType, address newImpl) public {\n        require(\n            isAdmin() || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\n            'UntangledBase: Must have admin role to perform this action'\n        );\n        require(newImpl != address(0), 'TokenGenerationEventFactory: TGEImplAddress cannot be zero');\n        TGEImplAddress[tgeType] = newImpl;\n        emit UpdateTGEImplAddress(tgeType, newImpl);\n    }\n\n    function createNewSaleInstance(\n        address issuerTokenController,\n        // address pool,\n        address token,\n        address currency,\n        uint8 saleType,\n        bool longSale\n    ) external override whenNotPaused nonReentrant returns (address) {\n        registry.requireSecuritizationManager(_msgSender());\n\n        address pool = INoteTokenLike(token).poolAddress();\n\n        if (saleType == uint8(SaleType.MINTED_INCREASING_INTEREST_SOT)) {\n            return\n                _newSale(\n                    TGEImplAddress[SaleType.MINTED_INCREASING_INTEREST_SOT],\n                    issuerTokenController,\n                    pool,\n                    token,\n                    currency,\n                    longSale\n                );\n        }\n\n        if (saleType == uint8(SaleType.NORMAL_SALE_JOT)) {\n            return\n                _newSale(\n                    TGEImplAddress[SaleType.NORMAL_SALE_JOT],\n                    issuerTokenController,\n                    pool,\n                    token,\n                    currency,\n                    longSale\n                );\n        }\n\n        if (saleType == uint8(SaleType.NORMAL_SALE_SOT)) {\n            return\n                _newSale(\n                    TGEImplAddress[SaleType.NORMAL_SALE_SOT],\n                    issuerTokenController,\n                    pool,\n                    token,\n                    currency,\n                    longSale\n                );\n        }\n\n        revert('Unknown sale type');\n    }\n\n    function _newSale(\n        address tgeImpl,\n        address issuerTokenController,\n        address pool,\n        address token,\n        address currency,\n        bool longSale\n    ) private returns (address) {\n        bytes memory _initialData = abi.encodeWithSelector(\n            TGE_INIT_FUNC_SELECTOR,\n            registry,\n            pool,\n            token,\n            currency,\n            longSale\n        );\n\n        address tgeAddress = _deployInstance(tgeImpl, _initialData);\n        UntangledBase tge = UntangledBase(tgeAddress);\n\n        tge.grantRole(tge.OWNER_ROLE(), issuerTokenController);\n        tge.renounceRole(tge.OWNER_ROLE(), address(this));\n\n        tgeAddresses.push(tgeAddress);\n        isExistingTge[tgeAddress] = true;\n\n        emit TokenGenerationEventCreated(tgeAddress);\n\n        return tgeAddress;\n    }\n\n    // function _newMintedIncreasingInterestSale(\n    //     address issuerTokenController,\n    //     address pool,\n    //     address token,\n    //     address currency,\n    //     bool longSale\n    // ) private returns (address) {\n    //     address mintedIncreasingInterestTGEImplAddress = address(registry.getMintedIncreasingInterestTGE());\n\n    //     bytes memory _initialData = abi.encodeWithSelector(\n    //         TGE_INIT_FUNC_SELECTOR,\n    //         registry,\n    //         pool,\n    //         token,\n    //         currency,\n    //         longSale\n    //     );\n\n    //     address tgeAddress = _deployInstance(mintedIncreasingInterestTGEImplAddress, _initialData);\n    //     MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAddress);\n\n    //     tge.grantRole(tge.OWNER_ROLE(), issuerTokenController);\n    //     tge.renounceRole(tge.OWNER_ROLE(), address(this));\n\n    //     tgeAddresses.push(tgeAddress);\n    //     isExistingTge[tgeAddress] = true;\n\n    //     emit TokenGenerationEventCreated(tgeAddress);\n\n    //     return tgeAddress;\n    // }\n\n    // function _newNormalSale(\n    //     address issuerTokenController,\n    //     address pool,\n    //     address token,\n    //     address currency,\n    //     bool longSale\n    // ) private returns (address) {\n    //     address mintedNormalTGEImplAddress = address(registry.getMintedNormalTGE());\n\n    //     bytes memory _initialData = abi.encodeWithSelector(\n    //         TGE_INIT_FUNC_SELECTOR,\n    //         registry,\n    //         pool,\n    //         token,\n    //         currency,\n    //         longSale\n    //     );\n\n    //     address tgeAddress = _deployInstance(mintedNormalTGEImplAddress, _initialData);\n    //     MintedNormalTGE tge = MintedNormalTGE(tgeAddress);\n\n    //     tge.grantRole(tge.OWNER_ROLE(), issuerTokenController);\n    //     tge.renounceRole(tge.OWNER_ROLE(), address(this));\n\n    //     tgeAddresses.push(tgeAddress);\n    //     isExistingTge[tgeAddress] = true;\n\n    //     emit TokenGenerationEventCreated(tgeAddress);\n\n    //     return tgeAddress;\n    // }\n\n    function pauseUnpauseTge(address tgeAdress) external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(isExistingTge[tgeAdress], 'TokenGenerationEventFactory: tge does not exist');\n        MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAdress);\n        if (tge.paused()) {\n            tge.unpause();\n        } else {\n            tge.pause();\n        }\n    }\n\n    function pauseUnpauseAllTges() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 tgeAddressesLength = tgeAddresses.length;\n        for (uint256 i = 0; i < tgeAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAddresses[i]);\n            if (tge.paused()) {\n                tge.unpause();\n            } else {\n                tge.pause();\n            }\n        }\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/IInterestRate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IInterestRate {\n    function pickedInterest() external view returns (uint32);\n}\n"
    },
    "contracts/protocol/note-sale/IMintedTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport {IInterestRate} from './IInterestRate.sol';\n\ninterface IMintedTGE is IInterestRate {\n    event YieldUpdated(uint256 newYield);\n    event SetupLongSale(uint256 interestRate, uint256 termLengthInSeconds, uint256 timeStartEarningInterest);\n    event UpdateInitialAmount(uint256 initialAmount);\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _isLongSale\n    ) external;\n\n    /// @notice initialize long sale settings\n    function setupLongSale(\n        uint256 interestRate,\n        uint256 termLengthInSeconds,\n        uint256 timeStartEarningInterest\n    ) external;\n\n    ///@notice investor bids for SOT/JOT token. Paid by pool's currency\n    function buyTokens(address payee, address beneficiary, uint256 currencyAmount) external returns (uint256);\n\n    function startNewRoundSale(uint256 openingTime_, uint256 closingTime_, uint256 rate_, uint256 cap_) external;\n}\n"
    },
    "contracts/protocol/note-sale/MintedIncreasingInterestTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../base/UntangledBase.sol';\nimport './crowdsale/IncreasingInterestCrowdsale.sol';\nimport './IMintedTGE.sol';\nimport './base/LongSaleInterest.sol';\nimport './IInterestRate.sol';\n\n/// @title MintedIncreasingInterestTGE\n/// @author Untangled Team\n/// @dev Note sale for SOT - auction\ncontract MintedIncreasingInterestTGE is IMintedTGE, UntangledBase, IncreasingInterestCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n    }\n\n    /// @inheritdoc Crowdsale\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    /// @dev Sets the yield variable to the specified value\n    function setYield(uint256 _yield) public whenNotPaused onlyRole(OWNER_ROLE) {\n        yield = _yield;\n        emit YieldUpdated(_yield);\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n\n            emit SetupLongSale(interestRate, termLengthInSeconds, timeStartEarningInterest);\n            emit YieldUpdated(yield);\n        }\n    }\n\n    /// @notice Calculate token price\n    /// @dev This sale is for SOT. So the function return SOT token price\n    function getTokenPrice() public view returns (uint256) {\n        return registry.getDistributionAssessor().getSOTTokenPrice(pool);\n    }\n\n    /// @notice Get amount of token can receive from an amount of currency\n    function getTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return currencyAmount / getTokenPrice();\n    }\n\n    /// @notice Setup a new round sale for note token\n    /// @param openingTime_ Define when the sale should start\n    /// @param closingTime_ Define when the sale should end\n    /// @param cap_ Target amount of raised currency\n    function startNewRoundSale(\n        uint256 openingTime_,\n        uint256 closingTime_,\n        uint256 rate_,\n        uint256 cap_\n    ) external whenNotPaused override {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedIncreasingInterestTGE: Caller must be owner or pool'\n        );\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate_);\n        newSaleRoundTime(openingTime_, closingTime_);\n        _setTotalCap(cap_);\n    }\n\n    /// @dev Validates that the previous sale round is closed and the time interval for increasing interest is greater than zero\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n        require(timeInterval > 0, 'MintedIncreasingInterestTGE: Time interval increasing interest is 0');\n    }\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public override(IMintedTGE, Crowdsale) returns (uint256 tokenAmount) {\n        tokenAmount = Crowdsale.buyTokens(payee, beneficiary, currencyAmount);\n        if (_currencyRaised >= totalCap) {\n            if (!this.finalized()) {\n                this.finalize(false, pool);\n            }\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/MintedNormalTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {Crowdsale} from './crowdsale/Crowdsale.sol';\nimport {FinalizableCrowdsale} from './crowdsale/FinalizableCrowdsale.sol';\nimport {ISecuritizationPool} from '../pool/ISecuritizationPool.sol';\nimport {IMintedTGE} from './IMintedTGE.sol';\nimport {LongSaleInterest} from './base/LongSaleInterest.sol';\n\n/// @title MintedNormalTGE\n/// @author Untangled Team\n/// @dev Note sale for JOT\ncontract MintedNormalTGE is IMintedTGE, FinalizableCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n    uint256 public initialAmount;\n\n    uint32 public pickedInterest;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n    }\n\n    /// @inheritdoc Crowdsale\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    /// @dev Sets the yield variable to the specified value\n    function setYield(uint256 _yield) public whenNotPaused onlyRole(OWNER_ROLE) {\n        yield = _yield;\n        emit YieldUpdated(_yield);\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n            emit SetupLongSale(interestRate, termLengthInSeconds, timeStartEarningInterest);\n            emit YieldUpdated(yield);\n        }\n    }\n\n    function getTokenPrice() public view returns (uint256) {\n        return registry.getDistributionAssessor().getJOTTokenPrice(pool);\n    }\n\n    function getTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return currencyAmount / getTokenPrice();\n    }\n\n    /// @notice Setup a new round sale for note token\n    /// @param openingTime_ Define when the sale should start\n    /// @param closingTime_ Define when the sale should end\n    /// @param cap_ Target amount of raised currency\n    function startNewRoundSale(\n        uint256 openingTime_,\n        uint256 closingTime_,\n        uint256 rate_,\n        uint256 cap_\n    ) external override whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or pool'\n        );\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate_);\n        newSaleRoundTime(openingTime_, closingTime_);\n        _setTotalCap(cap_);\n    }\n\n    /// @notice Setup initial amount currency raised for JOT condition\n    /// @param _initialAmount Expected minimum amount of JOT before SOT start\n    function setInitialAmount(uint256 _initialAmount) external whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or pool'\n        );\n        require(initialAmount < totalCap, 'MintedNormalTGE: Initial JOT amount must be less than total cap');\n        initialAmount = _initialAmount;\n        emit UpdateInitialAmount(_initialAmount);\n    }\n\n    /// @dev Validates that the previous sale round is closed and the time interval for increasing interest is greater than zero\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n    }\n\n    function _finalization() internal override {\n        super._finalization();\n\n        pickedInterest = uint32(interestRate);\n    }\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public override(IMintedTGE, Crowdsale) returns (uint256) {\n        return Crowdsale.buyTokens(payee, beneficiary, currencyAmount);\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/types.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nbytes32 constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");"
    },
    "contracts/protocol/pool/auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\ncontract Auth {\n    mapping (address => uint256) public wards;\n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"not-authorized\");\n        _;\n    }\n\n}\n"
    },
    "contracts/protocol/pool/base/NAVCalculation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../libraries/UntangledMath.sol';\nimport '../../../libraries/Configuration.sol';\n\nimport {RiskScore} from './types.sol';\n\ncontract NAVCalculation {\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10 ** 4;\n    uint256 public constant ONE_HUNDRED_PERCENT = 100 * INTEREST_RATE_SCALING_FACTOR_PERCENT;\n\n    // struct RiskScore {\n    //     uint32 daysPastDue;\n    //     uint32 advanceRate;\n    //     uint32 penaltyRate;\n    //     uint32 interestRate;\n    //     uint32 probabilityOfDefault;\n    //     uint32 lossGivenDefault;\n    //     uint32 writeOffAfterGracePeriod;\n    //     uint32 gracePeriod;\n    //     uint32 collectionPeriod;\n    //     uint32 writeOffAfterCollectionPeriod;\n    //     uint32 discountRate;\n    // }\n\n    /// @dev Calculate the expected present asset value\n    /// @param principalAmount Principal amount of asset\n    /// @param expectTimeEarnInterest Expected interest amount in expected repayment amount\n    /// @param interestRate interest rate of LAT, or interest rate for SOT, or interest rate for JOT (always interest rate= 0)\n    /// @param overdue overdue in seconds\n    /// @param secondTillCashFlow time till expiration in seconds\n    /// @param riskScore risk score applied\n    /// @return expected present asset value\n    function _calculateAssetValue(\n        uint256 principalAmount,\n        uint256 expectTimeEarnInterest,\n        uint256 interestRate,\n        uint256 overdue,\n        uint256 secondTillCashFlow,\n        RiskScore memory riskScore\n    ) internal pure returns (uint256) {\n        uint256 morePercentDecimal = UntangledMath.ONE / INTEREST_RATE_SCALING_FACTOR_PERCENT / 100;\n        uint256 totalDebtAmt = 0;\n\n        // LAT is now PLEDGE\n        interestRate = riskScore.interestRate;\n        principalAmount = (principalAmount * riskScore.advanceRate) / ONE_HUNDRED_PERCENT;\n\n        totalDebtAmt =\n            (principalAmount *\n                UntangledMath.rpow(\n                    UntangledMath.ONE + (interestRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                    expectTimeEarnInterest,\n                    UntangledMath.ONE\n                )) /\n            UntangledMath.ONE;\n\n        if (overdue > riskScore.gracePeriod) {\n            totalDebtAmt =\n                (totalDebtAmt *\n                    UntangledMath.rpow(\n                        UntangledMath.ONE + (interestRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                        riskScore.gracePeriod,\n                        UntangledMath.ONE\n                    )) /\n                UntangledMath.ONE;\n\n            uint256 penaltyRate = (interestRate * riskScore.penaltyRate) / ONE_HUNDRED_PERCENT;\n\n            totalDebtAmt =\n                (totalDebtAmt *\n                    UntangledMath.rpow(\n                        UntangledMath.ONE + (penaltyRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                        overdue - riskScore.gracePeriod,\n                        UntangledMath.ONE\n                    )) /\n                UntangledMath.ONE;\n            uint256 writeOff = riskScore.writeOffAfterGracePeriod;\n            if (overdue > riskScore.collectionPeriod) writeOff = riskScore.writeOffAfterCollectionPeriod;\n\n            totalDebtAmt = (totalDebtAmt * (ONE_HUNDRED_PERCENT - writeOff)) / ONE_HUNDRED_PERCENT;\n        } else if (overdue > 0) {\n            totalDebtAmt =\n                (totalDebtAmt *\n                    UntangledMath.rpow(\n                        UntangledMath.ONE + (interestRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                        overdue,\n                        UntangledMath.ONE\n                    )) /\n                UntangledMath.ONE;\n        }\n\n        uint256 creditRiskAdjustedExpCF = totalDebtAmt -\n            ((totalDebtAmt * riskScore.probabilityOfDefault * expectTimeEarnInterest * riskScore.lossGivenDefault) /\n                (YEAR_LENGTH_IN_SECONDS * ONE_HUNDRED_PERCENT ** 2));\n        return\n            (creditRiskAdjustedExpCF * UntangledMath.ONE) /\n            UntangledMath.rpow(\n                UntangledMath.ONE + (riskScore.discountRate * morePercentDecimal) / YEAR_LENGTH_IN_SECONDS,\n                secondTillCashFlow,\n                UntangledMath.ONE\n            );\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pool/base/SecuritizationPoolServiceBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../../storage/Registry.sol';\nimport {UntangledBase} from '../../../base/UntangledBase.sol';\nimport {ISecuritizationPool} from '../../../interfaces/ISecuritizationPool.sol';\nimport {ConfigHelper} from '../../../libraries/ConfigHelper.sol';\n\ncontract SecuritizationPoolServiceBase is UntangledBase {\n    Registry public registry;\n\n    function initialize(Registry _registry) public initializer {\n        __UntangledBase__init(_msgSender());\n\n        registry = _registry;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/pool/base/types.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nstruct RiskScore {\n    uint32 daysPastDue;\n    uint32 advanceRate;\n    uint32 penaltyRate;\n    uint32 interestRate;\n    uint32 probabilityOfDefault;\n    uint32 lossGivenDefault;\n    uint32 writeOffAfterGracePeriod;\n    uint32 gracePeriod;\n    uint32 collectionPeriod;\n    uint32 writeOffAfterCollectionPeriod;\n    uint32 discountRate;\n}\n\n\n// uint32 advanceRate;\n//     uint32 penaltyRate;\n//     uint32 interestRate;\n//     uint32 probabilityOfDefault;\n//     uint32 lossGivenDefault;\n//     uint32 writeOffAfterGracePeriod;\n//     uint32 gracePeriod;\n//     uint32 collectionPeriod;\n//     uint32 writeOffAfterCollectionPeriod;\n//     uint32 discountRate;"
    },
    "contracts/protocol/pool/discounting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport \"./math.sol\";\n\n/// @notice Discounting contract without a state which defines the relevant formulas for the navfeed\ncontract Discounting is Math {\n    /// @notice calculates the discount for a given loan\n    /// @param discountRate the discount rate\n    /// @param fv the future value of the loan\n    /// @param normalizedBlockTimestamp the normalized block time (each day to midnight)\n    /// @param maturityDate the maturity date of the loan\n    /// @return result discount for the loan\n    function calcDiscount(uint256 discountRate, uint256 fv, uint256 normalizedBlockTimestamp, uint256 maturityDate)\n        public\n        pure\n        returns (uint256 result)\n    {\n        return rdiv(fv, rpow(discountRate, safeSub(maturityDate, normalizedBlockTimestamp), ONE));\n    }\n\n    /// @notice calculate the future value based on the amount, maturityDate interestRate and recoveryRate\n    /// @param loanInterestRate the interest rate of the loan\n    /// @param amount of the loan (principal)\n    /// @param maturityDate the maturity date of the loan\n    /// @param recoveryRatePD the recovery rate together with the probability of default of the loan\n    /// @return fv future value of the loan\n    function calcFutureValue(uint256 loanInterestRate, uint256 amount, uint256 maturityDate, uint256 recoveryRatePD)\n        public\n        view\n        returns (uint256 fv)\n    {\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        uint256 timeRemaining = 0;\n        if (maturityDate > nnow) {\n            timeRemaining = safeSub(maturityDate, nnow);\n        }\n\n        return rmul(rmul(rpow(loanInterestRate, timeRemaining, ONE), amount), recoveryRatePD);\n    }\n\n    /// @notice substracts to values if the result smaller than 0 it returns 0\n    /// @param x the first value (minuend)\n    /// @param y the second value (subtrahend)\n    /// @return result result of the subtraction\n    function secureSub(uint256 x, uint256 y) public pure returns (uint256 result) {\n        if (y > x) {\n            return 0;\n        }\n        return safeSub(x, y);\n    }\n\n    /// @notice normalizes a timestamp to round down to the nearest midnight (UTC)\n    /// @param timestamp the timestamp which should be normalized\n    /// @return nTimestamp normalized timestamp\n    function uniqueDayTimestamp(uint256 timestamp) public pure returns (uint256 nTimestamp) {\n        return (1 days) * (timestamp / (1 days));\n    }\n    /// @notice rpow peforms a math pow operation with fixed point number\n    /// adopted from ds-math\n    /// @param x the base for the pow operation\n    /// @param n the exponent for the pow operation\n    /// @param base the base of the fixed point number\n    /// @return z the result of the pow operation\n\n    function rpow(uint256 x, uint256 n, uint256 base) public pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 { z := base }\n                default { z := 0 }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 { z := base }\n                default { z := x }\n                let half := div(base, 2) // for rounding.\n                for { n := div(n, 2) } n { n := div(n, 2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0, 0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0, 0) }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0, 0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0, 0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocol/pool/DistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './base/SecuritizationPoolServiceBase.sol';\nimport '../../interfaces/INoteToken.sol';\n\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\nimport {IDistributionAssessor} from './IDistributionAssessor.sol';\nimport {ISecuritizationPoolValueService} from './ISecuritizationPoolValueService.sol';\nimport {ISecuritizationLockDistribution} from './ISecuritizationLockDistribution.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\n/// @title DistributionAssessor\n/// @author Untangled Team\n/// @notice Calculate values in a pool\ncontract DistributionAssessor is SecuritizationPoolServiceBase, IDistributionAssessor {\n    using ConfigHelper for Registry;\n\n    function _getTokenPrice(\n        address securitizationPool,\n        INoteToken noteToken,\n        uint256 asset\n    ) private view returns (uint256) {\n        require(address(securitizationPool) != address(0), 'DistributionAssessor: Invalid pool address');\n\n        uint256 totalSupply = noteToken.totalSupply();\n        uint256 decimals = noteToken.decimals();\n\n        require(address(noteToken) != address(0), 'DistributionAssessor: Invalid note token address');\n        // In initial state, SOT price = 1$\n        if (noteToken.totalSupply() == 0)\n            return\n                10 ** (INoteToken(ISecuritizationTGE(securitizationPool).underlyingCurrency()).decimals() - decimals);\n\n        return asset / totalSupply;\n    }\n\n    // get current individual asset for SOT tranche\n    /// @inheritdoc IDistributionAssessor\n    function getSOTTokenPrice(address securitizationPool) public view override returns (uint256) {\n        ISecuritizationPoolValueService poolService = registry.getSecuritizationPoolValueService();\n        uint256 seniorAsset = poolService.getSeniorAsset(address(securitizationPool));\n        return _getTokenPrice(securitizationPool, INoteToken(ISecuritizationTGE(securitizationPool).sotToken()), seniorAsset);\n    }\n\n    /// @inheritdoc IDistributionAssessor\n    function calcCorrespondingTotalAssetValue(\n        address tokenAddress,\n        address investor\n    ) external view override returns (uint256) {\n        return _calcCorrespondingAssetValue(tokenAddress, investor);\n    }\n\n    /// @dev Calculate SOT/JOT asset value belongs to an investor\n    /// @param tokenAddress Address of SOT or JOT token\n    /// @param investor Investor's wallet\n    /// @return The value in pool's underlying currency\n    function _calcCorrespondingAssetValue(address tokenAddress, address investor) internal view returns (uint256) {\n        INoteToken notesToken = INoteToken(tokenAddress);\n        ISecuritizationLockDistribution securitizationPool = ISecuritizationLockDistribution(notesToken.poolAddress());\n\n        // if (Configuration.NOTE_TOKEN_TYPE(notesToken.noteTokenType()) == Configuration.NOTE_TOKEN_TYPE.SENIOR) {\n        //     tokenPrice = getSOTTokenPrice(securitizationPool);\n        // } else {\n        //     tokenPrice = getJOTTokenPrice(securitizationPool);\n        // }\n\n        uint256 tokenPrice = calcTokenPrice(address(securitizationPool), tokenAddress);\n\n        uint256 tokenRedeem = securitizationPool.lockedRedeemBalances(tokenAddress, investor);\n        uint256 tokenBalance = notesToken.balanceOf(investor) - tokenRedeem;\n        return tokenBalance * tokenPrice;\n    }\n\n    /// @notice Calculate SOT/JOT asset value for multiple investors\n    function calcCorrespondingAssetValue(\n        address tokenAddress,\n        address[] calldata investors\n    ) external view returns (uint256[] memory values) {\n        uint256 investorsLength = investors.length;\n        values = new uint256[](investorsLength);\n\n        for (uint256 i = 0; i < investorsLength; i = UntangledMath.uncheckedInc(i)) {\n            values[i] = _calcCorrespondingAssetValue(tokenAddress, investors[i]);\n        }\n    }\n\n    /// @inheritdoc IDistributionAssessor\n    function calcTokenPrice(address pool, address tokenAddress) public view override returns (uint256) {\n        ISecuritizationTGE securitizationPool = ISecuritizationTGE(pool);\n        if (tokenAddress == securitizationPool.sotToken()) return getSOTTokenPrice(pool);\n        if (tokenAddress == securitizationPool.jotToken()) return getJOTTokenPrice(pool);\n        return 0;\n    }\n\n    /// @inheritdoc IDistributionAssessor\n    function getJOTTokenPrice(address securitizationPool) public view override returns (uint256) {\n        ISecuritizationPoolValueService poolService = registry.getSecuritizationPoolValueService();\n        uint256 seniorAsset = poolService.getJuniorAsset(address(securitizationPool));\n        return _getTokenPrice(securitizationPool, INoteToken(ISecuritizationTGE(securitizationPool).jotToken()), seniorAsset);\n    }\n\n    /// @inheritdoc IDistributionAssessor\n    function getCashBalance(address pool) public view override returns (uint256) {\n        ISecuritizationLockDistribution securitizationPool = ISecuritizationLockDistribution(pool);\n        return\n            INoteToken(ISecuritizationTGE(pool).underlyingCurrency()).balanceOf(\n                ISecuritizationPoolStorage(pool).pot()\n            ) - securitizationPool.totalLockedDistributeBalance();\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pool/DistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport './base/SecuritizationPoolServiceBase.sol';\nimport '../../interfaces/INoteToken.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport {IDistributionOperator} from './IDistributionOperator.sol';\nimport {IDistributionTranche} from './IDistributionTranche.sol';\nimport {ICrowdSale} from '../note-sale/crowdsale/ICrowdSale.sol';\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\nimport {ISecuritizationLockDistribution} from './ISecuritizationLockDistribution.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\n/// @title DistributionOperator\n/// @author Untangled Team\ncontract DistributionOperator is SecuritizationPoolServiceBase, IDistributionOperator {\n    using ConfigHelper for Registry;\n\n    enum SettlementType {\n        FEE,\n        REDEEM,\n        PRINCIPAL_REDEEM,\n        INTEREST_REDEEM\n    }\n\n    struct DistributePercent {\n        address investor;\n        uint256 currencyDistribute;\n        uint256 tokenBurn;\n        uint256 paidInterestAmount;\n    }\n\n    event TokensRedeemed(\n        address indexed redeemer,\n        address indexed tokenAddress,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    );\n\n    /// @dev Create a redemption request for note token\n    /// @param noteToken SOT/JOT token address\n    /// @param tokenAmount Amount of SOT/JOT token to be redeemed\n    function _makeRedeemRequest(INoteToken noteToken, uint256 tokenAmount) internal {\n        require(\n            registry.getNoteTokenFactory().isExistingTokens(address(noteToken)),\n            'DistributionOperator: Invalid NoteToken'\n        );\n        require(noteToken.balanceOf(_msgSender()) >= tokenAmount, 'DistributionOperator: Invalid token amount');\n\n        address poolAddress = noteToken.poolAddress();\n        ISecuritizationTGE securitizationPool = ISecuritizationTGE(poolAddress);\n\n        require(\n            securitizationPool.sotToken() != address(noteToken) || securitizationPool.jotToken() != address(noteToken),\n            'DistributionOperator: invalid note token'\n        );\n        IDistributionTranche tranche = registry.getDistributionTranche();\n\n        require(\n            noteToken.allowance(_msgSender(), address(tranche)) >= tokenAmount,\n            'DistributionOperator: Invalid token allowance'\n        );\n\n        uint256 tokenPrice = registry.getDistributionAssessor().calcTokenPrice(poolAddress, address(noteToken));\n\n        address pot = ISecuritizationPoolStorage(poolAddress).pot();\n        uint256 tokenToBeRedeemed = Math.min(\n            INoteToken(securitizationPool.underlyingCurrency()).balanceOf(pot) / tokenPrice,\n            tokenAmount\n        );\n\n        uint256 currencyAmtToBeDistributed = tokenToBeRedeemed * tokenPrice;\n\n        ISecuritizationLockDistribution securitizationLockDistribute = ISecuritizationLockDistribution(poolAddress);\n        securitizationLockDistribute.increaseLockedDistributeBalance(\n            address(noteToken),\n            _msgSender(),\n            currencyAmtToBeDistributed,\n            tokenToBeRedeemed\n        );\n\n        tranche.redeemToken(address(noteToken), _msgSender(), tokenToBeRedeemed);\n    }\n\n    /// @notice Redeem SOT/JOT token and receive an amount of currency\n    /// @dev Fulfill redeem request created\n    /// @param redeemer Redeemer wallet address\n    /// @param pool Pool address which issued note token\n    /// @param tokenAddress Note token address\n    function _redeem(address redeemer, address pool, address tokenAddress) private returns (uint256) {\n        ISecuritizationLockDistribution securitizationPool = ISecuritizationLockDistribution(pool);\n\n        uint256 currencyLocked = securitizationPool.lockedDistributeBalances(tokenAddress, redeemer);\n        uint256 tokenRedeem = securitizationPool.lockedRedeemBalances(tokenAddress, redeemer);\n        if (currencyLocked > 0) {\n            _redeem(redeemer, pool, tokenAddress, tokenRedeem, currencyLocked, registry.getDistributionTranche(), pool);\n\n            if (ISecuritizationTGE(pool).sotToken() == tokenAddress) {\n                ICrowdSale(ISecuritizationPoolStorage(pool).tgeAddress()).onRedeem(currencyLocked);\n            } else if (ISecuritizationTGE(pool).jotToken() == tokenAddress) {\n                ICrowdSale(ISecuritizationPoolStorage(pool).secondTGEAddress()).onRedeem(currencyLocked);\n            }\n        }\n\n        emit TokensRedeemed(redeemer, tokenAddress, currencyLocked, tokenRedeem);\n\n        return currencyLocked;\n    }\n\n    /// @dev This calls make redeem request and redeem at once\n    function makeRedeemRequestAndRedeem(\n        address pool,\n        INoteToken noteToken,\n        uint256 tokenAmount\n    ) public whenNotPaused nonReentrant returns (uint256) {\n        _makeRedeemRequest(noteToken, tokenAmount);\n        uint256 currencyLocked = _redeem(_msgSender(), pool, address(noteToken));\n        address poolOfPot = registry.getSecuritizationManager().potToPool(_msgSender());\n        if (poolOfPot != address(0)) {\n            ISecuritizationTGE(poolOfPot).increaseReserve(currencyLocked);\n        }\n        return currencyLocked;\n    }\n\n    function makeRedeemRequestAndRedeemBatch(\n        address[] calldata pools,\n        INoteToken[] calldata noteTokens,\n        uint256[] calldata tokenAmounts\n    ) public whenNotPaused nonReentrant {\n        address redeemer = _msgSender();\n        for (uint256 i = 0; i < pools.length; i = UntangledMath.uncheckedInc(i)) {\n            _makeRedeemRequest(noteTokens[i], tokenAmounts[i]);\n            _redeem(redeemer, pools[i], address(noteTokens[i]));\n        }\n    }\n\n    function _redeem(\n        address redeemer,\n        address pool,\n        address tokenAddress,\n        uint256 tokenAmount,\n        uint256 currencyAmount,\n        IDistributionTranche tranche,\n        address securitizationPool\n    ) internal {\n        ISecuritizationLockDistribution(securitizationPool).decreaseLockedDistributeBalance(\n            tokenAddress,\n            redeemer,\n            currencyAmount,\n            tokenAmount\n        );\n        tranche.redeem(redeemer, pool, tokenAddress, currencyAmount, tokenAmount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pool/DistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './base/SecuritizationPoolServiceBase.sol';\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\nimport './IDistributionTranche.sol';\n\n/// @title DistributionTranche\n/// @author Untangled Team\ncontract DistributionTranche is SecuritizationPoolServiceBase, IDistributionTranche {\n    using ConfigHelper for Registry;\n\n    modifier onlyOperator() {\n        require(_msgSender() == address(registry.getDistributionOperator()), 'DistributionTranche: Only Operator');\n        _;\n    }\n\n    /// @inheritdoc IDistributionTranche\n    function redeem(\n        address usr,\n        address pool,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external whenNotPaused onlyOperator {\n        if (tokenAmount > 0) {\n            require(IERC20(notesToken).transfer(pool, tokenAmount), 'DistributionTranche: token-transfer-failed');\n        }\n        ISecuritizationTGE(pool).redeem(usr, notesToken, currencyAmount, tokenAmount);\n    }\n\n    /// @inheritdoc IDistributionTranche\n    function redeemToken(\n        address noteToken,\n        address usr,\n        uint256 tokenAmount\n    ) external whenNotPaused onlyOperator {\n        require(IERC20(noteToken).transferFrom(usr, address(this), tokenAmount), 'DistributionTranche: token-transfer-failed');\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pool/IDistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"./ISecuritizationPool.sol\";\n\ninterface IDistributionAssessor {\n    /// @notice current individual asset price for the \"SOT\" tranche at the current timestamp\n    function getSOTTokenPrice(address securitizationPool) external view returns (uint256);\n\n    /// @notice calculates the token price for the \"JOT\" tranche at the current timestamp\n    function getJOTTokenPrice(address securitizationPool) external view returns (uint256);\n\n    /// @notice calculates the token price for a specific token address in the securitization pool\n    function calcTokenPrice(address pool, address tokenAddress) external view returns (uint256);\n\n    /// @notice the available cash balance in the securitization pool\n    function getCashBalance(address pool) external view returns (uint256);\n\n    /// @notice calculates the corresponding total asset value for a specific token address, investor, and end time\n    function calcCorrespondingTotalAssetValue(\n        address tokenAddress,\n        address investor\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/IDistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IDistributionOperator {}\n"
    },
    "contracts/protocol/pool/IDistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IDistributionTranche {\n    /// @notice allows the redemption of tokens for a specific redeemer from a specified pool and tokenAddress\n    function redeem(\n        address usr,\n        address pool,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external;\n\n    /// @notice allows the distribution operator to redeem tokenAmount tokens of a specific noteToken from a given usr\n    function redeemToken(address noteToken, address usr, uint256 tokenAmount) external;\n}\n"
    },
    "contracts/protocol/pool/INoteTokenVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\ninterface INoteTokenVault {\n    event RedeemOrder(address pool, address noteTokenAddress, address usr, uint256 noteTokenRedeemAmount, uint256 noteTokenPrice);\n    event DisburseSOTOrder(address pool, address[] toAddresses, uint256[] amounts, uint256[] redeemedAmount);\n    event DisburseOrder(address pool, address noteTokenAddress, address[] toAddresses, uint256[] amounts, uint256[] redeemedAmount);\n    event SetRedeemDisabled(address pool, bool _redeemDisabled);\n\n    /// @title UserOrder\n    /// @dev Represents a user's order containing the amount of SOT and JOT to redeem.\n    struct UserOrder {\n        uint256 redeemSOTAmount;\n        uint256 redeemJOTAmount;\n    }\n\n    /// @notice redeemJOTOrder function can be used to place or revoke a redeem\n    function redeemOrder(address pool, address noteTokenAddress, uint256 newRedeemAmount) external;\n\n    /// @dev Disburses funds and handles SOT redemptions for a pool.\n    /// @param pool The address of the pool contract.\n    /// @param toAddresses An array of recipient addresses.\n    /// @param currencyAmounts An array of amounts to disburse to each recipient.\n    /// @param redeemedNoteAmounts An array of SOT amounts redeemed by each recipient.\n    /// @notice Only accessible by BACKEND_ADMIN role.\n    function disburseAllForSOT(address pool, address[] memory toAddresses, uint256[] memory currencyAmounts, uint256[] memory redeemedNoteAmounts) external;\n\n    /// @dev Disburses funds and handles JOT redemptions for a pool.\n    /// @param pool The address of the pool contract.\n    /// @param toAddresses An array of recipient addresses.\n    /// @param currencyAmounts An array of amounts to disburse to each recipient.\n    /// @param redeemedNoteAmounts An array of JOT amounts redeemed by each recipient.\n    /// @notice Only accessible by BACKEND_ADMIN role.\n    function disburseAll(address pool, address noteTokenAddress, address[] memory toAddresses, uint256[] memory currencyAmounts, uint256[] memory redeemedNoteAmounts) external;\n\n    /// @notice Pause redeem request\n    function setRedeemDisabled(address pool, bool _redeemDisabled) external;\n\n    /// @notice Total amount of SOT redeem order\n    function totalSOTRedeem(address pool) external view returns (uint256);\n\n    /// @notice Get redeem disabled\n    function redeemDisabled(address pool) external view returns (bool);\n\n    /// @notice Total amount of JOT redeem order\n    function totalJOTRedeem(address pool) external view returns (uint256);\n\n    /// @dev Retrieves the amount of JOT tokens that can be redeemed for the specified user.\n    /// @param usr The address of the user for which to retrieve the redeemable JOT amount.\n    /// @return The amount of JOT tokens that can be redeemed by the user.\n    function userRedeemJOTOrder(address pool, address usr) external view returns (uint256);\n    function userRedeemSOTOrder(address pool, address usr) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/IPoolNAV.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport './auth.sol';\nimport {Discounting} from './discounting.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\ninterface IPoolNAV {\n    function addLoan(uint256 loan) external returns (uint256);\n\n    function repayLoan(uint256 loan, uint256 amount) external returns (uint256);\n\n    function file(bytes32 name, uint256 value) external;\n\n    function file(\n        bytes32 name,\n        uint256 rate_,\n        uint256 writeOffPercentage_,\n        uint256 overdueDays_,\n        uint256 penaltyRate_,\n        uint256 riskIndex\n    ) external;\n\n    function debt(uint256 loan) external view returns (uint256 loanDebt);\n\n    /// @notice calculates and returns the current NAV\n    /// @return nav_ current NAV\n    function currentNAV() external view returns (uint256 nav_);\n}\n"
    },
    "contracts/protocol/pool/IPoolNAVFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport '../../interfaces/INoteToken.sol';\n\ninterface IPoolNAVFactory {\n    event UpdatePoolNAVImplementation(address indexed newAddress);\n\n    function setPoolNAVImplementation(address newAddress) external;\n\n    function poolNAVImplementation() external view returns (address);\n\n    function createPoolNAV() external returns (address);\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\n\nimport {OWNER_ROLE, ORIGINATOR_ROLE} from './types.sol';\n\ninterface ISecuritizationAccessControl {\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function isOwner(address account) external view returns (bool);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationLockDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ISecuritizationLockDistribution {\n    event UpdateLockedDistributeBalance(\n        address indexed tokenAddress,\n        address indexed investor,\n        uint256 lockedDistributeBalance,\n        uint256 lockedRedeemBalances,\n        uint256 totalLockedRedeemBalances,\n        uint256 totalLockedDistributeBalance\n    );\n\n    event UpdateTotalRedeemedCurrency(uint256 totalRedeemedCurrency, address tokenAddress);\n    event UpdateTotalLockedDistributeBalance(uint256 totalLockedDistributionBalance, address tokenAddress);\n\n    // Total $ (cUSD) has been redeemed\n    function totalRedeemedCurrency() external view returns (uint256);\n\n    // token address -> user -> locked\n    function lockedDistributeBalances(address tokenAddress, address investor) external view returns (uint256);\n\n    // token address -> total locked\n    function lockedRedeemBalances(address tokenAddress, address investor) external view returns (uint256);\n\n    // token address -> total locked\n    function totalLockedRedeemBalances(address tokenAddress) external view returns (uint256);\n\n    // for lending operation\n    function totalLockedDistributeBalance() external view returns (uint256);\n\n    /// @notice increases the locked distribution balance for a specific investor\n    function increaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external;\n\n    /// @notice decreases the locked distribution balance for a specific investor\n    function decreaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport './ISecuritizationPool.sol';\n\ninterface ISecuritizationManager {\n    event NewTGECreated(address indexed instanceAddress);\n    event NewNotesTokenCreated(address indexed instanceAddress);\n    event NewPoolCreated(address indexed instanceAddress);\n    event UpdatePotToPool(address indexed pot, address indexed pool);\n    event SotDeployed(address indexed sotAddress, address tgeAddress, address poolAddress);\n    event JotDeployed(address indexed jotAddress, address tgeAddress, address poolAddress);\n\n    function registry() external view returns (Registry);\n\n    function isExistingPools(address pool) external view returns (bool);\n\n    function pools(uint256 idx) external view returns (address);\n\n    function potToPool(address pot) external view returns (address);\n\n    function isExistingTGEs(address tge) external view returns (bool);\n\n    /// @dev Register pot to pool instance\n    /// @param pot Pool linked wallet\n    function registerPot(address pot) external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../libraries/Configuration.sol';\n\nimport {RiskScore} from './base/types.sol';\n\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\ninterface ISecuritizationPool {\n    event CollectAsset(uint256 value);\n    // event UpdateOpeningBlockTimestamp(uint256 newTimestamp);\n    event SecuritizationPoolWithdraw(address originatorAddress, uint256 amount);\n    event AddTokenAssetAddress(address token);\n    event InsertNFTAsset(address token, uint256 tokenId);\n    event RemoveNFTAsset(address token, uint256 tokenId);\n    event UpdateTGEAddress(address tge, address token, Configuration.NOTE_TOKEN_TYPE noteType);\n    event UpdateInterestRateSOT(uint32 _interestRateSOT);\n    event UpdateLockedDistributeBalance(\n        address indexed tokenAddress,\n        address indexed investor,\n        uint256 lockedDistributeBalance,\n        uint256 lockedRedeemBalances,\n        uint256 totalLockedRedeemBalances,\n        uint256 totalLockedDistributeBalance\n    );\n    event UpdateReserve(uint256 currencyAmount);\n    event UpdatePaidPrincipalAmountSOTByInvestor(address indexed user, uint256 currencyAmount);\n\n    /// @notice A view function that returns the length of the NFT (non-fungible token) assets array\n    function getNFTAssetsLength() external view returns (uint256);\n\n    /// @notice A view function that returns an array of token asset addresses\n    function getTokenAssetAddresses() external view returns (address[] memory);\n\n    /// @notice A view function that returns the length of the token asset addresses array\n    function getTokenAssetAddressesLength() external view returns (uint256);\n\n    /// @notice Riks scores length\n    /// @return the length of the risk scores array\n    function getRiskScoresLength() external view returns (uint256);\n\n    function riskScores(uint256 index) external view returns (RiskScore memory);\n\n    /// @notice sets up the risk scores for the contract for pool\n    function setupRiskScores(\n        uint32[] calldata _daysPastDues,\n        uint32[] calldata _ratesAndDefaults,\n        uint32[] calldata _periodsAndWriteOffs\n    ) external;\n\n    /// @notice exports NFT assets to another pool address\n    function exportAssets(address tokenAddress, address toPoolAddress, uint256[] calldata tokenIds) external;\n\n    /// @notice withdraws NFT assets from the contract and transfers them to recipients\n    function withdrawAssets(\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        address[] calldata recipients\n    ) external;\n\n    /// @notice collects NFT assets from a specified address\n    function collectAssets(uint256[] calldata tokenIds) external returns(uint256);\n\n    /// @notice collects ERC20 assets from specified senders\n    function collectERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata senders,\n        uint256[] calldata amounts\n    ) external;\n\n    /// @notice withdraws ERC20 assets from the contract and transfers them to recipients\\\n    function withdrawERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external;\n\n    function nftAssets(uint256 idx) external view returns (ISecuritizationPoolStorage.NFTAsset memory);\n\n    function tokenAssetAddresses(uint256 idx) external view returns (address);\n\n    /// @dev Trigger set up opening block timestamp\n    function setUpOpeningBlockTimestamp() external;\n\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\n\nimport {RiskScore} from './base/types.sol';\n\ninterface ISecuritizationPoolStorage {\n    event UpdateOpeningBlockTimestamp(uint256 newTimestamp);\n\n    struct NFTAsset {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    enum CycleState {\n        INITIATED,\n        CROWDSALE,\n        OPEN,\n        CLOSED\n    }\n\n    struct NewPoolParams {\n        address currency;\n        uint32 minFirstLossCushion;\n        bool validatorRequired;\n        uint256 debtCeiling;\n    }\n\n    struct Storage {\n        bool validatorRequired;\n        uint64 firstAssetTimestamp;\n        RiskScore[] riskScores;\n        NFTAsset[] nftAssets;\n        address[] tokenAssetAddresses;\n        mapping(address => bool) existsTokenAssetAddress;\n        // TGE\n        address tgeAddress;\n        address secondTGEAddress;\n        address sotToken;\n        address jotToken;\n        \n        address underlyingCurrency;\n        uint256 reserve; // Money in pool\n        uint32 minFirstLossCushion;\n        uint64 openingBlockTimestamp;\n        uint64 termLengthInSeconds;\n        // by default it is address(this)\n        address pot;\n        // for base (sell-loan) operation\n        uint256 principalAmountSOT;\n        uint256 paidPrincipalAmountSOT;\n        uint32 interestRateSOT; // Annually, support 4 decimals num\n        uint256 totalAssetRepaidCurrency;\n        mapping(address => uint256) paidPrincipalAmountSOTByInvestor;\n        uint256 amountOwedToOriginator;\n        uint256 debtCeiling;\n        CycleState state;\n        // lock distribution\n        mapping(address => mapping(address => uint256)) lockedDistributeBalances;\n        uint256 totalLockedDistributeBalance;\n        mapping(address => mapping(address => uint256)) lockedRedeemBalances;\n        // token address -> total locked\n        mapping(address => uint256) totalLockedRedeemBalances;\n        uint256 totalRedeemedCurrency; // Total $ (cUSD) has been redeemed\n        address poolNAV;\n    }\n\n    function amountOwedToOriginator() external view returns (uint256);\n\n    function tgeAddress() external view returns (address);\n\n    function secondTGEAddress() external view returns (address);\n\n    function state() external view returns (CycleState);\n\n    /// @notice checks if the contract is in a closed state\n    function isClosedState() external view returns (bool);\n\n    function pot() external view returns (address);\n\n    function poolNAV() external view returns (address);\n\n    function validatorRequired() external view returns (bool);\n\n    function openingBlockTimestamp() external view returns (uint64);\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ISecuritizationPoolValueService {\n    /// @notice calculates the outstanding principal in currency amount for a given investor address.\n    /// It takes the investor address as a parameter and returns the outstanding principal\n    function getOutstandingPrincipalCurrencyByInvestor(address pool, address investor) external view returns (uint256);\n\n    /// @notice calculates the total expected value of all assets in the securitization pool at a given timestamp\n    /// @dev iterates over the NFT assets and token assets in the pool, calling getExpectedAssetValue\n    /// or getExpectedERC20AssetValue for each asset and summing up the values\n    function getExpectedAssetsValue(address poolAddress, uint256 timestamp)\n        external\n        view\n        returns (uint256 expectedAssetsValue);\n\n    /// @notice the amount which belongs to the senior investor (SOT) in a pool\n    /// @dev  calculates  the amount which accrues interest for the senior tranche in the securitization pool at a given timestamp\n    function getSeniorAsset(address poolAddress) external view returns (uint256);\n\n    /// @notice calculates  the amount of Junior Debt at the current time\n    function getJuniorAsset(address poolAddress) external view returns (uint256);\n\n    /// @notice returns the rate that belongs to Junior investors at the current time\n    function getJuniorRatio(address poolAddress) external view returns (uint256);\n\n    /// @notice calculates the expected value of an ERC20 asset in the securitization pool at a given timestamp\n    function getExpectedERC20AssetValue(\n        address poolAddress,\n        address assetPoolAddress,\n        address tokenAddress,\n        uint256 interestRate,\n        uint256 timestamp\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationTGE.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {Configuration} from '../../libraries/Configuration.sol';\n\ninterface ISecuritizationTGE {\n    // event UpdateOpeningBlockTimestamp(uint256 newTimestamp);\n    event UpdateTGEAddress(address tge, Configuration.NOTE_TOKEN_TYPE noteType);\n    event UpdatePaidPrincipalAmountSOTByInvestor(address indexed user, uint256 currencyAmount);\n    event UpdateReserve(uint256 currencyAmount);\n    event UpdateInterestRateSOT(uint32 _interestRateSOT);\n    event UpdateDebtCeiling(uint256 _debtCeiling);\n    event Withdraw(address originatorAddress, uint256 amount);\n    event UpdatePoolNAV(address poolNav);\n\n    function termLengthInSeconds() external view returns (uint64);\n\n    /// @notice sets the pot address for the contract\n    function setPot(address _pot) external;\n\n    /// @notice sets debt ceiling value\n    function setDebtCeiling(uint256 _debtCeiling) external;\n\n    // function pot() external view returns (address);\n\n    /// @dev trigger update reserve when buy note token action happens\n    function increaseReserve(uint256 currencyAmount) external;\n\n    /// @dev trigger update reserve\n    function decreaseReserve(uint256 currencyAmount) external;\n\n    // function tgeAddress() external view returns (address);\n\n    // function secondTGEAddress() external view returns (address);\n\n    function sotToken() external view returns (address);\n\n    function jotToken() external view returns (address);\n\n    function underlyingCurrency() external view returns (address);\n\n    function paidPrincipalAmountSOT() external view returns (uint256);\n\n    function paidPrincipalAmountSOTByInvestor(address user) external view returns (uint256);\n\n    function reserve() external view returns (uint256);\n\n    function principalAmountSOT() external view returns (uint256);\n\n    function debtCeiling() external view returns (uint256);\n\n    function interestRateSOT() external view returns (uint32); // Annually, support 4 decimals num\n\n    function minFirstLossCushion() external view returns (uint32);\n\n    // // Money owed to originator\n    // function amountOwedToOriginator() external view returns (uint256);\n\n    function totalAssetRepaidCurrency() external view returns (uint256); // Total $ (cUSD) paid for Asset repayment - repayInBatch\n\n    /// @notice injects the address of the Token Generation Event (TGE) and the associated token address\n    function injectTGEAddress(\n        address _tgeAddress,\n        // address _tokenAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteToken\n    ) external;\n\n    /// @dev trigger update asset value repaid\n    function increaseTotalAssetRepaidCurrency(uint256 amount) external;\n\n    function redeem(address usr, address notesToken, uint256 currencyAmount, uint256 tokenAmount) external;\n\n    /// @dev Disburses a specified amount of currency to the given user.\n    /// @param usr The address of the user to receive the currency.\n    /// @param currencyAmount The amount of currency to disburse.\n    function disburse(address usr, uint256 currencyAmount) external;\n\n    /// @notice checks if the redemption process has finished\n    function hasFinishedRedemption() external view returns (bool);\n\n    ///@notice check current debt ceiling is valid\n    function isDebtCeilingValid() external view returns (bool);\n\n    /// @notice sets the interest rate for the senior tranche of tokens\n    function setInterestRateForSOT(uint32 _interestRateSOT) external;\n\n    function claimCashRemain(address recipientWallet) external;\n\n    // function openingBlockTimestamp() external view returns (uint64);\n\n    function startCycle(\n        uint64 _termLengthInSeconds,\n        uint256 _principalAmountForSOT,\n        uint32 _interestRateForSOT,\n        uint64 _timeStartEarningInterest\n    ) external;\n\n    /// @notice allows the originator to withdraw from reserve\n    function withdraw(address to, uint256 amount) external;\n\n    function setUpPoolNAV() external;\n}\n"
    },
    "contracts/protocol/pool/math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}\n"
    },
    "contracts/protocol/pool/mock/SecuritizationPoolV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../SecuritizationPool.sol';\n\ncontract SecuritizationPoolV2 is SecuritizationPool {\n    function greeting() public pure returns (string memory) {\n        return 'Hello world';\n    }\n\n    function hello() public pure returns (string memory) {\n        return 'Hello world';\n    }\n}\n"
    },
    "contracts/protocol/pool/NoteTokenVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport {ERC20BurnableUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\n\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\nimport {INoteTokenVault} from \"./INoteTokenVault.sol\";\nimport {INoteToken} from '../../interfaces/INoteToken.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\nimport { BACKEND_ADMIN } from './types.sol';\nimport \"../../storage/Registry.sol\";\nimport \"../../libraries/ConfigHelper.sol\";\n\n/// @title NoteTokenVault\n/// @author Untangled Team\n/// @notice NoteToken redemption\ncontract NoteTokenVault is Initializable, PausableUpgradeable, AccessControlEnumerableUpgradeable, INoteTokenVault {\n    using ConfigHelper for Registry;\n    Registry public registry;\n\n    /// @dev Pool redeem disabled value\n    mapping(address => bool) public poolRedeemDisabled;\n    /// @dev Pool total SOT redeem\n    mapping(address => uint256) public poolTotalSOTRedeem;\n    /// @dev Pool total JOT redeem\n    mapping(address => uint256) public poolTotalJOTRedeem;\n    /// @dev Pool user redeem order\n    mapping(address => mapping(address => UserOrder)) public poolUserRedeems;\n\n    /// @dev Checks if redeeming is allowed for a given pool.\n    /// @param pool The address of the pool to check.\n    modifier orderAllowed(address pool) {\n        require(\n            poolRedeemDisabled[pool] == false,\n            \"redeem-not-allowed\"\n        );\n        _;\n    }\n\n    function initialize(Registry _registry) public initializer {\n        __Pausable_init_unchained();\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        registry = _registry;\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function redeemOrder(address pool, address noteTokenAddress, uint256 noteTokenRedeemAmount) public orderAllowed(pool) {\n        address jotTokenAddress = ISecuritizationTGE(pool).jotToken();\n        address sotTokenAddress = ISecuritizationTGE(pool).sotToken();\n        require(noteTokenAddress == jotTokenAddress || noteTokenAddress == sotTokenAddress, \"NoteTokenVault: Invalid token address\");\n        address usr = _msgSender();\n\n        if (noteTokenAddress == jotTokenAddress) {\n            uint256 currentRedeemAmount = poolUserRedeems[pool][usr].redeemJOTAmount;\n            require(currentRedeemAmount == 0, \"NoteTokenVault: User already created redeem order\");\n            poolUserRedeems[pool][usr].redeemJOTAmount = noteTokenRedeemAmount;\n            poolTotalJOTRedeem[pool] = poolTotalJOTRedeem[pool] + noteTokenRedeemAmount;\n            require(INoteToken(jotTokenAddress).transferFrom(usr, address(this), noteTokenRedeemAmount), \"token-transfer-to-pool-failed\");\n            uint256 noteTokenPrice = registry.getDistributionAssessor().getJOTTokenPrice(pool);\n\n            emit RedeemOrder(pool, noteTokenAddress, usr, noteTokenRedeemAmount, noteTokenPrice);\n        } else if (noteTokenAddress == sotTokenAddress) {\n            uint256 currentRedeemAmount = poolUserRedeems[pool][usr].redeemSOTAmount;\n            require(currentRedeemAmount == 0, \"NoteTokenVault: User already created redeem order\");\n            poolUserRedeems[pool][usr].redeemSOTAmount = noteTokenRedeemAmount;\n            poolTotalSOTRedeem[pool] = poolTotalSOTRedeem[pool] + noteTokenRedeemAmount;\n            require(INoteToken(sotTokenAddress).transferFrom(usr, address(this), noteTokenRedeemAmount), \"token-transfer-to-pool-failed\");\n            uint256 noteTokenPrice = registry.getDistributionAssessor().getJOTTokenPrice(pool);\n\n            emit RedeemOrder(pool, noteTokenAddress, usr, noteTokenRedeemAmount, noteTokenPrice);\n        }\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function disburseAllForSOT(\n        address pool,\n        address[] memory toAddresses,\n        uint256[] memory amounts,\n        uint256[] memory redeemedAmounts\n    ) onlyRole(BACKEND_ADMIN) public {\n        ISecuritizationTGE poolTGE = ISecuritizationTGE(pool);\n        uint256 userLength = toAddresses.length;\n        uint256 totalAmount = 0;\n        uint256 totalSOTRedeemed = 0;\n\n        for (uint256 i = 0; i < userLength; i = UntangledMath.uncheckedInc(i)) {\n            totalAmount += amounts[i];\n            totalSOTRedeemed += redeemedAmounts[i];\n            poolTGE.disburse(toAddresses[i], amounts[i]);\n            poolUserRedeems[pool][toAddresses[i]].redeemSOTAmount -= redeemedAmounts[i];\n            ERC20BurnableUpgradeable(poolTGE.sotToken()).burn(redeemedAmounts[i]);\n        }\n\n        poolTotalSOTRedeem[pool] -= totalSOTRedeemed;\n        poolTGE.decreaseReserve(totalAmount);\n        emit DisburseSOTOrder(pool, toAddresses, amounts, redeemedAmounts);\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function disburseAll(\n        address pool,\n        address noteTokenAddress,\n        address[] memory toAddresses,\n        uint256[] memory currencyAmounts,\n        uint256[] memory redeemedNoteAmounts\n    ) onlyRole(BACKEND_ADMIN) public {\n        ISecuritizationTGE poolTGE = ISecuritizationTGE(pool);\n        address jotTokenAddress = poolTGE.jotToken();\n        address sotTokenAddress = poolTGE.sotToken();\n        require(noteTokenAddress == jotTokenAddress || noteTokenAddress == sotTokenAddress, \"NoteTokenVault: Invalid token address\");\n\n        uint256 totalCurrencyAmount = 0;\n        uint256 userLength = toAddresses.length;\n\n        if (noteTokenAddress == jotTokenAddress) {\n            uint256 totalJOTRedeemed = 0;\n            for (uint256 i = 0; i < userLength; i = UntangledMath.uncheckedInc(i)) {\n                totalCurrencyAmount += currencyAmounts[i];\n                totalJOTRedeemed += redeemedNoteAmounts[i];\n                poolTGE.disburse(toAddresses[i], currencyAmounts[i]);\n                poolUserRedeems[pool][toAddresses[i]].redeemJOTAmount -= redeemedNoteAmounts[i];\n                ERC20BurnableUpgradeable(jotTokenAddress).burn(redeemedNoteAmounts[i]);\n            }\n\n            poolTotalJOTRedeem[pool] -= totalJOTRedeemed;\n        } else if (noteTokenAddress == sotTokenAddress) {\n            uint256 totalSOTRedeemed = 0;\n            for (uint256 i = 0; i < userLength; i = UntangledMath.uncheckedInc(i)) {\n                totalCurrencyAmount += currencyAmounts[i];\n                totalSOTRedeemed += redeemedNoteAmounts[i];\n                poolTGE.disburse(toAddresses[i], currencyAmounts[i]);\n                poolUserRedeems[pool][toAddresses[i]].redeemSOTAmount -= redeemedNoteAmounts[i];\n                ERC20BurnableUpgradeable(sotTokenAddress).burn(redeemedNoteAmounts[i]);\n            }\n\n            poolTotalSOTRedeem[pool] -= totalSOTRedeemed;\n        }\n\n        poolTGE.decreaseReserve(totalCurrencyAmount);\n        emit DisburseOrder(pool, noteTokenAddress, toAddresses, currencyAmounts, redeemedNoteAmounts);\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function setRedeemDisabled(address pool, bool _redeemDisabled) onlyRole(BACKEND_ADMIN) public {\n        poolRedeemDisabled[pool] = _redeemDisabled;\n        emit SetRedeemDisabled(pool, _redeemDisabled);\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function redeemDisabled(address pool) public view returns (bool) {\n        return poolRedeemDisabled[pool];\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function totalJOTRedeem(address pool) public view override returns (uint256) {\n        return poolTotalJOTRedeem[pool];\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function totalSOTRedeem(address pool) public view override returns (uint256) {\n        return poolTotalSOTRedeem[pool];\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function userRedeemJOTOrder(address pool, address usr) public view override returns (uint256) {\n        return poolUserRedeems[pool][usr].redeemJOTAmount;\n    }\n\n    /// @inheritdoc INoteTokenVault\n    function userRedeemSOTOrder(address pool, address usr) public view override returns (uint256) {\n        return poolUserRedeems[pool][usr].redeemSOTAmount;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/pool/PoolNAV.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport './auth.sol';\nimport {Discounting} from './discounting.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '../../libraries/ConfigHelper.sol';\nimport '../../libraries/UnpackLoanParamtersLib.sol';\nimport {RiskScore} from './base/types.sol';\nimport {IPoolNAV} from './IPoolNAV.sol';\n\ncontract PoolNAV is Auth, Discounting, Initializable, IPoolNAV {\n    using ConfigHelper for Registry;\n\n    /// @notice details of the underlying collateral\n    struct NFTDetails {\n        uint128 nftValues;\n        uint128 futureValue;\n        uint128 maturityDate;\n        uint128 risk;\n    }\n\n    /// @notice stores all needed information of an interest rate group\n    struct Rate {\n        // total debt of all loans with this rate\n        uint256 pie;\n        // accumlated rate index over time\n        uint256 chi;\n        // interest rate per second\n        uint256 ratePerSecond;\n        // penalty rate per second\n        uint256 penaltyRatePerSecond;\n        // accumlated penalty rate index over time\n        uint256 penaltyChi;\n        // last time the rate was accumulated\n        uint48 lastUpdated;\n        // time start to penalty\n        uint48 timeStartPenalty;\n    }\n\n    address public pool;\n    Registry public registry;\n\n    /// @notice Interest Rate Groups are identified by a `uint` and stored in a mapping\n    mapping(uint256 => Rate) public rates;\n\n    mapping(uint256 => uint256) public pie;\n\n    /// @notice mapping from loan => rate\n    mapping(uint256 => uint256) public loanRates;\n    /// @notice mapping from loan => grace time\n\n    /// Events\n    event IncreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event DecreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event SetRate(uint256 indexed loan, uint256 rate);\n    event ChangeRate(uint256 indexed loan, uint256 newRate);\n    event File(bytes32 indexed what, uint256 rate, uint256 value);\n\n    uint256 public loanCount;\n    mapping(uint256 => uint256) public balances;\n    uint256 public balance;\n\n    /// @notice details of the loan\n    struct LoanDetails {\n        uint128 borrowed;\n        // only auth calls can move loan into different writeOff group\n        bool authWriteOff;\n    }\n\n    /// @notice details of the write off group\n    struct WriteOffGroup {\n        // denominated in (10^27)\n        uint128 percentage;\n        // amount of days after the maturity days that the writeoff group can be applied by default\n        uint128 overdueDays;\n        uint128 riskIndex;\n    }\n\n    // nft => details\n    mapping(bytes32 => NFTDetails) public details;\n    // loan => details\n    mapping(uint256 => LoanDetails) public loanDetails;\n    // timestamp => bucket\n    mapping(uint256 => uint256) public buckets;\n\n    WriteOffGroup[] public writeOffGroups;\n\n    // Write-off groups will be added as rate groups to the pile with their index\n    // in the writeOffGroups array + this number\n    uint256 public constant WRITEOFF_RATE_GROUP_START = 1000 * ONE;\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10 ** 4;\n    uint256 public constant ONE_HUNDRED_PERCENT = 100 * INTEREST_RATE_SCALING_FACTOR_PERCENT;\n\n    // Discount rate applied on every asset's fv depending on its maturityDate.\n    // The discount decreases with the maturityDate approaching.\n    // denominated in (10^27)\n    uint256 public discountRate;\n\n    // latestNAV is calculated in case of borrows & repayments between epoch executions.\n    // It decreases/increases the NAV by the repaid/borrowed amount without running the NAV calculation routine.\n    // This is required for more accurate Senior & JuniorAssetValue estimations between epochs\n    uint256 public latestNAV;\n    uint256 public latestDiscount;\n    uint256 public lastNAVUpdate;\n\n    // overdue loans are loans which passed the maturity date but are not written-off\n    uint256 public overdueLoans;\n\n    // events\n    event Depend(bytes32 indexed name, address addr);\n    event SetLoanMaturity(bytes32 nftID_, uint256 maturityDate_);\n    event WriteOff(uint256 indexed loan, uint256 indexed writeOffGroupsIndex, bool override_);\n    event AddLoan(uint256 indexed loan, uint256 principalAmount, uint256 maturityDate);\n\n    function getRiskScoreByIdx(uint256 idx) private view returns (RiskScore memory) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(pool);\n        require(address(securitizationPool) != address(0), 'Pool was not deployed');\n        if (idx == 0 || securitizationPool.getRiskScoresLength() == 0) {\n            // Default risk score\n            return\n                RiskScore({\n                    daysPastDue: 0,\n                    advanceRate: 1000000,\n                    penaltyRate: 0,\n                    interestRate: 0,\n                    probabilityOfDefault: 0,\n                    lossGivenDefault: 0,\n                    writeOffAfterGracePeriod: 0,\n                    gracePeriod: 0,\n                    collectionPeriod: 0,\n                    writeOffAfterCollectionPeriod: 0,\n                    discountRate: 0\n                });\n        }\n        // Because risk score upload = risk score index onchain + 1\n        idx = idx - 1;\n        return securitizationPool.riskScores(idx);\n    }\n\n    function addLoan(uint256 loan) external auth returns (uint256) {\n        UnpackLoanParamtersLib.InterestParams memory loanParam = registry\n            .getLoanInterestTermsContract()\n            .unpackParamsForAgreementID(bytes32(loan));\n        bytes32 _tokenId = bytes32(loan);\n        ILoanRegistry.LoanEntry memory loanEntry = registry.getLoanRegistry().getEntry(_tokenId);\n        RiskScore memory riskParam = getRiskScoreByIdx(loanEntry.riskScore);\n        uint256 principalAmount = loanParam.principalAmount;\n        uint256 _convertedInterestRate;\n\n        principalAmount = (principalAmount * riskParam.advanceRate) / (ONE_HUNDRED_PERCENT);\n        _convertedInterestRate =\n            ONE +\n            (riskParam.interestRate * ONE) /\n            (100 * INTEREST_RATE_SCALING_FACTOR_PERCENT * 365 days);\n\n        loanCount++;\n        setLoanMaturityDate(_tokenId, loanParam.termEndUnixTimestamp);\n        if (rates[_convertedInterestRate].ratePerSecond == 0) {\n            // If interest rate is not set\n            file('rate', _convertedInterestRate, _convertedInterestRate);\n        }\n        setRate(loan, _convertedInterestRate);\n        accrue(loan);\n\n        balances[loan] = safeAdd(balances[loan], principalAmount);\n        balance = safeAdd(balance, principalAmount);\n\n        // increase NAV\n        borrow(loan, principalAmount);\n        incDebt(loan, principalAmount);\n\n        emit AddLoan(loan, principalAmount, loanParam.termEndUnixTimestamp);\n\n        return principalAmount;\n    }\n\n    /// @notice getter function for the maturityDate\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\n    /// @return maturityDate_ the maturityDate of the nft\n    function maturityDate(bytes32 nft_) public view returns (uint256 maturityDate_) {\n        return uint256(details[nft_].maturityDate);\n    }\n\n    /// @notice getter function for the risk group\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\n    /// @return risk_ the risk group of the nft\n\n    function risk(bytes32 nft_) public view returns (uint256 risk_) {\n        return uint256(details[nft_].risk);\n    }\n\n    /// @notice getter function for the nft value\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\n    /// @return nftValue_ the value of the nft\n\n    function nftValues(bytes32 nft_) public view returns (uint256 nftValue_) {\n        return uint256(details[nft_].nftValues);\n    }\n\n    /// @notice getter function for the future value\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\n    /// @return fv_ future value of the loan\n    function futureValue(bytes32 nft_) public view returns (uint256 fv_) {\n        return uint256(details[nft_].futureValue);\n    }\n\n    /// @notice getter function for the recovery rate PD\n    /// @param riskID id of a risk group\n    /// @return recoveryRatePD_ recovery rate PD of the risk group\n    function recoveryRatePD(uint256 riskID, uint256 termLength) public view returns (uint256 recoveryRatePD_) {\n        RiskScore memory riskParam = getRiskScoreByIdx(riskID);\n        return\n            ONE -\n            (ONE * riskParam.probabilityOfDefault * riskParam.lossGivenDefault * termLength) /\n            (ONE_HUNDRED_PERCENT * ONE_HUNDRED_PERCENT * 365 days);\n    }\n\n    /// @notice getter function for the borrowed amount\n    /// @param loan id of a loan\n    /// @return borrowed_ borrowed amount of the loan\n    function borrowed(uint256 loan) public view returns (uint256 borrowed_) {\n        return uint256(loanDetails[loan].borrowed);\n    }\n\n    function initialize(Registry _registry, address _pool) public initializer {\n        registry = _registry;\n        wards[_pool] = 1;\n        pool = _pool;\n        lastNAVUpdate = uniqueDayTimestamp(block.timestamp);\n\n        // pre-definition for loans without interest rates\n        rates[0].chi = ONE;\n        rates[0].ratePerSecond = ONE;\n\n        // Default discount rate\n        discountRate = ONE;\n\n        emit Rely(_pool);\n    }\n\n    /// @notice converts a uint256 to uint128\n    /// @param value the value to be converted\n    /// @return converted value to uint128\n    function toUint128(uint256 value) internal pure returns (uint128 converted) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    function setLoanMaturityDate(bytes32 nftID_, uint256 maturityDate_) public auth {\n        require((futureValue(nftID_) == 0), 'can-not-change-maturityDate-outstanding-debt');\n        details[nftID_].maturityDate = toUint128(uniqueDayTimestamp(maturityDate_));\n        emit SetLoanMaturity(nftID_, maturityDate_);\n    }\n\n    /// @notice file allows governance to change parameters of the contract\n    /// @param name name of the parameter\n    /// @param value new value of the parameter\n    function file(bytes32 name, uint256 value) public auth {\n        if (name == 'discountRate') {\n            uint256 oldDiscountRate = discountRate;\n            discountRate = ONE + (value * ONE) / (100 * INTEREST_RATE_SCALING_FACTOR_PERCENT * 365 days);\n            // the nav needs to be re-calculated based on the new discount rate\n            // no need to recalculate it if initialized the first time\n            if (oldDiscountRate != 0) {\n                reCalcNAV();\n            }\n        } else {\n            revert('unknown config parameter');\n        }\n    }\n\n    /// @notice file allows governance to change parameters of the contract\n    /// @param name name of the parameter group\n    /// @param writeOffPercentage_ the write off rate in percent\n    /// @param overdueDays_ the number of days after which a loan is considered overdue\n    function file(\n        bytes32 name,\n        uint256 rate_,\n        uint256 writeOffPercentage_,\n        uint256 overdueDays_,\n        uint256 penaltyRate_,\n        uint256 riskIndex\n    ) public auth {\n        if (name == 'writeOffGroup') {\n            uint256 index = writeOffGroups.length;\n            uint256 _convertedInterestRate = ONE +\n                (rate_ * ONE) /\n                (100 * INTEREST_RATE_SCALING_FACTOR_PERCENT * 365 days);\n            uint256 _convertedWriteOffPercentage = ONE - (writeOffPercentage_ * ONE) / ONE_HUNDRED_PERCENT;\n            uint256 _convertedPenaltyRate = ONE +\n                (ONE * penaltyRate_ * rate_) /\n                (ONE_HUNDRED_PERCENT * ONE_HUNDRED_PERCENT * 365 days);\n            uint256 _convertedOverdueDays = overdueDays_ / 1 days;\n            writeOffGroups.push(\n                WriteOffGroup(\n                    toUint128(_convertedWriteOffPercentage),\n                    toUint128(_convertedOverdueDays),\n                    toUint128(riskIndex)\n                )\n            );\n            file('rate', safeAdd(WRITEOFF_RATE_GROUP_START, index), _convertedInterestRate);\n            file('penalty', safeAdd(WRITEOFF_RATE_GROUP_START, index), _convertedPenaltyRate);\n        } else {\n            revert('unknown name');\n        }\n    }\n\n    /// @notice file manages different state configs for the pile\n    /// only a ward can call this function\n    /// @param what what config to change\n    /// @param rate the interest rate group\n    /// @param value the value to change\n    function file(bytes32 what, uint256 rate, uint256 value) public auth {\n        if (what == 'rate') {\n            require(value != 0, 'rate-per-second-can-not-be-0');\n            if (rates[rate].chi == 0) {\n                rates[rate].chi = ONE;\n                rates[rate].lastUpdated = uint48(block.timestamp);\n            } else {\n                drip(rate);\n            }\n            rates[rate].ratePerSecond = value;\n        } else if (what == 'penalty') {\n            require(value != 0, 'penalty-per-second-can-not-be-0');\n            if (rates[rate].penaltyChi == 0) {\n                rates[rate].penaltyChi = ONE;\n                rates[rate].lastUpdated = uint48(block.timestamp);\n            } else {\n                drip(rate);\n            }\n\n            rates[rate].penaltyRatePerSecond = value;\n        } else {\n            revert('unknown parameter');\n        }\n    }\n\n    /// @notice borrow updates the NAV for a new borrowed loan\n    /// @param loan the id of the loan\n    /// @param amount the amount borrowed\n    /// @return navIncrease the increase of the NAV impacted by the new borrow\n    function borrow(uint256 loan, uint256 amount) private returns (uint256 navIncrease) {\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        bytes32 nftID_ = nftID(loan);\n        uint256 maturityDate_ = maturityDate(nftID_);\n\n        require(maturityDate_ > nnow, 'maturity-date-is-not-in-the-future');\n\n        if (nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n\n        // calculate amount including fixed fee if applicatable\n        Rate memory _rate = rates[loanRates[loan]];\n\n        // calculate future value FV\n        ILoanRegistry.LoanEntry memory loanEntry = registry.getLoanRegistry().getEntry(bytes32(loan));\n        uint256 fv = calcFutureValue(\n            _rate.ratePerSecond,\n            amount,\n            maturityDate_,\n            recoveryRatePD(loanEntry.riskScore, loanEntry.expirationTimestamp - loanEntry.issuanceBlockTimestamp)\n        );\n        details[nftID_].futureValue = toUint128(safeAdd(futureValue(nftID_), fv));\n\n        // add future value to the bucket of assets with the same maturity date\n        buckets[maturityDate_] = safeAdd(buckets[maturityDate_], fv);\n\n        // increase borrowed amount for future ceiling computations\n        loanDetails[loan].borrowed = toUint128(safeAdd(borrowed(loan), amount));\n\n        // return increase NAV amount\n        navIncrease = calcDiscount(discountRate, fv, nnow, maturityDate_);\n\n        latestDiscount = safeAdd(latestDiscount, navIncrease);\n        latestNAV = safeAdd(latestNAV, navIncrease);\n        return navIncrease;\n    }\n\n    /// @notice repay updates the NAV for a new repaid loan\n    /// @param loan the id of the loan\n    /// @param amount the amount repaid\n    function repayLoan(uint256 loan, uint256 amount) external returns (uint256) {\n        require(address(registry.getLoanRepaymentRouter()) == msg.sender, 'not authorized');\n        accrue(loan);\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        if (nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n\n        // In case of successful repayment the latestNAV is decreased by the repaid amount\n        bytes32 nftID_ = nftID(loan);\n        uint256 maturityDate_ = maturityDate(nftID_);\n\n        uint256 _currentDebt = debt(loan);\n        if (amount > _currentDebt) {\n            amount = _currentDebt;\n        }\n        // case 1: repayment of a written-off loan\n        if (isLoanWrittenOff(loan)) {\n            // update nav with write-off decrease\n            latestNAV = secureSub(\n                latestNAV,\n                rmul(amount, toUint128(writeOffGroups[loanRates[loan] - WRITEOFF_RATE_GROUP_START].percentage))\n            );\n            decDebt(loan, amount);\n            return amount;\n        }\n        uint256 _debt = safeSub(_currentDebt, amount); // Remaining\n        uint256 preFV = futureValue(nftID_);\n        // in case of partial repayment, compute the fv of the remaining debt and add to the according fv bucket\n        uint256 fv = 0;\n        uint256 fvDecrease = preFV;\n        if (_debt != 0) {\n            Rate memory _rate = rates[loanRates[loan]];\n            ILoanRegistry.LoanEntry memory loanEntry = registry.getLoanRegistry().getEntry(nftID_);\n            fv = calcFutureValue(\n                _rate.ratePerSecond,\n                _debt,\n                maturityDate_,\n                recoveryRatePD(loanEntry.riskScore, loanEntry.expirationTimestamp - loanEntry.issuanceBlockTimestamp)\n            );\n            if (preFV >= fv) {\n                fvDecrease = safeSub(preFV, fv);\n            } else {\n                fvDecrease = 0;\n            }\n        }\n\n        details[nftID_].futureValue = toUint128(fv);\n        // case 2: repayment of a loan before or on maturity date\n        if (maturityDate_ >= nnow) {\n            // remove future value decrease from bucket\n            buckets[maturityDate_] = safeSub(buckets[maturityDate_], fvDecrease);\n            uint256 discountDecrease = calcDiscount(discountRate, fvDecrease, nnow, maturityDate_);\n            latestDiscount = secureSub(latestDiscount, discountDecrease);\n            latestNAV = secureSub(latestNAV, discountDecrease);\n        } else {\n            // case 3: repayment of an overdue loan\n            overdueLoans = safeSub(overdueLoans, fvDecrease);\n            latestNAV = secureSub(latestNAV, fvDecrease);\n        }\n        decDebt(loan, amount);\n        return amount;\n    }\n\n    /// @notice borrowEvent triggers a borrow event for a loan\n    /// @param loan the id of the loan\n    function borrowEvent(uint256 loan, uint256) public virtual auth {\n        uint256 risk_ = risk(nftID(loan));\n\n        // when issued every loan has per default interest rate of risk group 0.\n        // correct interest rate has to be set on first borrow event\n        if (loanRates[loan] != risk_) {\n            // set loan interest rate to the one of the correct risk group\n            setRate(loan, risk_);\n        }\n    }\n\n    /// @notice writeOff writes off a loan if it is overdue\n    /// @param loan the id of the loan\n    function writeOff(uint256 loan) public {\n        require(!loanDetails[loan].authWriteOff, 'only-auth-write-off');\n\n        bytes32 nftID_ = nftID(loan);\n        uint256 maturityDate_ = maturityDate(nftID_);\n        require(maturityDate_ > 0, 'loan-does-not-exist');\n\n        // can not write-off healthy loans\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        ILoanRegistry.LoanEntry memory loanEntry = registry.getLoanRegistry().getEntry(bytes32(loan));\n        RiskScore memory riskParam = getRiskScoreByIdx(loanEntry.riskScore);\n        require(maturityDate_ + riskParam.gracePeriod <= nnow, 'maturity-date-in-the-future');\n        // check the writeoff group based on the amount of days overdue\n        uint256 writeOffGroupIndex_ = currentValidWriteOffGroup(loan);\n\n        if (\n            writeOffGroupIndex_ < type(uint128).max &&\n            loanRates[loan] != WRITEOFF_RATE_GROUP_START + writeOffGroupIndex_\n        ) {\n            _writeOff(loan, writeOffGroupIndex_, nftID_, maturityDate_);\n            emit WriteOff(loan, writeOffGroupIndex_, false);\n        }\n    }\n\n    /// @notice authorized call to write of a loan in a specific writeoff group\n    /// @param loan the id of the loan\n    /// @param writeOffGroupIndex_ the index of the writeoff group\n    function overrideWriteOff(uint256 loan, uint256 writeOffGroupIndex_) public auth {\n        // can not write-off healthy loans\n        bytes32 nftID_ = nftID(loan);\n        uint256 maturityDate_ = maturityDate(nftID_);\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        require(maturityDate_ < nnow, 'maturity-date-in-the-future');\n\n        if (loanDetails[loan].authWriteOff == false) {\n            loanDetails[loan].authWriteOff = true;\n        }\n        _writeOff(loan, writeOffGroupIndex_, nftID_, maturityDate_);\n        emit WriteOff(loan, writeOffGroupIndex_, true);\n    }\n\n    /// @notice internal function for the write off\n    /// @param loan the id of the loan\n    /// @param writeOffGroupIndex_ the index of the writeoff group\n    /// @param nftID_ the nftID of the loan\n    /// @param maturityDate_ the maturity date of the loan\n    function _writeOff(uint256 loan, uint256 writeOffGroupIndex_, bytes32 nftID_, uint256 maturityDate_) internal {\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        // Ensure we have an up to date NAV\n        if (nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n\n        uint256 latestNAV_ = latestNAV;\n\n        // first time written-off\n        if (isLoanWrittenOff(loan) == false) {\n            uint256 fv = futureValue(nftID_);\n            if (uniqueDayTimestamp(lastNAVUpdate) > maturityDate_) {\n                // write off after the maturity date\n                overdueLoans = secureSub(overdueLoans, fv);\n                latestNAV_ = secureSub(latestNAV_, fv);\n            } else {\n                // write off before or on the maturity date\n                buckets[maturityDate_] = safeSub(buckets[maturityDate_], fv);\n                uint256 pv = rmul(fv, rpow(discountRate, safeSub(uniqueDayTimestamp(maturityDate_), nnow), ONE));\n                latestDiscount = secureSub(latestDiscount, pv);\n                latestNAV_ = secureSub(latestNAV_, pv);\n            }\n        }\n\n        changeRate(loan, WRITEOFF_RATE_GROUP_START + writeOffGroupIndex_);\n        latestNAV = safeAdd(latestNAV_, rmul(debt(loan), writeOffGroups[writeOffGroupIndex_].percentage));\n    }\n\n    /// @notice returns if a loan is written off\n    /// @param loan the id of the loan\n    function isLoanWrittenOff(uint256 loan) public view returns (bool) {\n        return loanRates[loan] >= WRITEOFF_RATE_GROUP_START;\n    }\n\n    /// @notice calculates and returns the current NAV\n    /// @return nav_ current NAV\n    function currentNAV() public view returns (uint256 nav_) {\n        (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) = currentPVs();\n        return safeAdd(totalDiscount, safeAdd(overdue, writeOffs));\n    }\n\n    /// @notice calculates the present value of the loans together with overdue and written off loans\n    /// @return totalDiscount the present value of the loans\n    /// @return overdue the present value of the overdue loans\n    /// @return writeOffs the present value of the written off loans\n    function currentPVs() public view returns (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) {\n        if (latestDiscount == 0) {\n            // all loans are overdue or writtenOff\n            return (0, overdueLoans, currentWriteOffs());\n        }\n\n        uint256 errPV = 0;\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n\n        // find all new overdue loans since the last update\n        // calculate the discount of the overdue loans which is needed\n        // for the total discount calculation\n        for (uint256 i = lastNAVUpdate; i < nnow; i = i + 1 days) {\n            uint256 b = buckets[i];\n            if (b != 0) {\n                errPV = safeAdd(errPV, rmul(b, rpow(discountRate, safeSub(nnow, i), ONE)));\n                overdue = safeAdd(overdue, b);\n            }\n        }\n\n        return (\n            // calculate current totalDiscount based on the previous totalDiscount (optimized calculation)\n            // the overdue loans are incorrectly in this new result with their current PV and need to be removed\n            secureSub(rmul(latestDiscount, rpow(discountRate, safeSub(nnow, lastNAVUpdate), ONE)), errPV),\n            // current overdue loans not written off\n            safeAdd(overdueLoans, overdue),\n            // current write-offs loans\n            currentWriteOffs()\n        );\n    }\n\n    /// @notice returns the sum of all write off loans\n    /// @return sum of all write off loans\n    function currentWriteOffs() public view returns (uint256 sum) {\n        for (uint256 i = 0; i < writeOffGroups.length; i++) {\n            // multiply writeOffGroupDebt with the writeOff rate\n\n            sum = safeAdd(sum, rmul(rateDebt(WRITEOFF_RATE_GROUP_START + i), uint256(writeOffGroups[i].percentage)));\n        }\n        return sum;\n    }\n\n    /// @notice calculates and returns the current NAV and updates the state\n    /// @return nav_ current NAV\n    function calcUpdateNAV() public returns (uint256 nav_) {\n        (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) = currentPVs();\n\n        overdueLoans = overdue;\n        latestDiscount = totalDiscount;\n\n        latestNAV = safeAdd(safeAdd(totalDiscount, overdue), writeOffs);\n        lastNAVUpdate = uniqueDayTimestamp(block.timestamp);\n        return latestNAV;\n    }\n\n    /// @notice re-calculates the nav in a non-optimized way\n    ///  the method is not updating the NAV to latest block.timestamp\n    /// @return nav_ current NAV\n    function reCalcNAV() public returns (uint256 nav_) {\n        uint256 latestDiscount_ = reCalcTotalDiscount();\n\n        latestNAV = safeAdd(latestDiscount_, safeSub(latestNAV, latestDiscount));\n        latestDiscount = latestDiscount_;\n        return latestNAV;\n    }\n\n    /// @notice re-calculates the totalDiscount in a non-optimized way based on lastNAVUpdate\n    /// @return latestDiscount_ returns the total discount of the active loans\n    function reCalcTotalDiscount() public view returns (uint256 latestDiscount_) {\n        latestDiscount_ = 0;\n\n        for (uint256 loanID = 1; loanID < loanCount; loanID++) {\n            bytes32 nftID_ = nftID(loanID);\n            uint256 maturityDate_ = maturityDate(nftID_);\n\n            if (maturityDate_ < lastNAVUpdate) {\n                continue;\n            }\n\n            latestDiscount_ = safeAdd(\n                latestDiscount_,\n                calcDiscount(discountRate, futureValue(nftID_), lastNAVUpdate, maturityDate_)\n            );\n        }\n        return latestDiscount_;\n    }\n\n    /// @notice update the value (apprasial) of the collateral NFT\n    function update(bytes32 nftID_, uint256 value) public auth {\n        // switch of collateral risk group results in new: ceiling, threshold for existing loan\n        details[nftID_].nftValues = toUint128(value);\n    }\n\n    /// @notice updates the risk group of active loans (borrowed and unborrowed loans)\n    /// @param nftID_ the nftID of the loan\n    /// @param risk_ the new value appraisal of the collateral NFT\n    /// @param risk_ the new risk group\n    function update(bytes32 nftID_, uint256 value, uint256 risk_) public auth {\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        details[nftID_].nftValues = toUint128(value);\n\n        // no change in risk group\n        if (risk_ == risk(nftID_)) {\n            return;\n        }\n\n        details[nftID_].risk = toUint128(risk_);\n\n        // update nav -> latestNAVUpdate = now\n        if (nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n\n        // switch of collateral risk group results in new: ceiling, threshold and interest rate for existing loan\n        // change to new rate interestRate immediately in pile if loan debt exists\n        uint256 loan = uint256(nftID_);\n        if (pie[loan] != 0) {\n            changeRate(loan, risk_);\n        }\n\n        // no currencyAmount borrowed yet\n        if (futureValue(nftID_) == 0) {\n            return;\n        }\n\n        uint256 maturityDate_ = maturityDate(nftID_);\n\n        // Changing the risk group of an nft, might lead to a new interest rate for the dependant loan.\n        // New interest rate leads to a future value.\n        // recalculation required\n        uint256 fvDecrease = futureValue(nftID_);\n        uint256 navDecrease = calcDiscount(discountRate, fvDecrease, nnow, maturityDate_);\n        buckets[maturityDate_] = safeSub(buckets[maturityDate_], fvDecrease);\n        latestDiscount = safeSub(latestDiscount, navDecrease);\n        latestNAV = safeSub(latestNAV, navDecrease);\n\n        // update latest NAV\n        // update latest Discount\n        Rate memory _rate = rates[loanRates[loan]];\n        ILoanRegistry.LoanEntry memory loanEntry = registry.getLoanRegistry().getEntry(bytes32(loan));\n        details[nftID_].futureValue = toUint128(\n            calcFutureValue(\n                _rate.ratePerSecond,\n                debt(loan),\n                maturityDate(nftID_),\n                recoveryRatePD(loanEntry.riskScore, loanEntry.expirationTimestamp - loanEntry.issuanceBlockTimestamp)\n            )\n        );\n\n        uint256 fvIncrease = futureValue(nftID_);\n        uint256 navIncrease = calcDiscount(discountRate, fvIncrease, nnow, maturityDate_);\n        buckets[maturityDate_] = safeAdd(buckets[maturityDate_], fvIncrease);\n        latestDiscount = safeAdd(latestDiscount, navIncrease);\n        latestNAV = safeAdd(latestNAV, navIncrease);\n    }\n\n    /// @notice returns the nftID for the underlying collateral nft\n    /// @param loan the loan id\n    /// @return nftID_ the nftID of the loan\n    function nftID(uint256 loan) public pure returns (bytes32 nftID_) {\n        return bytes32(loan);\n    }\n\n    /// @notice returns true if the present value of a loan is zero\n    /// true if all debt is repaid or debt is 100% written-off\n    /// @param loan the loan id\n    /// @return isZeroPV true if the present value of a loan is zero\n    function zeroPV(uint256 loan) public view returns (bool isZeroPV) {\n        if (debt(loan) == 0) {\n            return true;\n        }\n\n        uint256 rate = loanRates[loan];\n\n        if (rate < WRITEOFF_RATE_GROUP_START) {\n            return false;\n        }\n\n        return writeOffGroups[safeSub(rate, WRITEOFF_RATE_GROUP_START)].percentage == 0;\n    }\n\n    /// @notice returns the current valid write off group of a loan\n    /// @param loan the loan id\n    /// @return writeOffGroup_ the current valid write off group of a loan\n    function currentValidWriteOffGroup(uint256 loan) public view returns (uint256 writeOffGroup_) {\n        bytes32 nftID_ = nftID(loan);\n        uint256 maturityDate_ = maturityDate(nftID_);\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\n        ILoanRegistry.LoanEntry memory loanEntry = registry.getLoanRegistry().getEntry(nftID_);\n        uint8 _loanRiskIndex = loanEntry.riskScore - 1;\n\n        uint128 lastValidWriteOff = type(uint128).max;\n        uint128 highestOverdueDays = 0;\n        // it is not guaranteed that writeOff groups are sorted by overdue days\n        for (uint128 i = 0; i < writeOffGroups.length; i++) {\n            uint128 overdueDays = writeOffGroups[i].overdueDays;\n            if (\n                writeOffGroups[i].riskIndex == _loanRiskIndex &&\n                overdueDays >= highestOverdueDays &&\n                nnow >= maturityDate_ + overdueDays * 1 days\n            ) {\n                lastValidWriteOff = i;\n                highestOverdueDays = overdueDays;\n            }\n        }\n\n        // returns type(uint128).max if no write-off group is valid for this loan\n        return lastValidWriteOff;\n    }\n\n    function incDebt(uint256 loan, uint256 currencyAmount) public auth {\n        uint256 rate = loanRates[loan];\n        require(block.timestamp == rates[rate].lastUpdated, 'rate-group-not-updated');\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = safeAdd(pie[loan], pieAmount);\n        rates[rate].pie = safeAdd(rates[rate].pie, pieAmount);\n\n        emit IncreaseDebt(loan, currencyAmount);\n    }\n\n    function decDebt(uint256 loan, uint256 currencyAmount) private {\n        uint256 rate = loanRates[loan];\n        require(block.timestamp == rates[rate].lastUpdated, 'rate-group-not-updated');\n        uint256 penaltyChi_ = rates[rate].penaltyChi;\n        if (penaltyChi_ > 0) {\n            currencyAmount = toPie(penaltyChi_, currencyAmount);\n        }\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = safeSub(pie[loan], pieAmount);\n        rates[rate].pie = safeSub(rates[rate].pie, pieAmount);\n\n        emit DecreaseDebt(loan, currencyAmount);\n    }\n\n    function debt(uint256 loan) public view returns (uint256 loanDebt) {\n        uint256 rate_ = loanRates[loan];\n        uint256 chi_ = rates[rate_].chi;\n        uint256 penaltyChi_ = rates[rate_].penaltyChi;\n        if (block.timestamp >= rates[rate_].lastUpdated) {\n            chi_ = chargeInterest(rates[rate_].chi, rates[rate_].ratePerSecond, rates[rate_].lastUpdated);\n            penaltyChi_ = chargeInterest(\n                rates[rate_].penaltyChi,\n                rates[rate_].penaltyRatePerSecond,\n                rates[rate_].lastUpdated\n            );\n        }\n\n        if (penaltyChi_ == 0) {\n            return toAmount(chi_, pie[loan]);\n        } else {\n            return toAmount(penaltyChi_, toAmount(chi_, pie[loan]));\n        }\n    }\n\n    function rateDebt(uint256 rate) public view returns (uint256 totalDebt) {\n        uint256 chi_ = rates[rate].chi;\n        uint256 penaltyChi_ = rates[rate].penaltyChi;\n        uint256 pie_ = rates[rate].pie;\n\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            chi_ = chargeInterest(rates[rate].chi, rates[rate].ratePerSecond, rates[rate].lastUpdated);\n            penaltyChi_ = chargeInterest(\n                rates[rate].penaltyChi,\n                rates[rate].penaltyRatePerSecond,\n                rates[rate].lastUpdated\n            );\n        }\n\n        if (penaltyChi_ == 0) {\n            return toAmount(chi_, pie_);\n        } else {\n            return toAmount(penaltyChi_, toAmount(chi_, pie_));\n        }\n    }\n\n    function setRate(uint256 loan, uint256 rate) public auth {\n        require(pie[loan] == 0, 'non-zero-debt');\n        // rate category has to be initiated\n        require(rates[rate].chi != 0, 'rate-group-not-set');\n        loanRates[loan] = rate;\n        emit SetRate(loan, rate);\n    }\n\n    function changeRate(uint256 loan, uint256 newRate) internal {\n        require(rates[newRate].chi != 0, 'rate-group-not-set');\n        if (newRate >= WRITEOFF_RATE_GROUP_START) {\n            rates[newRate].timeStartPenalty = uint48(block.timestamp);\n        }\n        uint256 currentRate = loanRates[loan];\n        drip(currentRate);\n        drip(newRate);\n        uint256 pie_ = pie[loan];\n        uint256 debt_ = toAmount(rates[currentRate].chi, pie_);\n        rates[currentRate].pie = safeSub(rates[currentRate].pie, pie_);\n        pie[loan] = toPie(rates[newRate].chi, debt_);\n        rates[newRate].pie = safeAdd(rates[newRate].pie, pie[loan]);\n        loanRates[loan] = newRate;\n        emit ChangeRate(loan, newRate);\n    }\n\n    function accrue(uint256 loan) public {\n        drip(loanRates[loan]);\n    }\n\n    function drip(uint256 rate) public {\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            (uint256 chi, ) = compounding(\n                rates[rate].chi,\n                rates[rate].ratePerSecond,\n                rates[rate].lastUpdated,\n                rates[rate].pie\n            );\n            rates[rate].chi = chi;\n            if (\n                rates[rate].penaltyRatePerSecond != 0 &&\n                rates[rate].timeStartPenalty != 0 &&\n                block.timestamp >= rates[rate].timeStartPenalty\n            ) {\n                uint lastUpdated_ = rates[rate].lastUpdated > rates[rate].timeStartPenalty\n                    ? rates[rate].lastUpdated\n                    : rates[rate].timeStartPenalty;\n                (uint256 penaltyChi, ) = compounding(\n                    rates[rate].penaltyChi,\n                    rates[rate].penaltyRatePerSecond,\n                    lastUpdated_,\n                    rates[rate].pie\n                );\n                rates[rate].penaltyChi = penaltyChi;\n            }\n            rates[rate].lastUpdated = uint48(block.timestamp);\n        }\n    }\n\n    /// Interest functions\n    // @notice This function provides compounding in seconds\n    // @param chi Accumulated interest rate over time\n    // @param ratePerSecond Interest rate accumulation per second in RAD(1027)\n    // @param lastUpdated When the interest rate was last updated\n    // @param _pie Total sum of all amounts accumulating under one interest rate, divided by that rate\n    // @return The new accumulated rate, as well as the difference between the debt calculated with the old and new accumulated rates.\n    function compounding(uint chi, uint ratePerSecond, uint lastUpdated, uint _pie) public view returns (uint, uint) {\n        require(block.timestamp >= lastUpdated, 'tinlake-math/invalid-timestamp');\n        require(chi != 0);\n        // instead of a interestBearingAmount we use a accumulated interest rate index (chi)\n        uint updatedChi = _chargeInterest(chi, ratePerSecond, lastUpdated, block.timestamp);\n        return (updatedChi, safeSub(rmul(updatedChi, _pie), rmul(chi, _pie)));\n    }\n\n    // @notice This function charge interest on a interestBearingAmount\n    // @param interestBearingAmount is the interest bearing amount\n    // @param ratePerSecond Interest rate accumulation per second in RAD(1027)\n    // @param lastUpdated last time the interest has been charged\n    // @return interestBearingAmount + interest\n    function chargeInterest(\n        uint interestBearingAmount,\n        uint ratePerSecond,\n        uint lastUpdated\n    ) public view returns (uint) {\n        if (block.timestamp >= lastUpdated) {\n            interestBearingAmount = _chargeInterest(interestBearingAmount, ratePerSecond, lastUpdated, block.timestamp);\n        }\n        return interestBearingAmount;\n    }\n\n    function _chargeInterest(\n        uint interestBearingAmount,\n        uint ratePerSecond,\n        uint lastUpdated,\n        uint current\n    ) internal pure returns (uint) {\n        return rmul(rpow(ratePerSecond, current - lastUpdated, ONE), interestBearingAmount);\n    }\n\n    // convert pie to debt/savings amount\n    function toAmount(uint chi, uint _pie) public pure returns (uint) {\n        return rmul(_pie, chi);\n    }\n\n    // convert debt/savings amount to pie\n    function toPie(uint chi, uint amount) public pure returns (uint) {\n        return rdivup(amount, chi);\n    }\n}\n"
    },
    "contracts/protocol/pool/PoolNAVFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IPauseable} from '../../base/IPauseable.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../base/Factory.sol';\nimport '../../libraries/ConfigHelper.sol';\nimport '../../libraries/UntangledMath.sol';\nimport './IPoolNAVFactory.sol';\n\ncontract PoolNAVFactory is UntangledBase, Factory, IPoolNAVFactory {\n    using ConfigHelper for Registry;\n\n    bytes4 constant POOL_NAV_INIT_FUNC_SELECTOR = bytes4(keccak256('initialize(address,address)'));\n\n    Registry public registry;\n\n    address public override poolNAVImplementation;\n\n    function initialize(Registry _registry, address _factoryAdmin) public initializer {\n        __UntangledBase__init(_msgSender());\n        __Factory__init(_factoryAdmin);\n\n        registry = _registry;\n    }\n\n    function setFactoryAdmin(address _factoryAdmin) public onlyAdmin {\n        _setFactoryAdmin(_factoryAdmin);\n    }\n\n    function setPoolNAVImplementation(address newAddress) external onlyAdmin {\n        require(newAddress != address(0), 'PoolNAVFactory: new address cannot be zero');\n        poolNAVImplementation = newAddress;\n        emit UpdatePoolNAVImplementation(newAddress);\n    }\n\n    function createPoolNAV() external override whenNotPaused returns (address) {\n        address pool = _msgSender();\n        bytes memory _initialData = abi.encodeWithSelector(POOL_NAV_INIT_FUNC_SELECTOR, registry, pool);\n        address poolNAV = _deployInstance(poolNAVImplementation, _initialData);\n        return poolNAV;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IPoolNAVFactory).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/protocol/pool/RegistryInjection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\n\ncontract RegistryInjection {\n    // keccak256(abi.encode(uint256(keccak256(\"untangled.storage.RegistryInjection\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant RegistryInjectionStorageLocation =\n        0x5f6bd0daaaf246715f06ec0ea7e99af4468b70381a38e1f10cb19776ed17ce00;\n\n    event UpdateRegistry(address registry);\n\n    /// @custom:storage-location erc7201:untangled.storage.RegistryInjection\n    struct RegistryInjectionStorage {\n        Registry registry;\n    }\n\n    function _getRegistryInjection() private pure returns (RegistryInjectionStorage storage $) {\n        assembly {\n            $.slot := RegistryInjectionStorageLocation\n        }\n    }\n\n    function _setRegistry(Registry _registry) internal {\n        RegistryInjectionStorage storage $ = _getRegistryInjection();\n        $.registry = _registry;\n        emit UpdateRegistry(address(_registry));\n    }\n\n    function registry() public view returns (Registry) {\n        return _getRegistryInjection().registry;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationAccessControl.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\n\nimport {OWNER_ROLE, ORIGINATOR_ROLE} from './types.sol';\n\nimport {ISecuritizationAccessControl} from './ISecuritizationAccessControl.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\nimport {ISecuritizationPoolExtension, SecuritizationPoolExtension} from './SecuritizationPoolExtension.sol';\n\ncontract SecuritizationAccessControl is\n    ERC165Upgradeable,\n    RegistryInjection,\n    ContextUpgradeable,\n    ISecuritizationAccessControl,\n    SecuritizationPoolExtension\n{\n    // keccak256(abi.encode(uint256(keccak256(\"untangled.storage.SecuritizationAccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant SecuritizationAccessControlStorageLocation =\n        0xb38e00afe21f8bf8961a30ad85d453b5f474f19414b8973dee80c89fb0d97b00;\n\n    /// @custom:storage-location erc7201:untangled.storage.SecuritizationAccessControl\n    struct SecuritizationAccessControlStorage {\n        mapping(address => mapping(bytes32 => bool)) roles;\n    }\n\n    function _getSecuritizationAccessControl() private pure returns (SecuritizationAccessControlStorage storage $) {\n        assembly {\n            $.slot := SecuritizationAccessControlStorageLocation\n        }\n    }\n\n    modifier onlyOwner() {\n        address account = _msgSender();\n\n        require(isOwner(account), 'AccessControl: caller is not an owner');\n        _;\n    }\n\n    modifier onlyRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), 'AccessControl: caller is not an originator');\n        _;\n    }\n\n    function installExtension(bytes memory params) public virtual override onlyCallInTargetPool {\n        __SecuritizationAccessControl_init_unchained(_msgSender());\n    }\n\n    function __SecuritizationAccessControl_init_unchained(address _owner) internal {\n        _setRole(OWNER_ROLE, _owner);\n    }\n\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        return $.roles[account][role];\n    }\n\n    function isOwner(address account) public view override returns (bool) {\n        return hasRole(OWNER_ROLE, account);\n    }\n\n    function grantRole(bytes32 role, address account) public virtual override onlyOwner {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = true;\n        emit RoleGranted(role, account, _msgSender());\n    }\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyOwner {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = false;\n        emit RoleRevoked(role, account, _msgSender());\n    }\n\n    function _setRole(bytes32 role, address account) internal virtual {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = true;\n        emit RoleRevoked(role, account, _msgSender());\n    }\n\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = false;\n        emit RoleRevoked(role, account, _msgSender());\n    }\n\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\n        _revokeRole(role, account);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            super.supportsInterface(interfaceId) ||\n            type(ISecuritizationAccessControl).interfaceId == interfaceId ||\n            type(ISecuritizationPoolExtension).interfaceId == interfaceId;\n    }\n\n    function getFunctionSignatures() public view virtual override returns (bytes4[] memory) {\n        bytes4[] memory _functionSignatures = new bytes4[](6);\n\n        _functionSignatures[0] = this.hasRole.selector;\n        _functionSignatures[1] = this.isOwner.selector;\n        _functionSignatures[2] = this.renounceRole.selector;\n        _functionSignatures[3] = this.grantRole.selector;\n        _functionSignatures[4] = this.revokeRole.selector;\n        _functionSignatures[5] = this.supportsInterface.selector;\n\n        return _functionSignatures;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationLockDistribution.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {PausableUpgradeable} from '../../base/PauseableUpgradeable.sol';\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\nimport {ISecuritizationLockDistribution} from './ISecuritizationLockDistribution.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\n\nimport {ISecuritizationPoolExtension, SecuritizationPoolExtension} from './SecuritizationPoolExtension.sol';\nimport {SecuritizationAccessControl} from './SecuritizationAccessControl.sol';\nimport {SecuritizationPoolStorage} from './SecuritizationPoolStorage.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\n// RegistryInjection,\n// ERC165Upgradeable,\n// PausableUpgradeable,\n// SecuritizationPoolStorage,\n// ISecuritizationLockDistribution\n\ncontract SecuritizationLockDistribution is\n    ERC165Upgradeable,\n    RegistryInjection,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    SecuritizationPoolExtension,\n    SecuritizationPoolStorage,\n    SecuritizationAccessControl,\n    ISecuritizationLockDistribution\n{\n    using ConfigHelper for Registry;\n\n    function installExtension(\n        bytes memory params\n    ) public virtual override(ISecuritizationPoolExtension, SecuritizationAccessControl, SecuritizationPoolStorage) onlyCallInTargetPool {}\n\n    function lockedDistributeBalances(address tokenAddress, address investor) public view override returns (uint256) {\n        Storage storage $ = _getStorage();\n        return $.lockedDistributeBalances[tokenAddress][investor];\n    }\n\n    function lockedRedeemBalances(address tokenAddress, address investor) public view override returns (uint256) {\n        Storage storage $ = _getStorage();\n        return $.lockedRedeemBalances[tokenAddress][investor];\n    }\n\n    function totalLockedRedeemBalances(address tokenAddress) public view override returns (uint256) {\n        Storage storage $ = _getStorage();\n        return $.totalLockedRedeemBalances[tokenAddress];\n    }\n\n    function totalLockedDistributeBalance() public view override returns (uint256) {\n        Storage storage $ = _getStorage();\n        return $.totalLockedDistributeBalance;\n    }\n\n    function totalRedeemedCurrency() public view override returns (uint256) {\n        Storage storage $ = _getStorage();\n        return $.totalRedeemedCurrency;\n    }\n\n    // // token address -> user -> locked\n    // mapping(address => mapping(address => uint256)) public override lockedDistributeBalances;\n\n    // uint256 public override totalLockedDistributeBalance;\n\n    // mapping(address => mapping(address => uint256)) public override lockedRedeemBalances;\n    // // token address -> total locked\n    // mapping(address => uint256) public override totalLockedRedeemBalances;\n\n    // uint256 public override totalRedeemedCurrency; // Total $ (cUSD) has been redeemed\n\n    // Increase by value\n    function increaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external override whenNotPaused {\n        registry().requireDistributionOperator(_msgSender());\n\n        Storage storage $ = _getStorage();\n\n        $.lockedDistributeBalances[tokenAddress][investor] =\n            $.lockedDistributeBalances[tokenAddress][investor] +\n            currency;\n        $.lockedRedeemBalances[tokenAddress][investor] = $.lockedRedeemBalances[tokenAddress][investor] + token;\n\n        $.totalLockedDistributeBalance = $.totalLockedDistributeBalance + currency;\n        $.totalLockedRedeemBalances[tokenAddress] = $.totalLockedRedeemBalances[tokenAddress] + token;\n\n        emit UpdateLockedDistributeBalance(\n            tokenAddress,\n            investor,\n            $.lockedDistributeBalances[tokenAddress][investor],\n            $.lockedRedeemBalances[tokenAddress][investor],\n            $.totalLockedRedeemBalances[tokenAddress],\n            $.totalLockedDistributeBalance\n        );\n\n        emit UpdateTotalRedeemedCurrency($.totalRedeemedCurrency, tokenAddress);\n        emit UpdateTotalLockedDistributeBalance($.totalLockedDistributeBalance, tokenAddress);\n    }\n\n    function decreaseLockedDistributeBalance(\n        address tokenAddress,\n        address investor,\n        uint256 currency,\n        uint256 token\n    ) external override whenNotPaused {\n        registry().requireDistributionOperator(_msgSender());\n\n        Storage storage $ = _getStorage();\n\n        $.lockedDistributeBalances[tokenAddress][investor] =\n            $.lockedDistributeBalances[tokenAddress][investor] -\n            currency;\n        $.lockedRedeemBalances[tokenAddress][investor] = $.lockedRedeemBalances[tokenAddress][investor] - token;\n\n        $.totalLockedDistributeBalance = $.totalLockedDistributeBalance - currency;\n        $.totalRedeemedCurrency = $.totalRedeemedCurrency + currency;\n        $.totalLockedRedeemBalances[tokenAddress] = $.totalLockedRedeemBalances[tokenAddress] - token;\n\n        emit UpdateLockedDistributeBalance(\n            tokenAddress,\n            investor,\n            $.lockedDistributeBalances[tokenAddress][investor],\n            $.lockedRedeemBalances[tokenAddress][investor],\n            $.totalLockedRedeemBalances[tokenAddress],\n            $.totalLockedDistributeBalance\n        );\n\n        emit UpdateTotalRedeemedCurrency($.totalRedeemedCurrency, tokenAddress);\n        emit UpdateTotalLockedDistributeBalance($.totalLockedDistributeBalance, tokenAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, SecuritizationAccessControl, SecuritizationPoolStorage)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId) || type(ISecuritizationLockDistribution).interfaceId == interfaceId;\n    }\n\n    function pause() public virtual {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n        _pause();\n    }\n\n    function unpause() public virtual {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n        _unpause();\n    }\n\n    function getFunctionSignatures()\n        public\n        view\n        virtual\n        override(ISecuritizationPoolExtension, SecuritizationAccessControl, SecuritizationPoolStorage)\n        returns (bytes4[] memory)\n    {\n        bytes4[] memory _functionSignatures = new bytes4[](8);\n\n        _functionSignatures[0] = this.totalRedeemedCurrency.selector;\n        _functionSignatures[1] = this.lockedDistributeBalances.selector;\n        _functionSignatures[2] = this.lockedRedeemBalances.selector;\n        _functionSignatures[3] = this.totalLockedRedeemBalances.selector;\n        _functionSignatures[4] = this.totalLockedDistributeBalance.selector;\n        _functionSignatures[5] = this.increaseLockedDistributeBalance.selector;\n        _functionSignatures[6] = this.decreaseLockedDistributeBalance.selector;\n        _functionSignatures[7] = this.supportsInterface.selector;\n\n        return _functionSignatures;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IAccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol';\n\nimport {UntangledBase} from '../../base/UntangledBase.sol';\n\nimport {IRequiresUID} from '../../interfaces/IRequiresUID.sol';\nimport {INoteToken} from '../../interfaces/INoteToken.sol';\n\nimport {Factory2} from '../../base/Factory2.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {INoteTokenFactory} from '../note-sale/fab/INoteTokenFactory.sol';\nimport {ISecuritizationManager} from './ISecuritizationManager.sol';\nimport {ISecuritizationPool} from './ISecuritizationPool.sol';\nimport {ICrowdSale} from '../note-sale/crowdsale/ICrowdSale.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\nimport {POOL_ADMIN} from './types.sol';\nimport {VALIDATOR_ROLE} from '../../tokens/ERC721/types.sol';\nimport {MintedNormalTGE} from '../note-sale/MintedNormalTGE.sol';\nimport {MintedIncreasingInterestTGE} from '../note-sale/MintedIncreasingInterestTGE.sol';\nimport {TokenGenerationEventFactory} from '../note-sale/fab/TokenGenerationEventFactory.sol';\nimport {ITokenGenerationEventFactory} from '../note-sale/fab/ITokenGenerationEventFactory.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\n\nimport {SecuritizationAccessControl} from './SecuritizationAccessControl.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\nabstract contract SecuritizationManagerBase is ISecuritizationManager {\n    Registry public override registry;\n\n    mapping(address => bool) public override isExistingPools;\n    address[] public override pools;\n\n    mapping(address => address) public override potToPool;\n\n    mapping(address => bool) public override isExistingTGEs;\n\n    uint256[44] private __gap;\n}\n\n/// @title SecuritizationManager\n/// @author Untangled Team\n/// @notice You can use this contract for creating new pool, setting up note toke sale, buying note token\ncontract SecuritizationManager is UntangledBase, Factory2, SecuritizationManagerBase, IRequiresUID {\n    using ConfigHelper for Registry;\n\n    event UpdateAllowedUIDTypes(uint256[] uids);\n    //noteSaleAddress, investor, amount, tokenAmount\n    event TokensPurchased(address indexed investor, address indexed tgeAddress, uint256 amount, uint256 tokenAmount);\n    event NoteTokenPurchased(\n        address indexed investor,\n        address indexed tgeAddress,\n        address poolAddress,\n        uint256 amount,\n        uint256 tokenAmount\n    );\n\n    bytes4 public constant POOL_INIT_FUNC_SELECTOR = bytes4(keccak256('initialize(address,bytes)'));\n\n    uint256[] public allowedUIDTypes;\n\n    struct NewRoundSaleParam {\n        uint256 openingTime;\n        uint256 closingTime;\n        uint256 rate;\n        uint256 cap;\n    }\n    struct TGEParam {\n        address issuerTokenController;\n        address pool;\n        uint256 minBidAmount;\n        bool longSale;\n        string ticker;\n        uint8 saleType;\n    }\n\n    struct IncreasingInterestParam {\n        uint32 initialInterest;\n        uint32 finalInterest;\n        uint32 timeInterval;\n        uint32 amountChangeEachInterval;\n    }\n\n    function initialize(Registry _registry, address _factoryAdmin) public reinitializer(2) {\n        __UntangledBase__init(_msgSender());\n        __Factory__init(_factoryAdmin);\n        _setRoleAdmin(POOL_ADMIN, OWNER_ROLE);\n\n        registry = _registry;\n    }\n\n    modifier onlyPoolExisted(address pool) {\n        require(isExistingPools[pool], 'SecuritizationManager: Pool does not exist');\n        _;\n    }\n\n    modifier onlyManager(address pool) {\n        require(\n            // pool.hasRole(pool.OWNER_ROLE(), _msgSender()) ||\n            hasRole(POOL_ADMIN, _msgSender()),\n            'SecuritizationManager: Not the controller of the project'\n        );\n        _;\n    }\n\n    modifier onlyIssuer(address pool) {\n        require(\n            IAccessControlUpgradeable(pool).hasRole(OWNER_ROLE, _msgSender()),\n            'SecuritizationManager: Not the controller of the project'\n        );\n        _;\n    }\n\n    modifier doesSOTExist(address pool) {\n        require(ISecuritizationTGE(pool).sotToken() == address(0), 'SecuritizationManager: Already exists SOT token');\n        _;\n    }\n\n    modifier doesJOTExist(address pool) {\n        require(ISecuritizationTGE(pool).jotToken() == address(0), 'SecuritizationManager: Already exists JOT token');\n        _;\n    }\n\n    function setFactoryAdmin(address _factoryAdmin) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setFactoryAdmin(_factoryAdmin);\n    }\n\n    function getPoolsLength() public view returns (uint256) {\n        return pools.length;\n    }\n\n    /// @notice Creates a new securitization pool\n    /// @param params params data of the securitization pool\n    /// @dev Creates a new instance of a securitization pool. Set msg sender as owner of the new pool\n    function newPoolInstance(\n        bytes32 salt,\n        address poolOwner,\n        bytes memory params\n    ) external whenNotPaused onlyRole(POOL_ADMIN) returns (address) {\n        // impl from eip1987\n        // _implementation\n        address poolImplAddress = address(registry.getSecuritizationPool());\n\n        bytes memory _initialData = abi.encodeWithSelector(POOL_INIT_FUNC_SELECTOR, registry, params);\n\n        address poolAddress = _deployInstance(poolImplAddress, _initialData, salt);\n        SecuritizationAccessControl poolInstance = SecuritizationAccessControl(poolAddress);\n\n        isExistingPools[poolAddress] = true;\n        pools.push(poolAddress);\n\n        poolInstance.grantRole(OWNER_ROLE, poolOwner);\n        poolInstance.renounceRole(OWNER_ROLE, address(this));\n        ISecuritizationTGE(poolAddress).setUpPoolNAV();\n\n        emit NewPoolCreated(poolAddress);\n\n        return poolAddress;\n    }\n\n    /// @inheritdoc ISecuritizationManager\n    function registerPot(address pot) external override whenNotPaused {\n        require(isExistingPools[_msgSender()], 'SecuritizationManager: Only SecuritizationPool');\n        require(potToPool[pot] == address(0), 'SecuritizationManager: pot used for another pool');\n        potToPool[pot] = _msgSender();\n\n        emit UpdatePotToPool(pot, _msgSender());\n    }\n\n    /// @notice sets up the initial token generation event (TGE) for the junior tranche (SOT) of a securitization pool\n    /// @param issuerTokenController who acts as owner of note sale\n    /// @param pool SecuritizationPool address where this sale belongs to\n    /// @param saleType Contains sale type parameter\n    /// @param longSale Define this sale is long sale. Default true\n    /// @param ticker Prefix for note token symbol name. Ex: Saff_SOT\n    function initialTGEForSOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) public onlyManager(pool) returns (address) {\n        return _initialTGEForSOT(issuerTokenController, pool, saleType, longSale, ticker);\n    }\n\n    function _initialTGEForSOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) internal whenNotPaused nonReentrant onlyPoolExisted(pool) doesSOTExist(pool) returns (address) {\n        INoteTokenFactory noteTokenFactory = registry.getNoteTokenFactory();\n        require(address(noteTokenFactory) != address(0), 'Note Token Factory was not registered');\n        require(address(registry.getTokenGenerationEventFactory()) != address(0), 'TGE Factory was not registered');\n\n        address underlyingCurrency = ISecuritizationTGE(pool).underlyingCurrency();\n        address sotToken = noteTokenFactory.createToken(\n            pool,\n            Configuration.NOTE_TOKEN_TYPE.SENIOR,\n            INoteToken(underlyingCurrency).decimals(),\n            ticker\n        );\n        require(sotToken != address(0), 'SOT token must be created');\n\n        address tgeAddress = registry.getTokenGenerationEventFactory().createNewSaleInstance(\n            issuerTokenController,\n            sotToken,\n            underlyingCurrency,\n            saleType,\n            longSale\n        );\n        noteTokenFactory.changeMinterRole(sotToken, tgeAddress);\n\n        ISecuritizationTGE(pool).injectTGEAddress(tgeAddress, Configuration.NOTE_TOKEN_TYPE.SENIOR);\n\n        isExistingTGEs[tgeAddress] = true;\n\n        emit NewTGECreated(tgeAddress);\n        emit NewNotesTokenCreated(sotToken);\n        emit SotDeployed(sotToken, tgeAddress, address(pool));\n        return tgeAddress;\n    }\n\n    /// @notice Sets up the token generation event (TGE) for the senior tranche (SOT) of a securitization pool with additional configuration parameters\n    /// @param increasingInterestParam Increasing interest parameters\n    /// @param tgeParam TGE parameters\n    /// @param saleParam Some parameters for new round token sale. Ex: openingTime, closeTime, totalCap...\n    function setUpTGEForSOT(\n        TGEParam memory tgeParam,\n        NewRoundSaleParam memory saleParam,\n        IncreasingInterestParam memory increasingInterestParam\n    ) public onlyIssuer(tgeParam.pool) {\n        address tgeAddress = _initialTGEForSOT(\n            tgeParam.issuerTokenController,\n            tgeParam.pool,\n            tgeParam.saleType,\n            tgeParam.longSale,\n            tgeParam.ticker\n        );\n        MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAddress);\n        uint8 saleType = tgeParam.saleType;\n        if (saleType == uint8(ITokenGenerationEventFactory.SaleType.MINTED_INCREASING_INTEREST_SOT)) {\n            tge.setInterestRange(\n                increasingInterestParam.initialInterest,\n                increasingInterestParam.finalInterest,\n                increasingInterestParam.timeInterval,\n                increasingInterestParam.amountChangeEachInterval\n            );\n        }\n        tge.startNewRoundSale(saleParam.openingTime, saleParam.closingTime, saleParam.rate, saleParam.cap);\n        tge.setMinBidAmount(tgeParam.minBidAmount);\n    }\n\n    /// @notice sets up the token generation event (TGE) for the junior tranche (JOT) of a securitization pool with additional configuration parameters\n    /// @param tgeParam Parameters for TGE\n    /// @param initialJOTAmount Minimum amount of JOT raised in currency before SOT can start\n    /// @param saleParam Some parameters for new round token sale. Ex: openingTime, closeTime, totalCap...\n    function setUpTGEForJOT(\n        TGEParam memory tgeParam,\n        NewRoundSaleParam memory saleParam,\n        uint256 initialJOTAmount\n    ) public onlyIssuer(tgeParam.pool) {\n        address tgeAddress = _initialTGEForJOT(\n            tgeParam.issuerTokenController,\n            tgeParam.pool,\n            tgeParam.saleType,\n            tgeParam.longSale,\n            tgeParam.ticker\n        );\n        MintedNormalTGE tge = MintedNormalTGE(tgeAddress);\n        tge.startNewRoundSale(saleParam.openingTime, saleParam.closingTime, saleParam.rate, saleParam.cap);\n        tge.setHasStarted(true);\n        tge.setMinBidAmount(tgeParam.minBidAmount);\n        tge.setInitialAmount(initialJOTAmount);\n    }\n\n    function _initialTGEForJOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) public whenNotPaused nonReentrant onlyPoolExisted(pool) doesJOTExist(pool) returns (address) {\n        INoteTokenFactory noteTokenFactory = registry.getNoteTokenFactory();\n        address underlyingCurrency = ISecuritizationTGE(pool).underlyingCurrency();\n        address jotToken = noteTokenFactory.createToken(\n            address(pool),\n            Configuration.NOTE_TOKEN_TYPE.JUNIOR,\n            INoteToken(underlyingCurrency).decimals(),\n            ticker\n        );\n\n        address tgeAddress = registry.getTokenGenerationEventFactory().createNewSaleInstance(\n            issuerTokenController,\n            jotToken,\n            underlyingCurrency,\n            saleType,\n            longSale\n        );\n        noteTokenFactory.changeMinterRole(jotToken, tgeAddress);\n\n        ISecuritizationTGE(pool).injectTGEAddress(tgeAddress, Configuration.NOTE_TOKEN_TYPE.JUNIOR);\n\n        isExistingTGEs[tgeAddress] = true;\n\n        emit NewTGECreated(tgeAddress);\n        emit NewNotesTokenCreated(jotToken);\n        emit JotDeployed(jotToken, tgeAddress, address(pool));\n        return tgeAddress;\n    }\n\n    /// @notice sets up the initial token generation event (TGE) for the junior tranche (JOT) of a securitization pool\n    /// @param issuerTokenController who acts as owner of note sale\n    /// @param pool SecuritizationPool address where this sale belongs to\n    /// @param saleType Contains sale type parameter\n    /// @param longSale Define this sale is long sale. Default true\n    /// @param ticker Prefix for note token symbol name. Ex: Saff_JOT\n    function initialTGEForJOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) public onlyManager(pool) returns (address) {\n        return _initialTGEForJOT(issuerTokenController, pool, saleType, longSale, ticker);\n    }\n\n    /// @notice Investor bid for SOT or JOT token\n    /// @param tgeAddress SOT/JOT token sale instance\n    /// @param currencyAmount Currency amount investor will pay\n    function buyTokens(address tgeAddress, uint256 currencyAmount) external whenNotPaused nonReentrant {\n        require(isExistingTGEs[tgeAddress], 'SMP: Note sale does not exist');\n        require(hasAllowedUID(_msgSender()), 'Unauthorized. Must have correct UID');\n\n        ICrowdSale tge = ICrowdSale(tgeAddress);\n        uint256 tokenAmount = tge.buyTokens(_msgSender(), _msgSender(), currencyAmount);\n        address pool = tge.pool();\n        require(registry.getNoteTokenVault().redeemDisabled(pool) == false, 'SM: Buy token paused');\n\n        if (INoteToken(tge.token()).noteTokenType() == uint8(Configuration.NOTE_TOKEN_TYPE.JUNIOR)) {\n            if (MintedNormalTGE(tgeAddress).currencyRaised() >= MintedNormalTGE(tgeAddress).initialAmount()) {\n                // Currency Raised For JOT > initialJOTAmount => SOT sale start\n                address sotTGEAddress = ISecuritizationPoolStorage(pool).tgeAddress();\n                if (sotTGEAddress != address(0)) {\n                    ICrowdSale(sotTGEAddress).setHasStarted(true);\n                }\n            }\n        }\n\n        ISecuritizationTGE(pool).increaseReserve(currencyAmount);\n        address poolOfPot = registry.getSecuritizationManager().potToPool(_msgSender());\n        if (poolOfPot != address(0)) {\n            ISecuritizationTGE(poolOfPot).decreaseReserve(currencyAmount);\n        }\n\n        emit TokensPurchased(_msgSender(), tgeAddress, currencyAmount, tokenAmount);\n        emit NoteTokenPurchased(_msgSender(), tgeAddress, address(pool), currencyAmount, tokenAmount);\n    }\n\n    function setAllowedUIDTypes(uint256[] calldata ids) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        allowedUIDTypes = ids;\n        emit UpdateAllowedUIDTypes(ids);\n    }\n\n    /// @notice Check if an user has valid UID type\n    function hasAllowedUID(address sender) public view override returns (bool) {\n        return registry.getGo().goOnlyIdTypes(sender, allowedUIDTypes);\n    }\n\n    // function pausePool(address poolAddress) external whenNotPaused nonReentrant onlyRole(POOL_ADMIN) {\n    //     require(isExistingPools[poolAddress], 'SecuritizationManager: pool does not exist');\n    //     ISecuritizationPool pool = ISecuritizationPool(poolAddress);\n    //     pool.pause();\n    // }\n\n    // function unpausePool(address poolAddress) external whenNotPaused nonReentrant onlyRole(POOL_ADMIN) {\n    //     require(isExistingPools[poolAddress], 'SecuritizationManager: pool does not exist');\n    //     ISecuritizationPool pool = ISecuritizationPool(poolAddress);\n    //     pool.unpause();\n    // }\n\n    // function pauseAllPools() external whenNotPaused nonReentrant onlyRole(POOL_ADMIN) {\n    //     uint256 poolsLength = pools.length;\n    //     for (uint256 i = 0; i < poolsLength; i = UntangledMath.uncheckedInc(i)) {\n    //         pools[i].pause();\n    //     }\n    // }\n\n    // function unpauseAllPools() external whenNotPaused nonReentrant onlyRole(POOL_ADMIN) {\n    //     uint256 poolsLength = pools.length;\n    //     for (uint256 i = 0; i < poolsLength; i = UntangledMath.uncheckedInc(i)) {\n    //         pools[i].unpause();\n    //     }\n    // }\n\n    function registerValidator(address validator) public onlyRole(POOL_ADMIN) {\n        require(validator != address(0), 'SecuritizationManager: Invalid validator address');\n        IAccessControlUpgradeable(address(registry.getLoanAssetToken())).grantRole(VALIDATOR_ROLE, validator);\n    }\n\n    function unregisterValidator(address validator) public onlyRole(POOL_ADMIN) {\n        IAccessControlUpgradeable(address(registry.getLoanAssetToken())).revokeRole(VALIDATOR_ROLE, validator);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC165CheckerUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol';\nimport {StringsUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol';\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {POOL_ADMIN, ORIGINATOR_ROLE, RATE_SCALING_FACTOR} from './types.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {ISecuritizationPoolExtension} from './SecuritizationPoolExtension.sol';\nimport {StorageSlot} from '@openzeppelin/contracts/utils/StorageSlot.sol';\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Main entry point for senior LPs (a.k.a. capital providers)\n *  Automatically invests across borrower pools using an adjustable strategy.\n * @author Untangled Team\n */\n// is\n// RegistryInjection,\n// SecuritizationAccessControl,\n// SecuritizationPoolStorage,\n// SecuritizationTGE,\n// SecuritizationPoolAsset,\n// SecuritizationLockDistribution\ncontract SecuritizationPool is Initializable, RegistryInjection, ERC165Upgradeable {\n    using ConfigHelper for Registry;\n    using AddressUpgradeable for address;\n    using ERC165CheckerUpgradeable for address;\n\n    address public original;\n\n    address[] public extensions;\n    mapping(bytes4 => address) public delegates;\n    mapping(address => bytes4[]) public extensionSignatures;\n\n    function extensionsLength() public view returns (uint256) {\n        return extensions.length;\n    }\n\n    modifier onlyCallInOriginal() {\n        require(original == address(this), 'Only call in original contract');\n        _;\n    }\n\n    constructor() {\n        original = address(this); // default original\n    }\n\n    function registerExtension(address ext) public onlyCallInOriginal {\n        _registerExtension(ext);\n    }\n\n    function _registerExtension(address ext) internal {\n        extensions.push(ext);\n\n        bytes4[] memory signatures = ISecuritizationPoolExtension(ext).getFunctionSignatures();\n        for (uint i = 0; i < signatures.length; i++) {\n            delegates[signatures[i]] = ext;\n        }\n\n        extensionSignatures[ext] = signatures;\n    }\n\n    function _installExtension(address ext, bytes memory data) internal {\n        // function installExtension(bytes)\n        ext.functionDelegateCall(abi.encodeWithSelector(0x326cd970, data));\n    }\n\n    // bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        // EIP 1967\n        return StorageSlot.getAddressSlot(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc).value;\n    }\n\n    /** CONSTRUCTOR */\n    function initialize(Registry registry_, bytes memory params) public initializer {\n        __ERC165_init_unchained();\n\n        address poolImpl = address(_getImplementation());\n        require(poolImpl != address(0), 'SecuritizationPool: No pool implementation');\n        original = poolImpl;\n\n        ISecuritizationPoolStorage.NewPoolParams memory newPoolParams = abi.decode(\n            params,\n            (ISecuritizationPoolStorage.NewPoolParams)\n        );\n\n        require(\n            newPoolParams.minFirstLossCushion <= 100 * RATE_SCALING_FACTOR,\n            'minFirstLossCushion is greater than 100'\n        );\n        require(newPoolParams.currency != address(0), 'SecuritizationPool: Invalid currency');\n\n        _setRegistry(registry_);\n\n        uint256 exLength = SecuritizationPool(payable(original)).extensionsLength();\n\n        for (uint i = 0; i < exLength; ++i) {\n            address ext = SecuritizationPool(payable(original)).extensions(i);\n            _installExtension(ext, params);\n        }\n    }\n\n    fallback() external payable {\n        address delegate = SecuritizationPool(payable(original)).delegates(msg.sig);\n\n        require(\n            delegate != address(0),\n            string(\n                abi.encodePacked(\n                    'Can not delegate call to ',\n                    StringsUpgradeable.toHexString(delegate),\n                    ' with method ',\n                    StringsUpgradeable.toHexString(uint32(msg.sig), 32)\n                )\n            )\n        );\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), delegate, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        uint256 length = SecuritizationPool(payable(original)).extensionsLength();\n\n        for (uint i = 0; i < length; ++i) {\n            if (SecuritizationPool(payable(original)).extensions(i).supportsInterface(interfaceId)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // function pause() public override(SecuritizationLockDistribution, SecuritizationPoolAsset, SecuritizationTGE) {\n    //     SecuritizationTGE.pause();\n    // }\n\n    // function unpause() public override(SecuritizationLockDistribution, SecuritizationPoolAsset, SecuritizationTGE) {\n    //     SecuritizationTGE.unpause();\n    // }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPoolAsset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {AccessControlEnumerableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\nimport {ERC20BurnableUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol';\nimport {IERC721ReceiverUpgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol';\nimport {IAccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport {PausableUpgradeable} from '../../base/PauseableUpgradeable.sol';\nimport {IUntangledERC721} from '../../interfaces/IUntangledERC721.sol';\nimport {INoteToken} from '../../interfaces/INoteToken.sol';\nimport {ICrowdSale} from '../note-sale/crowdsale/ICrowdSale.sol';\n\nimport {ISecuritizationPool} from './ISecuritizationPool.sol';\nimport {ISecuritizationPoolValueService} from './ISecuritizationPoolValueService.sol';\n\nimport {MintedIncreasingInterestTGE} from '../note-sale/MintedIncreasingInterestTGE.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {FinalizableCrowdsale} from './../note-sale/crowdsale/FinalizableCrowdsale.sol';\nimport {POOL_ADMIN, ORIGINATOR_ROLE, RATE_SCALING_FACTOR} from './types.sol';\n\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\nimport {ISecuritizationLockDistribution} from './ISecuritizationLockDistribution.sol';\nimport {SecuritizationLockDistribution} from './SecuritizationLockDistribution.sol';\nimport {SecuritizationTGE} from './SecuritizationTGE.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\n\nimport {SecuritizationAccessControl} from './SecuritizationAccessControl.sol';\nimport {ISecuritizationAccessControl} from './ISecuritizationAccessControl.sol';\n\nimport {RiskScore} from './base/types.sol';\n\nimport {SecuritizationPoolStorage} from './SecuritizationPoolStorage.sol';\nimport {ISecuritizationPoolExtension, SecuritizationPoolExtension} from './SecuritizationPoolExtension.sol';\nimport {IPoolNAV} from './IPoolNAV.sol';\nimport {IPoolNAVFactory} from './IPoolNAVFactory.sol';\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Main entry point for senior LPs (a.k.a. capital providers)\n *  Automatically invests across borrower pools using an adjustable strategy.\n * @author Untangled Team\n */\ncontract SecuritizationPoolAsset is\n    ERC165Upgradeable,\n    RegistryInjection,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable,\n    ISecuritizationPool,\n    SecuritizationPoolStorage,\n    SecuritizationAccessControl\n{\n    using ConfigHelper for Registry;\n    using AddressUpgradeable for address;\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, SecuritizationAccessControl, SecuritizationPoolStorage)\n        returns (bool)\n    {\n        return\n            super.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC721ReceiverUpgradeable).interfaceId ||\n            interfaceId == type(ISecuritizationPool).interfaceId ||\n            interfaceId == type(ISecuritizationPoolExtension).interfaceId ||\n            interfaceId == type(ISecuritizationAccessControl).interfaceId ||\n            interfaceId == type(ISecuritizationPoolStorage).interfaceId;\n    }\n\n    function installExtension(\n        bytes memory params\n    ) public virtual override(SecuritizationAccessControl, SecuritizationPoolStorage) onlyCallInTargetPool {\n        __SecuritizationPoolAsset_init_unchained(abi.decode(params, (NewPoolParams)));\n    }\n\n    function __SecuritizationPoolAsset_init_unchained(NewPoolParams memory newPoolParams) internal {\n        _getStorage().validatorRequired = newPoolParams.validatorRequired;\n\n        require(\n            IERC20Upgradeable(newPoolParams.currency).approve(pot(), type(uint256).max),\n            'SecuritizationPool: Currency approval failed'\n        );\n        registry().getLoanAssetToken().setApprovalForAll(address(registry().getLoanKernel()), true);\n    }\n\n    /** GETTER */\n    function getNFTAssetsLength() public view override returns (uint256) {\n        return _getStorage().nftAssets.length;\n    }\n\n    function getTokenAssetAddresses() public view override returns (address[] memory) {\n        return _getStorage().tokenAssetAddresses;\n    }\n\n    function getTokenAssetAddressesLength() public view override returns (uint256) {\n        return _getStorage().tokenAssetAddresses.length;\n    }\n\n    function getRiskScoresLength() public view override returns (uint256) {\n        return _getStorage().riskScores.length;\n    }\n\n    /** UTILITY FUNCTION */\n    function _removeNFTAsset(address tokenAddress, uint256 tokenId) private returns (bool) {\n        NFTAsset[] storage _nftAssets = _getStorage().nftAssets;\n        uint256 nftAssetsLength = _nftAssets.length;\n        for (uint256 i = 0; i < nftAssetsLength; i = UntangledMath.uncheckedInc(i)) {\n            if (_nftAssets[i].tokenAddress == tokenAddress && _nftAssets[i].tokenId == tokenId) {\n                // Remove i element from nftAssets\n                _removeNFTAssetIndex(i);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _removeNFTAssetIndex(uint256 indexToRemove) private {\n        NFTAsset[] storage _nftAssets = _getStorage().nftAssets;\n\n        _nftAssets[indexToRemove] = _nftAssets[_nftAssets.length - 1];\n\n        NFTAsset storage nft = _nftAssets[_nftAssets.length - 1];\n        emit RemoveNFTAsset(nft.tokenAddress, nft.tokenId);\n        _nftAssets.pop();\n    }\n\n    function _pushTokenAssetAddress(address tokenAddress) private {\n        Storage storage $ = _getStorage();\n\n        if (!$.existsTokenAssetAddress[tokenAddress]) $.tokenAssetAddresses.push(tokenAddress);\n        $.existsTokenAssetAddress[tokenAddress] = true;\n        emit AddTokenAssetAddress(tokenAddress);\n    }\n\n    function onERC721Received(address, address, uint256 tokenId, bytes memory) external returns (bytes4) {\n        address token = _msgSender();\n        require(\n            token == address(registry().getLoanAssetToken()),\n            'SecuritizationPool: Must be token issued by Untangled'\n        );\n        NFTAsset[] storage _nftAssets = _getStorage().nftAssets;\n        _nftAssets.push(NFTAsset({tokenAddress: token, tokenId: tokenId}));\n        emit InsertNFTAsset(token, tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function setupRiskScores(\n        uint32[] calldata _daysPastDues,\n        uint32[] calldata _ratesAndDefaults,\n        uint32[] calldata _periodsAndWriteOffs\n    ) external override whenNotPaused notClosingStage {\n        registry().requirePoolAdmin(_msgSender());\n\n        uint256 _daysPastDuesLength = _daysPastDues.length;\n        require(\n            _daysPastDuesLength * 6 == _ratesAndDefaults.length &&\n                _daysPastDuesLength * 4 == _periodsAndWriteOffs.length,\n            'SecuritizationPool: Riskscore params length is not equal'\n        );\n\n        Storage storage $ = _getStorage();\n        delete $.riskScores;\n\n        for (uint256 i = 0; i < _daysPastDuesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(\n                i == 0 || _daysPastDues[i] > _daysPastDues[i - 1],\n                'SecuritizationPool: Risk scores must be sorted'\n            );\n            uint32 _interestRate = _ratesAndDefaults[i + _daysPastDuesLength * 2];\n            uint32 _writeOffAfterGracePeriod = _periodsAndWriteOffs[i + _daysPastDuesLength * 2];\n            uint32 _writeOffAfterCollectionPeriod = _periodsAndWriteOffs[i + _daysPastDuesLength * 3];\n            $.riskScores.push(\n                RiskScore({\n                    daysPastDue: _daysPastDues[i],\n                    advanceRate: _ratesAndDefaults[i],\n                    penaltyRate: _ratesAndDefaults[i + _daysPastDuesLength],\n                    interestRate: _interestRate,\n                    probabilityOfDefault: _ratesAndDefaults[i + _daysPastDuesLength * 3],\n                    lossGivenDefault: _ratesAndDefaults[i + _daysPastDuesLength * 4],\n                    discountRate: _ratesAndDefaults[i + _daysPastDuesLength * 5],\n                    gracePeriod: _periodsAndWriteOffs[i],\n                    collectionPeriod: _periodsAndWriteOffs[i + _daysPastDuesLength],\n                    writeOffAfterGracePeriod: _writeOffAfterGracePeriod,\n                    writeOffAfterCollectionPeriod: _periodsAndWriteOffs[i + _daysPastDuesLength * 3]\n                })\n            );\n            IPoolNAV(poolNAV()).file(\n                'writeOffGroup',\n                _interestRate,\n                _writeOffAfterGracePeriod,\n                _periodsAndWriteOffs[i],\n                _ratesAndDefaults[i + _daysPastDuesLength],\n                i\n            );\n            IPoolNAV(poolNAV()).file(\n                'writeOffGroup',\n                _interestRate,\n                _writeOffAfterCollectionPeriod,\n                _periodsAndWriteOffs[i + _daysPastDuesLength],\n                _ratesAndDefaults[i + _daysPastDuesLength],\n                i\n            );\n        }\n\n        // Set discount rate\n        IPoolNAV(poolNAV()).file('discountRate', $.riskScores[0].discountRate);\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function exportAssets(\n        address tokenAddress,\n        address toPoolAddress,\n        uint256[] calldata tokenIds\n    ) external override whenNotPaused nonReentrant notClosingStage {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n\n        uint256 tokenIdsLength = tokenIds.length;\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            require(_removeNFTAsset(tokenAddress, tokenIds[i]), 'SecuritizationPool: Asset does not exist');\n        }\n\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            IUntangledERC721(tokenAddress).safeTransferFrom(address(this), toPoolAddress, tokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function withdrawAssets(\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        address[] calldata recipients\n    ) external override whenNotPaused nonReentrant onlyOwner {\n        uint256 tokenIdsLength = tokenIds.length;\n        require(tokenAddresses.length == tokenIdsLength, 'tokenAddresses length and tokenIds length are not equal');\n        require(\n            tokenAddresses.length == recipients.length,\n            'tokenAddresses length and recipients length are not equal'\n        );\n\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            require(_removeNFTAsset(tokenAddresses[i], tokenIds[i]), 'SecuritizationPool: Asset does not exist');\n        }\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            IUntangledERC721(tokenAddresses[i]).safeTransferFrom(address(this), recipients[i], tokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function collectAssets(uint256[] calldata tokenIds) external override whenNotPaused returns (uint256) {\n        registry().requireLoanKernel(_msgSender());\n        uint256 tokenIdsLength = tokenIds.length;\n        uint256 expectedAssetsValue = 0;\n        for (uint256 i = 0; i < tokenIdsLength; i = UntangledMath.uncheckedInc(i)) {\n            expectedAssetsValue = expectedAssetsValue + IPoolNAV(poolNAV()).addLoan(tokenIds[i]);\n        }\n\n        Storage storage $ = _getStorage();\n\n        if (firstAssetTimestamp() == 0) {\n            $.firstAssetTimestamp = uint64(block.timestamp);\n            _setUpOpeningBlockTimestamp();\n        }\n        if (openingBlockTimestamp() == 0) {\n            // If openingBlockTimestamp is not set\n            _setOpeningBlockTimestamp(openingBlockTimestamp());\n        }\n\n        emit CollectAsset(expectedAssetsValue);\n        return expectedAssetsValue;\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function collectERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata senders,\n        uint256[] calldata amounts\n    ) external override whenNotPaused notClosingStage onlyRole(ORIGINATOR_ROLE) {\n        uint256 tokenAddressesLength = tokenAddresses.length;\n        require(\n            tokenAddressesLength == senders.length && senders.length == amounts.length,\n            'SecuritizationPool: Params length are not equal'\n        );\n\n        // check\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(\n                registry().getNoteTokenFactory().isExistingTokens(tokenAddresses[i]),\n                'SecuritizationPool: unknown-token-address'\n            );\n        }\n\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            _pushTokenAssetAddress(tokenAddresses[i]);\n        }\n\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(\n                IERC20Upgradeable(tokenAddresses[i]).transferFrom(senders[i], address(this), amounts[i]),\n                'SecuritizationPool: Transfer failed'\n            );\n        }\n\n        if (openingBlockTimestamp() == 0) {\n            // If openingBlockTimestamp is not set\n            _setOpeningBlockTimestamp(uint64(block.timestamp));\n        }\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function withdrawERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external override whenNotPaused nonReentrant {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n\n        uint256 tokenAddressesLength = tokenAddresses.length;\n        require(tokenAddressesLength == recipients.length, 'tokenAddresses length and tokenIds length are not equal');\n        require(tokenAddressesLength == amounts.length, 'tokenAddresses length and recipients length are not equal');\n\n        mapping(address => bool) storage existsTokenAssetAddress = _getStorage().existsTokenAssetAddress;\n        for (uint256 i = 0; i < tokenAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            require(existsTokenAssetAddress[tokenAddresses[i]], 'SecuritizationPool: note token asset does not exist');\n            require(\n                IERC20Upgradeable(tokenAddresses[i]).transfer(recipients[i], amounts[i]),\n                'SecuritizationPool: Transfer failed'\n            );\n        }\n    }\n\n    function firstAssetTimestamp() public view returns (uint64) {\n        return _getStorage().firstAssetTimestamp;\n    }\n\n    /// @inheritdoc ISecuritizationPool\n    function setUpOpeningBlockTimestamp() public override whenNotPaused {\n        require(_msgSender() == tgeAddress(), 'SecuritizationPool: Only tge address');\n        _setUpOpeningBlockTimestamp();\n    }\n\n    /// @dev Set the opening block timestamp\n    function _setUpOpeningBlockTimestamp() private {\n        if (tgeAddress() == address(0)) return;\n        uint64 _firstNoteTokenMintedTimestamp = ICrowdSale(tgeAddress()).firstNoteTokenMintedTimestamp();\n        uint64 _firstAssetTimestamp = firstAssetTimestamp();\n        if (_firstNoteTokenMintedTimestamp > 0 && _firstAssetTimestamp > 0) {\n            // Pick the later\n            if (_firstAssetTimestamp > _firstNoteTokenMintedTimestamp) {\n                _setOpeningBlockTimestamp(_firstAssetTimestamp);\n            } else {\n                _setOpeningBlockTimestamp(_firstNoteTokenMintedTimestamp);\n            }\n        }\n\n        emit UpdateOpeningBlockTimestamp(openingBlockTimestamp());\n    }\n\n    function _setOpeningBlockTimestamp(uint64 _openingBlockTimestamp) internal {\n        Storage storage $ = _getStorage();\n        $.openingBlockTimestamp = _openingBlockTimestamp;\n        emit UpdateOpeningBlockTimestamp(_openingBlockTimestamp);\n    }\n\n    function riskScores(uint256 idx) public view virtual override returns (RiskScore memory) {\n        return _getStorage().riskScores[idx];\n    }\n\n    function nftAssets(uint256 idx) public view virtual override returns (NFTAsset memory) {\n        return _getStorage().nftAssets[idx];\n    }\n\n    function tokenAssetAddresses(uint256 idx) public view virtual override returns (address) {\n        return _getStorage().tokenAssetAddresses[idx];\n    }\n\n    function pause() public virtual override {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n        _pause();\n    }\n\n    function unpause() public virtual override {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n        _unpause();\n    }\n\n    function getFunctionSignatures()\n        public\n        view\n        virtual\n        override(SecuritizationAccessControl, SecuritizationPoolStorage)\n        returns (bytes4[] memory)\n    {\n        bytes4[] memory _functionSignatures = new bytes4[](19);\n\n        _functionSignatures[0] = this.getNFTAssetsLength.selector;\n        _functionSignatures[1] = this.getTokenAssetAddresses.selector;\n        _functionSignatures[2] = this.getTokenAssetAddressesLength.selector;\n        _functionSignatures[3] = this.getRiskScoresLength.selector;\n        _functionSignatures[4] = this.riskScores.selector;\n        _functionSignatures[5] = this.setupRiskScores.selector;\n        _functionSignatures[6] = this.exportAssets.selector;\n        _functionSignatures[7] = this.withdrawAssets.selector;\n        _functionSignatures[8] = this.collectAssets.selector;\n        _functionSignatures[9] = this.collectERC20Assets.selector;\n        _functionSignatures[10] = this.withdrawERC20Assets.selector;\n        _functionSignatures[11] = this.nftAssets.selector;\n        _functionSignatures[12] = this.tokenAssetAddresses.selector;\n        _functionSignatures[13] = this.setUpOpeningBlockTimestamp.selector;\n        _functionSignatures[14] = this.supportsInterface.selector;\n        _functionSignatures[15] = this.onERC721Received.selector;\n        _functionSignatures[16] = this.pause.selector;\n        _functionSignatures[17] = this.unpause.selector;\n        _functionSignatures[18] = this.paused.selector;\n\n        return _functionSignatures;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPoolExtension.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\ninterface ISecuritizationPoolLike {\n    function original() external view returns (address);\n}\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Main entry point for senior LPs (a.k.a. capital providers)\n *  Automatically invests across borrower pools using an adjustable strategy.\n * @author Untangled Team\n */\ninterface ISecuritizationPoolExtension {\n    function installExtension(bytes memory params) external;\n\n    function getFunctionSignatures() external view returns (bytes4[] memory);\n}\n\nabstract contract SecuritizationPoolExtension is ISecuritizationPoolExtension {\n    modifier onlyCallInTargetPool() {\n        ISecuritizationPoolLike current = ISecuritizationPoolLike(address(this));\n        // current contract is not poolImpl, => delegate call\n        require(current.original() != address(this), 'Only call in target pool');\n        _;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\n\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\nimport {RiskScore} from './base/types.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\nimport {ISecuritizationPoolExtension, SecuritizationPoolExtension} from './SecuritizationPoolExtension.sol';\n\ncontract SecuritizationPoolStorage is\n    ERC165Upgradeable,\n    RegistryInjection,\n    SecuritizationPoolExtension,\n    ISecuritizationPoolStorage\n{\n    // keccak256(abi.encode(uint256(keccak256(\"untangled.storage.SecuritizationPoolStorage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant StorageLocation = 0x42988f810f621c79bb2e8db2f913a015fc39ef8eac016043863c6a0d12adbf00;\n\n    modifier onlyIssuingTokenStage() {\n        CycleState _state = state();\n        require(_state != CycleState.OPEN && _state != CycleState.CLOSED, 'Not in issuing token stage');\n        _;\n    }\n\n    modifier notClosingStage() {\n        require(!isClosedState(), 'SecuritizationPool: Pool in closed state');\n        _;\n    }\n\n    function _getStorage() internal pure returns (Storage storage $) {\n        assembly {\n            $.slot := StorageLocation\n        }\n    }\n\n    function installExtension(bytes memory params) public virtual override onlyCallInTargetPool {\n        __SecuritizationPoolStorage_init_unchained(abi.decode(params, (NewPoolParams)));\n    }\n\n    function __SecuritizationPoolStorage_init_unchained(NewPoolParams memory _newPoolParams) internal {}\n\n    function tgeAddress() public view virtual override returns (address) {\n        Storage storage $ = _getStorage();\n        return $.tgeAddress;\n    }\n\n    function pot() public view returns (address) {\n        return _getStorage().pot;\n    }\n\n    function amountOwedToOriginator() public view returns (uint256) {\n        return _getStorage().amountOwedToOriginator;\n    }\n\n    function openingBlockTimestamp() public view override returns (uint64) {\n        Storage storage $ = _getStorage();\n        return $.openingBlockTimestamp;\n    }\n\n    function state() public view override returns (CycleState) {\n        return _getStorage().state;\n    }\n\n    /// @notice checks if the contract is in a closed state\n    function isClosedState() public view override returns (bool) {\n        return state() == CycleState.CLOSED;\n    }\n\n    function secondTGEAddress() public view virtual override returns (address) {\n        return _getStorage().secondTGEAddress;\n    }\n\n    function validatorRequired() public view virtual override returns (bool) {\n        return _getStorage().validatorRequired;\n    }\n\n    function poolNAV() public view override returns (address) {\n        return _getStorage().poolNAV;\n    }\n\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            super.supportsInterface(_interfaceId) ||\n            type(ISecuritizationPoolStorage).interfaceId == _interfaceId ||\n            type(ISecuritizationPoolExtension).interfaceId == _interfaceId;\n    }\n\n    function getFunctionSignatures() public view virtual override returns (bytes4[] memory) {\n        bytes4[] memory _functionSignatures = new bytes4[](10);\n\n        _functionSignatures[0] = this.amountOwedToOriginator.selector;\n        _functionSignatures[1] = this.tgeAddress.selector;\n        _functionSignatures[2] = this.secondTGEAddress.selector;\n        _functionSignatures[3] = this.state.selector;\n        _functionSignatures[4] = this.isClosedState.selector;\n        _functionSignatures[5] = this.pot.selector;\n        _functionSignatures[6] = this.validatorRequired.selector;\n        _functionSignatures[7] = this.openingBlockTimestamp.selector;\n        _functionSignatures[8] = this.poolNAV.selector;\n        _functionSignatures[9] = this.supportsInterface.selector;\n\n        return _functionSignatures;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\nimport {IERC20MetadataUpgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol';\n\nimport {INoteToken} from '../../interfaces/INoteToken.sol';\nimport {IUntangledERC721} from '../../interfaces/IUntangledERC721.sol';\nimport {ICrowdSale} from '../../interfaces/ICrowdSale.sol';\nimport {ILoanRegistry} from '../../interfaces/ILoanRegistry.sol';\n\nimport {ISecuritizationPool} from './ISecuritizationPool.sol';\nimport {ISecuritizationPoolValueService} from './ISecuritizationPoolValueService.sol';\nimport {IDistributionAssessor} from './IDistributionAssessor.sol';\n\nimport {NAVCalculation} from './base/NAVCalculation.sol';\nimport {SecuritizationPoolServiceBase} from './base/SecuritizationPoolServiceBase.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\nimport {IPoolNAV} from './IPoolNAV.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\n\nimport {RiskScore} from './base/types.sol';\n\n/// @title SecuritizationPoolValueService\n/// @author Untangled Team\n/// @dev Calculate pool's values\ncontract SecuritizationPoolValueService is\n    SecuritizationPoolServiceBase,\n    NAVCalculation,\n    ISecuritizationPoolValueService\n{\n    using ConfigHelper for Registry;\n\n    uint256 public constant RATE_SCALING_FACTOR = 10 ** 4;\n\n    function getPresentValueWithNAVCalculation(\n        address poolAddress,\n        uint256 principalAmount,\n        uint256 expectTimeEarnInterest,\n        uint256 interestRate,\n        uint256 riskScoreIdx, // riskScoreIdx should be reduced 1 to be able to use because 0 means no specific riskScore\n        uint256 overdue,\n        uint256 secondTillCashFlow\n    ) private view returns (uint256) {\n        uint256 riskScoresLength = ISecuritizationPool(poolAddress).getRiskScoresLength();\n        bool hasValidRiskScore = riskScoresLength > 0;\n        if (hasValidRiskScore) {\n            if (riskScoreIdx == 0) (hasValidRiskScore, riskScoreIdx) = getAssetRiskScoreIdx(poolAddress, overdue);\n            else riskScoreIdx = riskScoreIdx > riskScoresLength ? riskScoresLength - 1 : riskScoreIdx - 1;\n        }\n        if (!hasValidRiskScore) {\n            return\n                (principalAmount *\n                    UntangledMath.rpow(\n                        UntangledMath.ONE +\n                            ((interestRate * UntangledMath.ONE) / INTEREST_RATE_SCALING_FACTOR_PERCENT / 100) /\n                            YEAR_LENGTH_IN_SECONDS,\n                        expectTimeEarnInterest,\n                        UntangledMath.ONE\n                    )) / UntangledMath.ONE;\n        }\n        RiskScore memory riskscore = ISecuritizationPool(poolAddress).riskScores(riskScoreIdx);\n        uint256 result = _calculateAssetValue(\n            principalAmount,\n            expectTimeEarnInterest,\n            interestRate,\n            overdue,\n            secondTillCashFlow,\n            riskscore\n        );\n        return result;\n    }\n\n    function getAssetInterestRate(\n        address poolAddress,\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view returns (uint256) {\n        IUntangledERC721 loanAssetToken = IUntangledERC721(tokenAddress);\n        uint256 interestRate = loanAssetToken.getInterestRate(tokenId);\n\n        uint256 riskScoresLength = ISecuritizationPool(poolAddress).getRiskScoresLength();\n\n        bool hasValidRiskScore = riskScoresLength > 0;\n        if (hasValidRiskScore) {\n            uint256 riskScoreIdx = loanAssetToken.getRiskScore(tokenId);\n\n            if (riskScoreIdx == 0) {\n                uint256 expirationTimestamp = loanAssetToken.getExpirationTimestamp(tokenId);\n                uint256 overdue = timestamp > expirationTimestamp ? timestamp - expirationTimestamp : 0;\n                (hasValidRiskScore, riskScoreIdx) = getAssetRiskScoreIdx(poolAddress, overdue);\n            } else riskScoreIdx = riskScoreIdx > riskScoresLength ? riskScoresLength - 1 : riskScoreIdx - 1;\n\n            if (hasValidRiskScore) {\n                RiskScore memory riskscore = ISecuritizationPool(poolAddress).riskScores(riskScoreIdx);\n                return riskscore.interestRate;\n            }\n        }\n\n        return interestRate;\n    }\n\n    function getAssetInterestRates(\n        address poolAddress,\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        uint256 timestamp\n    ) external view returns (uint256[] memory) {\n        uint256 tokenIdsLength = tokenIds.length;\n        uint256[] memory interestRates = new uint256[](tokenIdsLength);\n        for (uint256 i; i < tokenIdsLength; i++) {\n            interestRates[i] = getAssetInterestRate(poolAddress, tokenAddresses[i], tokenIds[i], timestamp);\n        }\n        return interestRates;\n    }\n\n    function getExpectedLATAssetValue(address poolAddress) public view returns(uint256) {\n        return IPoolNAV(ISecuritizationPoolStorage(poolAddress).poolNAV()).currentNAV();\n    }\n\n    function getExpectedERC20AssetValue(\n        address poolAddress,\n        address assetPoolAddress,\n        address tokenAddress,\n        uint256 interestRate,\n        uint256 timestamp\n    ) public view returns (uint256) {\n        uint256 expirationTimestamp = ISecuritizationPoolStorage(assetPoolAddress).openingBlockTimestamp() +\n            ISecuritizationTGE(assetPoolAddress).termLengthInSeconds();\n\n        uint256 overdue = timestamp > expirationTimestamp ? timestamp - expirationTimestamp : 0;\n        uint256 secondTillCashflow = expirationTimestamp > timestamp ? expirationTimestamp - timestamp : 0;\n\n        uint256 totalDebt = registry.getDistributionAssessor().calcCorrespondingTotalAssetValue(\n            tokenAddress,\n            poolAddress\n        );\n\n        uint256 presentValue = getPresentValueWithNAVCalculation(\n            poolAddress,\n            totalDebt,\n            0,\n            interestRate,\n            0,\n            overdue,\n            secondTillCashflow\n        );\n\n        if (timestamp < expirationTimestamp) {\n            totalDebt = registry.getDistributionAssessor().calcCorrespondingTotalAssetValue(tokenAddress, poolAddress);\n        }\n\n        return presentValue < totalDebt ? presentValue : totalDebt;\n    }\n\n    /// @inheritdoc ISecuritizationPoolValueService\n    function getExpectedAssetsValue(\n        address poolAddress,\n        uint256 timestamp\n    ) external view returns (uint256 expectedAssetsValue) {\n        expectedAssetsValue = 0;\n        ISecuritizationPool securitizationPool = ISecuritizationPool(poolAddress);\n\n        expectedAssetsValue =\n            expectedAssetsValue + IPoolNAV(ISecuritizationPoolStorage(poolAddress).poolNAV()).currentNAV();\n\n        uint256 tokenAssetAddressesLength = securitizationPool.getTokenAssetAddressesLength();\n        for (uint256 i = 0; i < tokenAssetAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            address tokenAddress = securitizationPool.tokenAssetAddresses(i);\n            INoteToken notesToken = INoteToken(tokenAddress);\n            if (notesToken.balanceOf(poolAddress) > 0) {\n                expectedAssetsValue =\n                    expectedAssetsValue +\n                    getExpectedERC20AssetValue(\n                        poolAddress,\n                        notesToken.poolAddress(),\n                        tokenAddress,\n                        Configuration.NOTE_TOKEN_TYPE(notesToken.noteTokenType()) ==\n                            Configuration.NOTE_TOKEN_TYPE.SENIOR\n                            ? ISecuritizationTGE(notesToken.poolAddress()).interestRateSOT()\n                            : 0,\n                        timestamp\n                    );\n            }\n        }\n    }\n\n    function getAssetRiskScoreIdx(\n        address poolAddress,\n        uint256 overdue\n    ) public view returns (bool hasValidRiskScore, uint256 riskScoreIdx) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(poolAddress);\n        uint256 riskScoresLength = securitizationPool.getRiskScoresLength();\n        for (riskScoreIdx = 0; riskScoreIdx < riskScoresLength; riskScoreIdx++) {\n            uint32 daysPastDue = getDaysPastDueByIdx(securitizationPool, riskScoreIdx);\n            if (overdue < daysPastDue) return (false, 0);\n            else if (riskScoreIdx == riskScoresLength - 1) {\n                return (true, riskScoreIdx);\n            } else {\n                uint32 nextDaysPastDue = getDaysPastDueByIdx(securitizationPool, riskScoreIdx + 1);\n                if (overdue < nextDaysPastDue) return (true, riskScoreIdx);\n            }\n        }\n    }\n\n    function getDaysPastDueByIdx(ISecuritizationPool securitizationPool, uint256 idx) private view returns (uint32) {\n        // (uint32 daysPastDue, , , , , , , , , , ) = securitizationPool.riskScores(idx);\n        return securitizationPool.riskScores(idx).daysPastDue;\n    }\n\n    /// @inheritdoc ISecuritizationPoolValueService\n    function getOutstandingPrincipalCurrencyByInvestor(address pool, address investor) public view returns (uint256) {\n        ISecuritizationPoolStorage securitizationPool = ISecuritizationPoolStorage(pool);\n        ICrowdSale crowdsale = ICrowdSale(securitizationPool.tgeAddress());\n\n        return\n            crowdsale.currencyRaisedByInvestor(investor) -\n            ISecuritizationTGE(pool).paidPrincipalAmountSOTByInvestor(investor);\n    }\n\n    function getPoolValue(address poolAddress) external view returns (uint256) {\n        ISecuritizationPool securitizationPool = ISecuritizationPool(poolAddress);\n        require(address(securitizationPool) != address(0), 'Pool was not deployed');\n        uint256 currentTimestamp = block.timestamp;\n        uint256 nAVpoolValue = this.getExpectedAssetsValue(poolAddress, currentTimestamp);\n\n        // use reserve variable instead\n        uint256 balancePool = ISecuritizationTGE(poolAddress).reserve();\n        uint256 poolValue = balancePool +\n            nAVpoolValue -\n            ISecuritizationPoolStorage(poolAddress).amountOwedToOriginator();\n\n        return poolValue;\n    }\n\n    // @notice this function return value 90 in example\n    function getBeginningSeniorAsset(address poolAddress) external view returns (uint256) {\n        require(poolAddress != address(0), 'Invalid pool address');\n        ISecuritizationTGE securitizationPool = ISecuritizationTGE(poolAddress);\n        address sotToken = securitizationPool.sotToken();\n        require(sotToken != address(0), 'Invalid sot address');\n        uint256 tokenSupply = INoteToken(sotToken).totalSupply();\n        uint256 tokenDecimals = INoteToken(sotToken).decimals();\n        return\n            tokenSupply *\n            10 ** (IERC20MetadataUpgradeable(securitizationPool.underlyingCurrency()).decimals() - tokenDecimals);\n    }\n\n    // @notice this function will return 72 in example\n    function getBeginningSeniorDebt(address poolAddress) external view returns (uint256) {\n        uint256 poolValue = this.getPoolValue(poolAddress);\n        if (poolValue == 0) return 0;\n        // require(poolValue > 0, 'Pool value is 0');\n        uint256 beginningSeniorAsset = this.getBeginningSeniorAsset(poolAddress);\n        uint256 currentTimestamp = block.timestamp;\n        uint256 nAVpoolValue = this.getExpectedAssetsValue(poolAddress, currentTimestamp);\n        if (nAVpoolValue > poolValue) {\n            return beginningSeniorAsset;\n        }\n        return (beginningSeniorAsset * nAVpoolValue) / poolValue;\n    }\n\n    // @notice get beginning of senior debt, get interest of this debt over number of interval\n    function getSeniorDebt(address poolAddress) external view returns (uint256) {\n        uint256 beginningSeniorDebt = this.getBeginningSeniorDebt(poolAddress);\n        if (beginningSeniorDebt == 0) return 0;\n        ISecuritizationPoolStorage securitizationPool = ISecuritizationPoolStorage(poolAddress);\n        require(address(securitizationPool) != address(0), 'Pool was not deployed');\n        uint256 seniorInterestRate = ISecuritizationTGE(poolAddress).interestRateSOT();\n        uint256 openingTime = securitizationPool.openingBlockTimestamp();\n        uint256 compoundingPeriods = block.timestamp - openingTime;\n        uint256 oneYearInSeconds = NAVCalculation.YEAR_LENGTH_IN_SECONDS;\n\n        uint256 seniorDebt = beginningSeniorDebt +\n            (beginningSeniorDebt * seniorInterestRate * compoundingPeriods) /\n            (RATE_SCALING_FACTOR * oneYearInSeconds);\n        return seniorDebt;\n    }\n\n    // @notice get beginning senior asset, then calculate ratio reserve on pools.Finaly multiple them\n    function getSeniorBalance(address poolAddress) external view returns (uint256) {\n        return this.getBeginningSeniorAsset(poolAddress) - this.getBeginningSeniorDebt(poolAddress);\n    }\n\n    /// @inheritdoc ISecuritizationPoolValueService\n    function getSeniorAsset(address poolAddress) external view returns (uint256) {\n        // we need to change this value with interest rate by time\n        uint256 seniorAsset;\n        uint256 poolValue = this.getPoolValue(poolAddress);\n        uint256 expectedSeniorAsset = this.getExpectedSeniorAssets(poolAddress);\n\n        if (poolValue > expectedSeniorAsset) {\n            seniorAsset = expectedSeniorAsset;\n        } else {\n            // case of default\n            seniorAsset = poolValue;\n        }\n\n        return seniorAsset;\n    }\n\n    /// @inheritdoc ISecuritizationPoolValueService\n    function getJuniorAsset(address poolAddress) external view returns (uint256) {\n        uint256 poolValue = this.getPoolValue(poolAddress);\n        uint256 seniorAsset = this.getSeniorAsset(poolAddress);\n        uint256 juniorAsset = 0;\n        if (poolValue >= seniorAsset) {\n            juniorAsset = poolValue - seniorAsset;\n        }\n\n        return juniorAsset;\n    }\n\n    /// @inheritdoc ISecuritizationPoolValueService\n    function getJuniorRatio(address poolAddress) external view returns (uint256) {\n        uint256 rateSenior = this.getSeniorRatio(poolAddress);\n        require(rateSenior <= 100 * RATE_SCALING_FACTOR, 'securitizationPool.rateSenior >100');\n\n        return 100 * RATE_SCALING_FACTOR - rateSenior;\n    }\n\n    function getSeniorRatio(address poolAddress) external view returns (uint256) {\n        uint256 seniorAsset = this.getSeniorAsset(poolAddress);\n        uint256 poolValue = this.getPoolValue(poolAddress);\n        if (poolValue == 0) {\n            return 0;\n        }\n\n        return (seniorAsset * 100 * RATE_SCALING_FACTOR) / poolValue;\n    }\n\n    function getExpectedSeniorAssets(address poolAddress) external view returns (uint256) {\n        uint256 senorDebt = this.getSeniorDebt(poolAddress);\n        uint256 seniorBalance = this.getSeniorBalance(poolAddress);\n        return senorDebt + seniorBalance;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pool/SecuritizationTGE.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport {PausableUpgradeable} from '../../base/PauseableUpgradeable.sol';\nimport {ERC20BurnableUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\nimport {ISecuritizationPoolValueService} from './ISecuritizationPoolValueService.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\nimport {SecuritizationAccessControl} from './SecuritizationAccessControl.sol';\nimport {IMintedTGE} from '../note-sale/IMintedTGE.sol';\nimport {IFinalizableCrowdsale} from '../note-sale/crowdsale/IFinalizableCrowdsale.sol';\nimport {SecuritizationPoolStorage} from './SecuritizationPoolStorage.sol';\nimport {ISecuritizationPoolExtension, SecuritizationPoolExtension} from './SecuritizationPoolExtension.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\nimport {ICrowdSale} from '../note-sale/crowdsale/ICrowdSale.sol';\n\nimport {ORIGINATOR_ROLE} from './types.sol';\n\nimport {IPoolNAV} from './IPoolNAV.sol';\nimport {IPoolNAVFactory} from './IPoolNAVFactory.sol';\n\ninterface ICrowdSaleLike {\n    function token() external view returns (address);\n}\n\ncontract SecuritizationTGE is\n    ERC165Upgradeable,\n    RegistryInjection,\n    ContextUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    SecuritizationAccessControl,\n    SecuritizationPoolStorage,\n    ISecuritizationTGE\n{\n    using ConfigHelper for Registry;\n\n    function installExtension(\n        bytes memory params\n    ) public virtual override(SecuritizationAccessControl, SecuritizationPoolStorage) onlyCallInTargetPool {\n        __SecuritizationTGE_init_unchained(abi.decode(params, (NewPoolParams)));\n    }\n\n    function __SecuritizationTGE_init_unchained(NewPoolParams memory params) internal {\n        Storage storage $ = _getStorage();\n        $.pot = address(this);\n        $.state = CycleState.INITIATED;\n\n        $.underlyingCurrency = params.currency;\n        $.minFirstLossCushion = params.minFirstLossCushion;\n        $.debtCeiling = params.debtCeiling;\n    }\n\n    // alias\n    function sotToken() public view override returns (address) {\n        // return _getStorage().sotToken;\n        address tge = tgeAddress();\n        if (tge == address(0)) return address(0);\n        return ICrowdSaleLike(tge).token();\n    }\n\n    // alias\n    function jotToken() public view override returns (address) {\n        // return _getStorage().jotToken;\n        address tge = secondTGEAddress();\n        if (tge == address(0)) return address(0);\n        return ICrowdSaleLike(tge).token();\n    }\n\n    function underlyingCurrency() public view override returns (address) {\n        return _getStorage().underlyingCurrency;\n    }\n\n    function reserve() public view override returns (uint256) {\n        return _getStorage().reserve;\n    }\n\n    function minFirstLossCushion() public view override returns (uint32) {\n        return _getStorage().minFirstLossCushion;\n    }\n\n    function termLengthInSeconds() public view override returns (uint64) {\n        return _getStorage().termLengthInSeconds;\n    }\n\n    function paidPrincipalAmountSOT() public view override returns (uint256) {\n        return _getStorage().paidPrincipalAmountSOT;\n    }\n\n    function principalAmountSOT() public view override returns (uint256) {\n        return _getStorage().principalAmountSOT;\n    }\n\n    function debtCeiling() public view override returns (uint256) {\n        return _getStorage().debtCeiling;\n    }\n\n    function interestRateSOT() public view override returns (uint32) {\n        return _getStorage().interestRateSOT;\n    }\n\n    function paidPrincipalAmountSOTByInvestor(address user) public view override returns (uint256) {\n        return _getStorage().paidPrincipalAmountSOTByInvestor[user];\n    }\n\n    function totalAssetRepaidCurrency() public view override returns (uint256) {\n        return _getStorage().totalAssetRepaidCurrency;\n    }\n\n    modifier finishRedemptionValidator() {\n        require(hasFinishedRedemption(), 'SecuritizationPool: Redemption has not finished');\n        _;\n    }\n\n    /// @inheritdoc ISecuritizationTGE\n    function injectTGEAddress(\n        address _tgeAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteType\n    ) external override whenNotPaused onlyIssuingTokenStage {\n        registry().requireSecuritizationManager(_msgSender());\n\n        require(_tgeAddress != address(0), 'SecuritizationPool: Address zero');\n        address _tokenAddress = ICrowdSaleLike(_tgeAddress).token();\n        require(_tokenAddress != address(0), 'SecuritizationPool: Address zero');\n\n        Storage storage $ = _getStorage();\n\n        if (_noteType == Configuration.NOTE_TOKEN_TYPE.SENIOR) {\n            $.tgeAddress = _tgeAddress;\n            $.sotToken = _tokenAddress;\n        } else {\n            $.secondTGEAddress = _tgeAddress;\n            $.jotToken = _tokenAddress;\n        }\n\n        $.state = CycleState.CROWDSALE;\n\n        emit UpdateTGEAddress(_tgeAddress, _noteType);\n    }\n\n    /// @notice allows the redemption of tokens\n    function redeem(\n        address usr,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external virtual override {\n        require(\n            _msgSender() == address(registry().getDistributionTranche()),\n            'SecuritizationPool: Caller must be DistributionTranche'\n        );\n\n        Storage storage $ = _getStorage();\n\n        if (sotToken() == notesToken) {\n            $.paidPrincipalAmountSOTByInvestor[usr] += currencyAmount;\n            emit UpdatePaidPrincipalAmountSOTByInvestor(usr, currencyAmount);\n        }\n\n        $.reserve = $.reserve - currencyAmount;\n\n        if (tokenAmount > 0) {\n            ERC20BurnableUpgradeable(notesToken).burn(tokenAmount);\n        }\n\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n        require(\n            IERC20Upgradeable($.underlyingCurrency).transferFrom($.pot, usr, currencyAmount),\n            'SecuritizationPool: currency-transfer-failed'\n        );\n\n        emit UpdateReserve($.reserve);\n    }\n\n    /// @inheritdoc ISecuritizationTGE\n    function disburse(\n        address usr,\n        uint256 currencyAmount\n    ) external virtual override {\n        Storage storage $ = _getStorage();\n        require(\n            _msgSender() == address(registry().getNoteTokenVault()),\n            'SecuritizationPool: Caller must be NoteTokenVault'\n        );\n        require(\n            IERC20Upgradeable($.underlyingCurrency).transferFrom($.pot, usr, currencyAmount),\n            'SecuritizationPool: currency-transfer-failed'\n        );\n\n    }\n\n    function checkMinFirstLost() public view virtual returns (bool) {\n        ISecuritizationPoolValueService poolService = registry().getSecuritizationPoolValueService();\n        return _getStorage().minFirstLossCushion <= poolService.getJuniorRatio(address(this));\n    }\n\n    function isDebtCeilingValid() public view virtual override returns (bool) {\n        Storage storage $ = _getStorage();\n        uint256 totalDebt = 0;\n        if ($.tgeAddress != address(0)) {\n            totalDebt += ICrowdSale($.tgeAddress).currencyRaised();\n        }\n        if ($.secondTGEAddress != address(0)) {\n            totalDebt += ICrowdSale($.secondTGEAddress).currencyRaised();\n        }\n        return $.debtCeiling >= totalDebt;\n    }\n\n    // Increase by value\n    function increaseTotalAssetRepaidCurrency(uint256 amount) external virtual override whenNotPaused {\n        registry().requireLoanRepaymentRouter(_msgSender());\n\n        Storage storage $ = _getStorage();\n\n        $.reserve = $.reserve + amount;\n        $.totalAssetRepaidCurrency = $.totalAssetRepaidCurrency + amount;\n\n        emit UpdateReserve($.reserve);\n    }\n\n    function hasFinishedRedemption() public view override returns (bool) {\n        address stoken = sotToken();\n        if (stoken != address(0)) {\n            require(IERC20Upgradeable(stoken).totalSupply() == 0, 'SecuritizationPool: SOT still remain');\n        }\n\n        address jtoken = jotToken();\n        if (jtoken != address(0)) {\n            require(IERC20Upgradeable(jtoken).totalSupply() == 0, 'SecuritizationPool: JOT still remain');\n        }\n\n        return true;\n    }\n\n    function setPot(address _pot) external override whenNotPaused nonReentrant notClosingStage {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n\n        Storage storage $ = _getStorage();\n\n        require($.pot != _pot, 'SecuritizationPool: Same address with current pot');\n        $.pot = _pot;\n\n        if (_pot == address(this)) {\n            require(\n                IERC20Upgradeable($.underlyingCurrency).approve(_pot, type(uint256).max),\n                'SecuritizationPool: Pot not approved'\n            );\n        }\n        registry().getSecuritizationManager().registerPot(_pot);\n    }\n\n    function setDebtCeiling(uint256 _debtCeiling) external override whenNotPaused notClosingStage {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n\n        Storage storage $ = _getStorage();\n        $.debtCeiling = _debtCeiling;\n        require(isDebtCeilingValid(), 'SecuritizationPool: Debt ceiling is not valid');\n        emit UpdateDebtCeiling(_debtCeiling);\n    }\n\n    function setUpPoolNAV() public override {\n        require(poolNAV() == address(0), 'SecuritizationPool: PoolNAV already set');\n        IPoolNAVFactory poolNAVFactory = registry().getPoolNAVFactory();\n        require(address(poolNAVFactory) != address(0), 'Pool NAV Factory was not registered');\n        address poolNAVAddress = poolNAVFactory.createPoolNAV();\n        Storage storage $ = _getStorage();\n        $.poolNAV = poolNAVAddress;\n\n        emit UpdatePoolNAV(poolNAVAddress);\n    }\n\n    function increaseReserve(uint256 currencyAmount) external override whenNotPaused {\n        require(\n            _msgSender() == address(registry().getSecuritizationManager()) ||\n                _msgSender() == address(registry().getDistributionOperator()),\n            'SecuritizationPool: Caller must be SecuritizationManager or DistributionOperator'\n        );\n\n        Storage storage $ = _getStorage();\n\n        $.reserve = $.reserve + currencyAmount;\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n\n        emit UpdateReserve($.reserve);\n    }\n\n    function decreaseReserve(uint256 currencyAmount) external override whenNotPaused {\n        require(\n            _msgSender() == address(registry().getSecuritizationManager()) ||\n            _msgSender() == address(registry().getDistributionOperator()) || _msgSender() == address(registry().getNoteTokenVault()),\n            'SecuritizationPool: Caller must be SecuritizationManager or DistributionOperator'\n        );\n\n        Storage storage $ = _getStorage();\n        $.reserve = $.reserve - currencyAmount;\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n\n        emit UpdateReserve($.reserve);\n    }\n\n    function setInterestRateForSOT(uint32 _interestRateSOT) external override whenNotPaused {\n        Storage storage $ = _getStorage();\n        require(_msgSender() == $.tgeAddress, 'SecuritizationPool: Only tge can update interest');\n\n        $.interestRateSOT = _interestRateSOT;\n        emit UpdateInterestRateSOT(_interestRateSOT);\n    }\n\n    // After closed pool and redeem all not -> get remain cash to recipient wallet\n    function claimCashRemain(\n        address recipientWallet\n    ) external override whenNotPaused onlyOwner finishRedemptionValidator {\n        Storage storage $ = _getStorage();\n\n        IERC20Upgradeable currency = IERC20Upgradeable($.underlyingCurrency);\n        require(\n            currency.transferFrom($.pot, recipientWallet, currency.balanceOf($.pot)),\n            'SecuritizationPool: Transfer failed'\n        );\n    }\n\n    function startCycle(\n        uint64 _termLengthInSeconds,\n        uint256 _principalAmountForSOT,\n        uint32 _interestRateForSOT,\n        uint64 _timeStartEarningInterest\n    ) external override whenNotPaused nonReentrant onlyOwner onlyIssuingTokenStage {\n        require(_termLengthInSeconds > 0, 'SecuritizationPool: Term length is 0');\n\n        Storage storage $ = _getStorage();\n\n        $.termLengthInSeconds = _termLengthInSeconds;\n\n        $.principalAmountSOT = _principalAmountForSOT;\n\n        $.state = CycleState.OPEN;\n\n        if ($.tgeAddress != address(0)) {\n            IMintedTGE mintedTokenGenerationEvent = IMintedTGE($.tgeAddress);\n            mintedTokenGenerationEvent.setupLongSale(\n                _interestRateForSOT,\n                _termLengthInSeconds,\n                _timeStartEarningInterest\n            );\n            if (!IFinalizableCrowdsale($.tgeAddress).finalized()) {\n                IFinalizableCrowdsale($.tgeAddress).finalize(false, $.pot);\n            }\n            $.interestRateSOT = mintedTokenGenerationEvent.pickedInterest();\n        }\n        if ($.secondTGEAddress != address(0)) {\n            IFinalizableCrowdsale($.secondTGEAddress).finalize(false, $.pot);\n            require(\n                IFinalizableCrowdsale($.secondTGEAddress).finalized(),\n                'SecuritizationPool: second sale is still on going'\n            );\n        }\n    }\n\n    function withdraw(address to, uint256 amount) public override whenNotPaused {\n        registry().requireLoanKernel(_msgSender());\n        require(hasRole(ORIGINATOR_ROLE, to), 'SecuritizationPool: Only Originator can drawdown');\n        require(!registry().getNoteTokenVault().redeemDisabled(address(this)), \"SecuritizationPool: withdraw paused\");\n        Storage storage $ = _getStorage();\n        require($.reserve >= amount, 'SecuritizationPool: not enough reserve');\n\n        $.reserve = $.reserve - amount;\n\n        require(checkMinFirstLost(), 'MinFirstLoss is not satisfied');\n        require(\n            IERC20Upgradeable(underlyingCurrency()).transferFrom(pot(), to, amount),\n            'SecuritizationPool: Transfer failed'\n        );\n        emit Withdraw(to, amount);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, SecuritizationAccessControl, SecuritizationPoolStorage)\n        returns (bool)\n    {\n        return interfaceId == type(ISecuritizationTGE).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function pause() public virtual {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n        _pause();\n    }\n\n    function unpause() public virtual {\n        registry().requirePoolAdminOrOwner(address(this), _msgSender());\n        _unpause();\n    }\n\n    function getFunctionSignatures()\n        public\n        view\n        virtual\n        override(SecuritizationAccessControl, SecuritizationPoolStorage)\n        returns (bytes4[] memory)\n    {\n        bytes4[] memory _functionSignatures = new bytes4[](31);\n\n        _functionSignatures[0] = this.termLengthInSeconds.selector;\n        _functionSignatures[1] = this.setPot.selector;\n        _functionSignatures[2] = this.increaseReserve.selector;\n        _functionSignatures[3] = this.decreaseReserve.selector;\n        _functionSignatures[4] = this.sotToken.selector;\n        _functionSignatures[5] = this.jotToken.selector;\n        _functionSignatures[6] = this.underlyingCurrency.selector;\n        _functionSignatures[7] = this.paidPrincipalAmountSOT.selector;\n        _functionSignatures[8] = this.paidPrincipalAmountSOTByInvestor.selector;\n        _functionSignatures[9] = this.reserve.selector;\n        _functionSignatures[10] = this.principalAmountSOT.selector;\n        _functionSignatures[11] = this.interestRateSOT.selector;\n        _functionSignatures[12] = this.minFirstLossCushion.selector;\n        _functionSignatures[13] = this.totalAssetRepaidCurrency.selector;\n        _functionSignatures[14] = this.injectTGEAddress.selector;\n        _functionSignatures[15] = this.increaseTotalAssetRepaidCurrency.selector;\n        _functionSignatures[16] = this.redeem.selector;\n        _functionSignatures[17] = this.hasFinishedRedemption.selector;\n        _functionSignatures[18] = this.setInterestRateForSOT.selector;\n        _functionSignatures[19] = this.claimCashRemain.selector;\n        _functionSignatures[20] = this.startCycle.selector;\n        _functionSignatures[21] = this.withdraw.selector;\n        _functionSignatures[22] = this.supportsInterface.selector;\n        _functionSignatures[23] = this.paused.selector;\n        _functionSignatures[24] = this.pause.selector;\n        _functionSignatures[25] = this.unpause.selector;\n        _functionSignatures[26] = this.setUpPoolNAV.selector;\n        _functionSignatures[27] = this.isDebtCeilingValid.selector;\n        _functionSignatures[28] = this.setDebtCeiling.selector;\n        _functionSignatures[29] = this.debtCeiling.selector;\n        _functionSignatures[30] = this.disburse.selector;\n\n        return _functionSignatures;\n    }\n}\n"
    },
    "contracts/protocol/pool/types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nbytes32 constant OWNER_ROLE = keccak256('OWNER_ROLE');\nbytes32 constant POOL_ADMIN = keccak256('POOL_CREATOR');\nbytes32 constant ORIGINATOR_ROLE = keccak256('ORIGINATOR_ROLE');\nbytes32 constant BACKEND_ADMIN = keccak256('BACKEND_ADMIN');\n\nuint256 constant RATE_SCALING_FACTOR = 10 ** 4;\n"
    },
    "contracts/storage/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {UntangledBase} from '../base/UntangledBase.sol';\nimport {Configuration} from '../libraries/Configuration.sol';\n\n/**\n * @title Registry\n * @notice This contract stores mappings of useful \"protocol config state\", giving a central place\n *  for all other contracts to access it. These config vars\n *  are enumerated in the `Configuration` library, and can only be changed by admins of the protocol.\n * @author Untangled Team\n */\ncontract Registry is UntangledBase {\n    mapping(uint8 => address) public contractAddresses;\n\n    event AddressUpdated(address owner, uint8 index, address oldValue, address newValue);\n\n    function initialize() public initializer {\n        __UntangledBase__init(_msgSender());\n    }\n\n    function _setAddress(uint8 addressIndex, address newAddress) private {\n        emit AddressUpdated(_msgSender(), addressIndex, contractAddresses[addressIndex], newAddress);\n        contractAddresses[addressIndex] = newAddress;\n    }\n\n    function getAddress(uint8 index) public view returns (address) {\n        return contractAddresses[index];\n    }\n\n    function setSecuritizationManager(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER), newAddress);\n    }\n\n    function setSecuritizationPool(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL), newAddress);\n    }\n\n    function setNoteTokenFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY), newAddress);\n    }\n\n    // function setNoteToken(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN), newAddress);\n    // }\n\n    function setTokenGenerationEventFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY), newAddress);\n    }\n\n    // function setMintedIncreasingInterestTGE(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE), newAddress);\n    // }\n\n    // function setMintedNormalTGE(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE), newAddress);\n    // }\n\n    function setDistributionOperator(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR), newAddress);\n    }\n\n    function setDistributionAssessor(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR), newAddress);\n    }\n\n    function setLoanAssetToken(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN), newAddress);\n    }\n\n    function setDistributionTranche(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE), newAddress);\n    }\n\n    function setSecuritizationPoolValueService(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE), newAddress);\n    }\n\n    function setLoanRegistry(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REGISTRY), newAddress);\n    }\n\n    function setLoanInterestTermsContract(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT), newAddress);\n    }\n\n    function setLoanRepaymentRouter(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER), newAddress);\n    }\n\n    function setLoanKernel(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_KERNEL), newAddress);\n    }\n\n    function setGo(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.GO), newAddress);\n    }\n\n    function setPoolNAVFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.POOL_NAV_FACTORY), newAddress);\n    }\n\n    function setNoteTokenVault(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN_VAULT), newAddress);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/test/MockERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol';\n\ncontract MockERC20Upgradeable is ERC20PresetMinterPauserUpgradeable {\n    uint8 public currentDecimal;\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        uint8 _currentDecimal\n    ) public initializer {\n        __ERC20PresetMinterPauser_init(name, symbol);\n        currentDecimal = _currentDecimal;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return currentDecimal;\n    }\n\n    function setDecimal(uint8 _decimal) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        currentDecimal = _decimal;\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n/// @title TestERC20\n/// @author Untangled Team\n/// @dev Used for test purpose only\ncontract TestERC20 is ERC20 {\n    address admin;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) {\n        admin = msg.sender;\n        _mint(msg.sender, initialSupply);\n    }\n\n    function mint(uint256 amount) public {\n        _mint(admin, amount);\n    }\n}\n"
    },
    "contracts/test/TestUniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../uid/UniqueIdentity.sol\";\n\n/// @title TestUniqueIdentity\n/// @author Untangled Team\n/// @dev Used for test purpose only\ncontract TestUniqueIdentity is UniqueIdentity {\n  function _mintForTest(\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) public incrementNonce(to) {\n    _mint(to, id, amount, data);\n  }\n\n  function _burnForTest(address account, uint256 id) public incrementNonce(account) {\n    _burn(account, id, 1);\n  }\n}\n"
    },
    "contracts/tokens/ERC20/INoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {IERC20MetadataUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol';\nimport {IPauseable} from '../../base/IPauseable.sol';\n\ninterface INoteToken is IERC20Upgradeable, IERC20MetadataUpgradeable, IPauseable {\n    // address public poolAddress;\n    // uint8 public noteTokenType;\n\n    // uint8 internal immutable _d;\n    function poolAddress() external view returns (address);\n\n    function noteTokenType() external view returns (uint8);\n\n    function mint(address receiver, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n}\n"
    },
    "contracts/tokens/ERC20/NoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol';\nimport './INoteToken.sol';\n\n/// @title NoteToken\n/// @author Untangled Team\n/// @dev Template for SOT/JOT token\ncontract NoteToken is INoteToken, ERC20PresetMinterPauserUpgradeable {\n    address internal _poolAddress;\n    uint8 internal _noteTokenType;\n    uint8 internal _decimals;\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        uint8 decimalsOfToken,\n        address poolAddressOfToken,\n        uint8 typeOfToken\n    ) public initializer {\n        __ERC20PresetMinterPauser_init(name, symbol);\n        require(poolAddressOfToken != address(0), 'NoteToken: Invalid pool address');\n\n        _decimals = decimalsOfToken;\n        _poolAddress = poolAddressOfToken;\n        _noteTokenType = typeOfToken;\n    }\n\n    function poolAddress() external view returns (address) {\n        return _poolAddress;\n    }\n\n    function noteTokenType() external view returns (uint8) {\n        return _noteTokenType;\n    }\n\n    function decimals() public view override(ERC20Upgradeable, IERC20MetadataUpgradeable) returns (uint8) {\n        return _decimals;\n    }\n\n    function burn(uint256 amount) public override(ERC20BurnableUpgradeable, INoteToken) {\n        return ERC20BurnableUpgradeable.burn(amount);\n    }\n\n    function mint(address receiver, uint256 amount) public override(INoteToken, ERC20PresetMinterPauserUpgradeable) {\n        return ERC20PresetMinterPauserUpgradeable.mint(receiver, amount);\n    }\n\n    function pause() public virtual override(ERC20PresetMinterPauserUpgradeable, IPauseable) {\n        super.pause();\n    }\n\n    function paused() public view virtual override(IPauseable, PausableUpgradeable) returns (bool) {\n        return super.paused();\n    }\n\n    function unpause() public virtual override(ERC20PresetMinterPauserUpgradeable, IPauseable) {\n        super.unpause();\n    }\n}\n"
    },
    "contracts/tokens/ERC20/types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nbytes32 constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");"
    },
    "contracts/tokens/ERC721/IERC5008.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n// https://eips.ethereum.org/EIPS/eip-5008\n/// @dev the ERC-165 identifier for this interface is 0xce03fdab.\n/* is IERC165 */ interface IERC5008 {\n    /// @notice Emitted when the `nonce` of an NFT is changed\n    event NonceChanged(uint256 tokenId, uint256 nonce);\n\n    /// @notice Get the nonce of an NFT\n    /// Throws if `tokenId` is not a valid NFT\n    /// @param tokenId The id of the NFT\n    /// @return The nonce of the NFT\n    function nonce(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "contracts/tokens/ERC721/ILoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../interfaces/IUntangledERC721.sol';\nimport './types.sol';\n\nabstract contract ILoanAssetToken is IUntangledERC721 {\n  \n  function safeMint(address creditor, LoanAssetInfo calldata latInfo) external virtual;\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/IUntangledERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol';\nimport '../../storage/Registry.sol';\n\nabstract contract IUntangledERC721 is ERC721PresetMinterPauserAutoIdUpgradeable {\n    Registry public registry;\n\n    function __UntangledERC721__init(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __UntangledERC721__init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __UntangledERC721__init_unchained(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _safeMint(to, tokenId);\n    }\n\n    /// @notice calculates the total expected repayment value (principal + interest) for a loan asset token at a given timestamp\n    function getTotalExpectedRepaymentValue(\n        uint256 agreementId,\n        uint256 timestamp\n    ) external view virtual returns (uint256);\n\n    /// @notice the expected principal and interest for an asset\n    function getExpectedRepaymentValues(\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view virtual returns (uint256 expectedPrincipal, uint256 expectedInterest);\n\n    /// @notice the expiration timestamp of an invoice/loan token\n    function getExpirationTimestamp(uint256 agreementId) external view virtual returns (uint256);\n\n    /// @notice  the interest rate associated with an token\n    function getInterestRate(uint256 agreementId) external view virtual returns (uint256);\n\n    /// @notice the risk score associated with a token\n    function getRiskScore(uint256 agreementId) external view virtual returns (uint8);\n\n    /// @notice retrieves the asset purpose for a given loan agreement ID\n    function getAssetPurpose(uint256 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/LATValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {EIP712Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol';\nimport {ECDSAUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport {SignatureCheckerUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol';\nimport {ERC165CheckerUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol';\nimport {ISecuritizationPoolStorage} from '../../interfaces/ISecuritizationPoolStorage.sol';\nimport {ISecuritizationAccessControl} from '../../interfaces/ISecuritizationAccessControl.sol';\nimport {IERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol';\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\nimport {IERC5008} from './IERC5008.sol';\nimport {VALIDATOR_ROLE, LoanAssetInfo} from './types.sol';\n\nabstract contract LATValidator is IERC5008, EIP712Upgradeable {\n    using SignatureCheckerUpgradeable for address;\n    using ECDSAUpgradeable for bytes32;\n    using ERC165CheckerUpgradeable for address;\n\n    bytes32 internal constant LAT_TYPEHASH =\n        keccak256('LoanAssetToken(uint256[] tokenIds,uint256[] nonces,address validator)');\n\n    mapping(uint256 => uint256) internal _nonces;\n\n    modifier validateCreditor(address creditor, LoanAssetInfo calldata info) {\n        //  requireNonceValid(latInfo) requireValidator(latInfo)\n        if (\n            IERC165Upgradeable(creditor).supportsInterface(type(ISecuritizationPoolStorage).interfaceId) &&\n            IERC165Upgradeable(creditor).supportsInterface(type(ISecuritizationAccessControl).interfaceId)\n        ) {\n            if (ISecuritizationPoolStorage(creditor).validatorRequired()) {\n                _checkNonceValid(info);\n\n                require(_checkValidator(info), 'LATValidator: invalid validator signature');\n                require(isValidator(info.validator), 'LATValidator: invalid validator');\n            }\n        }\n        _;\n    }\n\n    modifier requireValidator(LoanAssetInfo calldata info) {\n        require(_checkValidator(info), 'LATValidator: invalid validator signature');\n        _;\n    }\n\n    modifier requireNonceValid(LoanAssetInfo calldata info) {\n        _checkNonceValid(info);\n        _;\n    }\n\n    function _checkNonceValid(LoanAssetInfo calldata info) internal {\n        for (uint256 i = 0; i < info.tokenIds.length; i = UntangledMath.uncheckedInc(i)) {\n            require(_nonces[info.tokenIds[i]] == info.nonces[i], 'LATValidator: invalid nonce');\n            unchecked {\n                _nonces[info.tokenIds[i]] = _nonces[info.tokenIds[i]] + 1;\n            }\n\n            emit NonceChanged(info.tokenIds[i], _nonces[info.tokenIds[i]]);\n        }\n    }\n\n    function __LATValidator_init() internal onlyInitializing {\n        __EIP712_init_unchained('UntangledLoanAssetToken', '0.0.1');\n        __LATValidator_init_unchained();\n    }\n\n    function __LATValidator_init_unchained() internal onlyInitializing {}\n\n    function isValidator(address sender) public view virtual returns (bool);\n\n    function nonce(uint256 tokenId) external view override returns (uint256) {\n        return _nonces[tokenId];\n    }\n\n    function _checkValidator(LoanAssetInfo calldata latInfo) internal view returns (bool) {\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    LAT_TYPEHASH,\n                    keccak256(abi.encodePacked(latInfo.tokenIds)),\n                    keccak256(abi.encodePacked(latInfo.nonces)),\n                    latInfo.validator\n                )\n            )\n        );\n\n        return latInfo.validator.isValidSignatureNow(digest, latInfo.validateSignature);\n    }\n\n    function domainSeparatorV4() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/LoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanRegistry} from '../../interfaces/ILoanRegistry.sol';\nimport {ILoanInterestTermsContract} from '../../interfaces/ILoanInterestTermsContract.sol';\nimport {ILoanAssetToken} from './ILoanAssetToken.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {LATValidator} from './LATValidator.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {LoanAssetInfo, VALIDATOR_ROLE, VALIDATOR_ADMIN_ROLE} from '../ERC721/types.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\nimport {UntangledMath} from '../../libraries/UntangledMath.sol';\n\n/**\n * LoanAssetToken: The representative for ownership of a Loan\n */\ncontract LoanAssetToken is ILoanAssetToken, LATValidator {\n    using ConfigHelper for Registry;\n\n    /** CONSTRUCTOR */\n    function initialize(\n        Registry _registry,\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) public initializer {\n        __UntangledERC721__init(name, symbol, baseTokenURI);\n        __LATValidator_init();\n\n        registry = _registry;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        require(\n            address(registry.getSecuritizationManager()) != address(0x0),\n            'SECURITIZATION_MANAGER is zero address.'\n        );\n\n        _setupRole(VALIDATOR_ADMIN_ROLE, address(registry.getSecuritizationManager()));\n        _setRoleAdmin(VALIDATOR_ROLE, VALIDATOR_ADMIN_ROLE);\n\n        require(address(registry.getLoanKernel()) != address(0x0), 'LOAN_KERNEL is zero address.');\n\n        _setupRole(MINTER_ROLE, address(registry.getLoanKernel()));\n        _revokeRole(MINTER_ROLE, _msgSender());\n    }\n\n    function getExpectedRepaymentValues(\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view override returns (uint256 expectedPrincipal, uint256 expectedInterest) {\n        bytes32 agreementId = bytes32(tokenId);\n        (expectedPrincipal, expectedInterest) = registry.getLoanInterestTermsContract().getExpectedRepaymentValues(\n            agreementId,\n            timestamp\n        );\n    }\n\n    function getExpirationTimestamp(uint256 _tokenId) public view override returns (uint256) {\n        return registry.getLoanRegistry().getExpirationTimestamp(bytes32(_tokenId));\n    }\n\n    function getRiskScore(uint256 _tokenId) public view override returns (uint8) {\n        return registry.getLoanRegistry().getRiskScore(bytes32(_tokenId));\n    }\n\n    function getAssetPurpose(uint256 _tokenId) public view override returns (Configuration.ASSET_PURPOSE) {\n        return registry.getLoanRegistry().getAssetPurpose(bytes32(_tokenId));\n    }\n\n    function getInterestRate(uint256 _tokenId) public view override returns (uint256 beneficiary) {\n        return registry.getLoanInterestTermsContract().getInterestRate(bytes32(_tokenId));\n    }\n\n    function getTotalExpectedRepaymentValue(\n        uint256 agreementId,\n        uint256 timestamp\n    ) public view override returns (uint256 expectedRepaymentValue) {\n        uint256 principalAmount;\n        uint256 interestAmount;\n        (principalAmount, interestAmount) = getExpectedRepaymentValues(agreementId, timestamp);\n        expectedRepaymentValue = principalAmount + interestAmount;\n    }\n\n    function safeMint(\n        address creditor,\n        LoanAssetInfo calldata latInfo\n    ) public virtual override onlyRole(MINTER_ROLE) validateCreditor(creditor, latInfo) {\n        for (uint i = 0; i < latInfo.tokenIds.length; i = UntangledMath.uncheckedInc(i)) {\n            _safeMint(creditor, latInfo.tokenIds[i]);\n        }\n    }\n\n    function isValidator(address sender) public view virtual override returns (bool) {\n        return hasRole(VALIDATOR_ROLE, sender);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/mock/AAWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {ECDSAUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\n\ncontract AAWallet is AccessControlUpgradeable {\n    using ECDSAUpgradeable for bytes32;\n\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n\n    bytes32 public constant VALIDATOR_ROLE = keccak256('VALIDATOR_ROLE');\n\n    function initialize() public initializer {\n        __AccessControl_init_unchained();\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Should return whether the signature provided is valid for the provided hash\n     * @param _hash      Hash of the data to be signed\n     * @param _signature Signature byte array associated with _hash\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4 magicValue) {\n        // Validate signatures\n        address signer = _hash.recover(_signature);\n        if (hasRole(VALIDATOR_ROLE, signer)) {\n            return 0x1626ba7e;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function execute(address target, bytes memory data) external returns (bytes memory) {\n        return AddressUpgradeable.functionCall(target, data);\n    }\n}\n"
    },
    "contracts/tokens/ERC721/types.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nstruct LoanAssetInfo {\n    uint256[] tokenIds;\n    uint256[] nonces;\n    address validator;\n    bytes validateSignature;\n}\n\nbytes32 constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\nbytes32 constant VALIDATOR_ADMIN_ROLE = keccak256(\"VALIDATOR_ADMIN_ROLE\");"
    },
    "contracts/uid/IRequiresUID.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IRequiresUID {\n  function hasAllowedUID(address sender) external view returns (bool);\n}\n"
    },
    "contracts/uid/IUniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface IUniqueIdentity is IERC1155Upgradeable {\n    /// @notice Mint a new UniqueIdentity token to the msgSender\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding mint params:\n    ///                  account, id, expiresAt, address(this), nonces[account], block.chainid\n    ///                  from an address with the SIGNER_ROLE.\n    function mint(uint256 id, uint256 expiresAt, bytes calldata signature) external payable;\n\n    /// @notice Mint a new UniqueIdentity token to the `recipient`\n    /// @param recipient The recipient address to be minted to.\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding mintTo params:\n    ///                  (account, recipient, id, expiresAt, address(this), nonces[account], block.chainid)\n    ///                  from an address with the SIGNER_ROLE.\n    function mintTo(\n        address recipient,\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) external payable;\n\n    /// @notice Burn a UniqueIdentity token of `id` from the `account`\n    /// @param account The account which currently owns the UID\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding burn params:\n    ///                  (account, id, expiresAt, address(this), nonces[account], block.chainid)\n    ///                  from an address with the SIGNER_ROLE.\n    function burn(address account, uint256 id, uint256 expiresAt, bytes calldata signature) external;\n}\n"
    },
    "contracts/uid/UniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ECDSAUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {ERC1155PresetPauserUpgradeable} from '../external/ERC1155PresetPauserUpgradeable.sol';\nimport {IUniqueIdentity} from './IUniqueIdentity.sol';\n\n/**\n * @title UniqueIdentity\n * @notice UniqueIdentity is an ERC1155-compliant contract for representing\n * the identity verification status of addresses.\n * @author Untangled\n */\n\ncontract UniqueIdentity is ERC1155PresetPauserUpgradeable, IUniqueIdentity {\n    bytes32 public constant SIGNER_ROLE = keccak256('SIGNER_ROLE');\n\n    uint256 public constant ID_TYPE_0 = 0; // non-US individual\n    uint256 public constant ID_TYPE_1 = 1; // US accredited individual\n    uint256 public constant ID_TYPE_2 = 2; // US non accredited individual\n    uint256 public constant ID_TYPE_3 = 3; // US entity\n    uint256 public constant ID_TYPE_4 = 4; // non-US entity\n    uint256 public constant ID_TYPE_5 = 5;\n    uint256 public constant ID_TYPE_6 = 6;\n    uint256 public constant ID_TYPE_7 = 7;\n    uint256 public constant ID_TYPE_8 = 8;\n    uint256 public constant ID_TYPE_9 = 9;\n    uint256 public constant ID_TYPE_10 = 10;\n\n    uint256 public constant MINT_COST_PER_TOKEN = 830000 gwei;\n\n    /// @dev We include a nonce in every hashed message, and increment the nonce as part of a\n    /// state-changing operation, so as to prevent replay attacks, i.e. the reuse of a signature.\n    mapping(address => uint256) public nonces;\n    mapping(uint256 => bool) public supportedUIDTypes;\n\n    function initialize(address owner, string memory uri) public initializer {\n        require(owner != address(0), 'Owner address cannot be empty');\n\n        __ERC1155PresetPauser_init(owner, uri);\n        __UniqueIdentity_init(owner);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __UniqueIdentity_init(address owner) internal onlyInitializing {\n        __UniqueIdentity_init_unchained(owner);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __UniqueIdentity_init_unchained(address owner) internal onlyInitializing {\n        _setupRole(SIGNER_ROLE, owner);\n        _setRoleAdmin(SIGNER_ROLE, OWNER_ROLE);\n    }\n\n    function setSupportedUIDTypes(uint256[] calldata ids, bool[] calldata values) public onlyAdmin {\n        require(ids.length == values.length, 'accounts and ids length mismatch');\n        for (uint256 i = 0; i < ids.length; ++i) {\n            supportedUIDTypes[ids[i]] = values[i];\n        }\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() public pure returns (string memory) {\n        return 'Unique Identity';\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() public pure returns (string memory) {\n        return 'UID';\n    }\n\n    function mint(\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) public payable override onlySigner(_msgSender(), id, expiresAt, signature) incrementNonce(_msgSender()) {\n        _mintTo(_msgSender(), id);\n    }\n\n    function mintTo(\n        address recipient,\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) public payable override onlySignerMintTo(recipient, id, expiresAt, signature) incrementNonce(_msgSender()) {\n        require(balanceOf(_msgSender(), id) == 0, 'msgSender already owns UID');\n        _mintTo(recipient, id);\n    }\n\n    function _mintTo(address mintToAddress, uint256 id) private {\n        require(msg.value >= MINT_COST_PER_TOKEN, 'Token mint requires 0.00083 ETH');\n        require(supportedUIDTypes[id], 'Token id not supported');\n        require(balanceOf(mintToAddress, id) == 0, 'Balance before mint must be 0');\n\n        _mint(mintToAddress, id, 1, '');\n    }\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) public override onlySigner(account, id, expiresAt, signature) incrementNonce(account) {\n        _burn(account, id, 1);\n\n        uint256 accountBalance = balanceOf(account, id);\n        require(accountBalance == 0, 'Balance after burn must be 0');\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155PresetPauserUpgradeable) {\n        require(\n            (from == address(0) && to != address(0)) || (from != address(0) && to == address(0)),\n            'Only mint or burn transfers are allowed'\n        );\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    modifier onlySigner(\n        address account,\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) {\n        require(block.timestamp < expiresAt, 'Signature has expired');\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(account, id, expiresAt, address(this), nonces[account], block.chainid)\n        );\n        bytes32 ethSignedMessage = ECDSAUpgradeable.toEthSignedMessageHash(hash);\n        require(hasRole(SIGNER_ROLE, ECDSAUpgradeable.recover(ethSignedMessage, signature)), 'Invalid signer');\n        _;\n    }\n\n    modifier onlySignerMintTo(\n        address mintToAddress,\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) {\n        require(block.timestamp < expiresAt, 'Signature has expired');\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                _msgSender(),\n                mintToAddress,\n                id,\n                expiresAt,\n                address(this),\n                nonces[_msgSender()],\n                block.chainid\n            )\n        );\n\n        bytes32 ethSignedMessage = ECDSAUpgradeable.toEthSignedMessageHash(hash);\n        require(hasRole(SIGNER_ROLE, ECDSAUpgradeable.recover(ethSignedMessage, signature)), 'Invalid signer');\n        _;\n    }\n\n    modifier incrementNonce(address account) {\n        nonces[account] += 1;\n        _;\n    }\n\n    // unlock\n    function unlockWrongToken(address token) public onlyAdmin {\n        if (token == address(0)) {\n            (bool success, ) = payable(_msgSender()).call{value: IERC20Upgradeable(token).balanceOf(address(this))}('');\n            require(success, 'Transfer failed.');\n        } else {\n            require(\n                IERC20Upgradeable(token).transfer(_msgSender(), IERC20Upgradeable(token).balanceOf(address(this))),\n                'Transfer failed.'\n            );\n        }\n    }\n\n    uint256[48] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
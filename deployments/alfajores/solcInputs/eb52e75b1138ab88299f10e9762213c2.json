{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"../extensions/ERC721BurnableUpgradeable.sol\";\nimport \"../extensions/ERC721PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC721PresetMinterPauserAutoIdUpgradeable is\n    Initializable, ContextUpgradeable,\n    AccessControlEnumerableUpgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721BurnableUpgradeable,\n    ERC721PausableUpgradeable\n{\n    function initialize(string memory name, string memory symbol, string memory baseTokenURI) public virtual initializer {\n        __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);\n    }\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    CountersUpgradeable.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n     * See {ERC721-tokenURI}.\n     */\n    function __ERC721PresetMinterPauserAutoId_init(string memory name, string memory symbol, string memory baseTokenURI) internal onlyInitializing {\n        __ERC721_init_unchained(name, symbol);\n        __Pausable_init_unchained();\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __ERC721PresetMinterPauserAutoId_init_unchained(string memory, string memory, string memory baseTokenURI) internal onlyInitializing {\n        _baseTokenURI = baseTokenURI;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/base/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {TransparentUpgradeableProxy} from '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\nabstract contract Factory is Initializable, ContextUpgradeable {\n    address public factoryAdmin;\n\n    modifier onlyFactoryAdmin() {\n        require(msg.sender == factoryAdmin, 'Only factory admin');\n        _;\n    }\n\n    function __Factory__init(address _factoryAdmin) internal onlyInitializing {\n        __Context_init_unchained();\n        __Factory_init_unchained(_factoryAdmin);\n    }\n\n    function __Factory_init_unchained(address _factoryAdmin) internal onlyInitializing {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    function _setFactoryAdmin(address _factoryAdmin) internal {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    function _deployInstance(address _poolImplAddress, bytes memory _data) internal returns (address) {\n        TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(_poolImplAddress, factoryAdmin, _data);\n\n        return address(proxy);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/base/Factory2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/utils/Create2.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\n\nabstract contract Factory2 is Initializable {\n    using AddressUpgradeable for address;\n\n    address public factoryAdmin;\n\n    function __Factory__init(address _factoryAdmin) internal onlyInitializing {\n        __Factory__init_unchained(_factoryAdmin);\n    }\n\n    function __Factory__init_unchained(address _factoryAdmin) internal onlyInitializing {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    function _setFactoryAdmin(address _factoryAdmin) internal {\n        factoryAdmin = _factoryAdmin;\n    }\n\n    // function getSelector(string memory _func) internal pure returns (bytes4) {\n    //     return bytes4(keccak256(bytes(_func)));\n    // }\n\n    function _deployInstance(address _poolImplAddress, bytes memory _data, bytes32 salt) internal returns (address) {\n        ITransparentUpgradeableProxy proxy = ITransparentUpgradeableProxy(\n            Create2.deploy(\n                0,\n                salt,\n                abi.encodePacked(\n                    type(TransparentUpgradeableProxy).creationCode,\n                    abi.encode(_poolImplAddress, address(this), '')\n                )\n            )\n        );\n\n        proxy.changeAdmin(factoryAdmin);\n        address(proxy).functionCall(_data);\n\n        return address(proxy);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/base/IPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IPauseable {\n    function pause() external;\n    function unpause() external;\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/base/UntangledBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';\n\nimport '../libraries/Configuration.sol';\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Abstract contract that serves as a base contract for other contracts in the Untangled system.\n *  It provides functionalities for contract initialization, pausing, and access control.\n * @author Untangled Team\n */\nabstract contract UntangledBase is\n    Initializable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\n\n    function isAdmin() public view virtual returns (bool) {\n        return hasRole(OWNER_ROLE, _msgSender());\n    }\n\n    modifier onlyAdmin() {\n        require(isAdmin(), 'UntangledBase: Must have admin role to perform this action');\n        _;\n    }\n\n    function __UntangledBase__init(address owner) internal onlyInitializing {\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n        __UntangledBase__init_unchained(owner);\n    }\n\n    function __UntangledBase__init_unchained(address owner) internal onlyInitializing {\n        if (owner == address(0)) owner = _msgSender();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(OWNER_ROLE, owner);\n\n        _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n    }\n\n    function getInitializedVersion() public view virtual returns (uint256) {\n        return _getInitializedVersion();\n    }\n\n    function pause() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/ICrowdSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ICrowdSale} from '../protocol/note-sale/crowdsale/ICrowdSale.sol';\n"
    },
    "contracts/interfaces/IDistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IDistributionAssessor} from '../protocol/pool/IDistributionAssessor.sol';\n"
    },
    "contracts/interfaces/IDistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IDistributionOperator} from '../protocol/pool/IDistributionOperator.sol';\n"
    },
    "contracts/interfaces/IDistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../protocol/pool/IDistributionTranche.sol';"
    },
    "contracts/interfaces/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IGo} from '../protocol/IGo.sol';\n"
    },
    "contracts/interfaces/ILoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanAssetToken} from '../tokens/ERC721/ILoanAssetToken.sol';\n"
    },
    "contracts/interfaces/ILoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanInterestTermsContract} from '../protocol/loan/ILoanInterestTermsContract.sol';\n"
    },
    "contracts/interfaces/ILoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanKernel} from '../protocol/loan/ILoanKernel.sol';\n"
    },
    "contracts/interfaces/ILoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ILoanRegistry} from '../protocol/loan/ILoanRegistry.sol';\n"
    },
    "contracts/interfaces/ILoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../protocol/loan/ILoanRepaymentRouter.sol';"
    },
    "contracts/interfaces/INoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {INoteToken} from '../tokens/ERC20/INoteToken.sol';\n"
    },
    "contracts/interfaces/INoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {INoteTokenFactory} from './../protocol/note-sale/fab/INoteTokenFactory.sol';\n"
    },
    "contracts/interfaces/IRequiresUID.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IRequiresUID} from '../uid/IRequiresUID.sol';\n"
    },
    "contracts/interfaces/ISecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ISecuritizationManager} from '../protocol/pool/ISecuritizationManager.sol';\n"
    },
    "contracts/interfaces/ISecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport {ISecuritizationPool} from '../protocol/pool/ISecuritizationPool.sol';\n"
    },
    "contracts/interfaces/ISecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ISecuritizationPoolValueService} from '../protocol/pool/ISecuritizationPoolValueService.sol';\n"
    },
    "contracts/interfaces/ITokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ITokenGenerationEventFactory} from '../protocol/note-sale/fab/ITokenGenerationEventFactory.sol';\n"
    },
    "contracts/interfaces/IUntangledERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IUntangledERC721} from '../tokens/ERC721/IUntangledERC721.sol';\n"
    },
    "contracts/libraries/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IAccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol';\nimport {Registry} from '../storage/Registry.sol';\nimport {Configuration} from './Configuration.sol';\n\nimport {ISecuritizationManager} from '../interfaces/ISecuritizationManager.sol';\nimport {ISecuritizationPool} from '../interfaces/ISecuritizationPool.sol';\nimport {INoteTokenFactory} from '../interfaces/INoteTokenFactory.sol';\nimport {INoteToken} from '../interfaces/INoteToken.sol';\nimport {ITokenGenerationEventFactory} from '../interfaces/ITokenGenerationEventFactory.sol';\nimport {IUntangledERC721} from '../interfaces/IUntangledERC721.sol';\nimport {IDistributionOperator} from '../interfaces/IDistributionOperator.sol';\nimport {IDistributionTranche} from '../interfaces/IDistributionTranche.sol';\nimport {ILoanRegistry} from '../interfaces/ILoanRegistry.sol';\nimport {ILoanInterestTermsContract} from '../interfaces/ILoanInterestTermsContract.sol';\nimport {ILoanRepaymentRouter} from '../interfaces/ILoanRepaymentRouter.sol';\nimport {ILoanKernel} from '../interfaces/ILoanKernel.sol';\nimport {ILoanAssetToken} from '../interfaces/ILoanAssetToken.sol';\nimport {IDistributionAssessor} from '../interfaces/IDistributionAssessor.sol';\nimport {ISecuritizationPoolValueService} from '../interfaces/ISecuritizationPoolValueService.sol';\n\nimport {MintedIncreasingInterestTGE} from '../protocol/note-sale/MintedIncreasingInterestTGE.sol';\nimport {MintedNormalTGE} from '../protocol/note-sale/MintedNormalTGE.sol';\nimport {IGo} from '../interfaces/IGo.sol';\nimport \"../protocol/pool/IPoolNAVFactory.sol\";\n\nimport {POOL_ADMIN, OWNER_ROLE} from './types.sol';\nimport {INoteTokenVault} from \"../protocol/pool/INoteTokenVault.sol\";\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the Registry contract\n * @author Untangled Team\n */\nlibrary ConfigHelper {\n    function getAddress(Registry registry, Configuration.CONTRACT_TYPE contractType) internal view returns (address) {\n        return registry.getAddress(uint8(contractType));\n    }\n\n    function getSecuritizationManager(Registry registry) internal view returns (ISecuritizationManager) {\n        return ISecuritizationManager(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER));\n    }\n\n    function getSecuritizationPool(Registry registry) internal view returns (ISecuritizationPool) {\n        return ISecuritizationPool(getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL));\n    }\n\n    function getNoteTokenFactory(Registry registry) internal view returns (INoteTokenFactory) {\n        return INoteTokenFactory(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY));\n    }\n\n    // function getNoteToken(Registry registry) internal view returns (INoteToken) {\n    //     return INoteToken(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN));\n    // }\n\n    function getTokenGenerationEventFactory(Registry registry) internal view returns (ITokenGenerationEventFactory) {\n        return\n            ITokenGenerationEventFactory(\n                getAddress(registry, Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY)\n            );\n    }\n\n    function getDistributionOperator(Registry registry) internal view returns (IDistributionOperator) {\n        return IDistributionOperator(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR));\n    }\n\n    function getLoanAssetToken(Registry registry) internal view returns (ILoanAssetToken) {\n        return ILoanAssetToken(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN));\n    }\n\n    function getLoanRegistry(Registry registry) internal view returns (ILoanRegistry) {\n        return ILoanRegistry(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REGISTRY));\n    }\n\n    function getLoanInterestTermsContract(Registry registry) internal view returns (ILoanInterestTermsContract) {\n        return\n            ILoanInterestTermsContract(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT));\n    }\n\n    function getLoanRepaymentRouter(Registry registry) internal view returns (ILoanRepaymentRouter) {\n        return ILoanRepaymentRouter(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER));\n    }\n\n    function getLoanKernel(Registry registry) internal view returns (ILoanKernel) {\n        return ILoanKernel(getAddress(registry, Configuration.CONTRACT_TYPE.LOAN_KERNEL));\n    }\n\n    function getDistributionTranche(Registry registry) internal view returns (IDistributionTranche) {\n        return IDistributionTranche(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE));\n    }\n\n    function getSecuritizationPoolValueService(\n        Registry registry\n    ) internal view returns (ISecuritizationPoolValueService) {\n        return\n            ISecuritizationPoolValueService(\n                getAddress(registry, Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE)\n            );\n    }\n\n    function getDistributionAssessor(Registry registry) internal view returns (IDistributionAssessor) {\n        return IDistributionAssessor(getAddress(registry, Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR));\n    }\n\n    // function getMintedIncreasingInterestTGE(Registry registry) internal view returns (MintedIncreasingInterestTGE) {\n    //     return\n    //         MintedIncreasingInterestTGE(\n    //             getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE)\n    //         );\n    // }\n\n    // function getMintedNormalTGE(Registry registry) internal view returns (MintedNormalTGE) {\n    //     return MintedNormalTGE(getAddress(registry, Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE));\n    // }\n\n    function getGo(Registry registry) internal view returns (IGo) {\n        return IGo(getAddress(registry, Configuration.CONTRACT_TYPE.GO));\n    }\n\n    function getPoolNAVFactory(Registry registry) internal view returns (IPoolNAVFactory) {\n        return IPoolNAVFactory(getAddress(registry, Configuration.CONTRACT_TYPE.POOL_NAV_FACTORY));\n    }\n\n    function getNoteTokenVault(Registry registry) internal view returns (INoteTokenVault) {\n        return INoteTokenVault(getAddress(registry, Configuration.CONTRACT_TYPE.NOTE_TOKEN_VAULT));\n    }\n\n    function requireDistributionOperator(Registry registry, address account) internal view {\n        require(account == address(getDistributionOperator(registry)), 'Registry: Only DistributionOperator');\n    }\n\n    function requirePoolAdmin(Registry registry, address account) internal view {\n        require(\n            IAccessControlUpgradeable(address(getSecuritizationManager(registry))).hasRole(POOL_ADMIN, account),\n            'Registry: Not an pool admin'\n        );\n    }\n\n    function requirePoolAdminOrOwner(Registry registry, address pool, address account) internal view {\n        require(\n            IAccessControlUpgradeable(address(getSecuritizationManager(registry))).hasRole(POOL_ADMIN, account) ||\n                IAccessControlUpgradeable(pool).hasRole(OWNER_ROLE, account),\n            'Registry: Not an pool admin or pool owner'\n        );\n    }\n\n    function requireSecuritizationManager(Registry registry, address account) internal view {\n        require(account == address(getSecuritizationManager(registry)), 'Registry: Only SecuritizationManager');\n    }\n\n    function requireLoanRepaymentRouter(Registry registry, address account) internal view {\n        require(account == address(getLoanRepaymentRouter(registry)), 'Registry: Only LoanRepaymentRouter');\n    }\n\n    function requireLoanKernel(Registry registry, address account) internal view {\n        require(account == address(getLoanKernel(registry)), 'Registry: Only LoanKernel');\n    }\n\n    function requireLoanInterestTermsContract(Registry registry, address account) internal view {\n        require(account == address(getLoanInterestTermsContract(registry)), 'Registry: Only LoanInterestTermsContract');\n    }\n}\n"
    },
    "contracts/libraries/Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Configuration\n/// @author Untangled Team\nlibrary Configuration {\n    // NEVER EVER CHANGE THE ORDER OF THESE!\n    // You can rename or append. But NEVER change the order.\n    enum CONTRACT_TYPE {\n        SECURITIZATION_MANAGER,\n        SECURITIZATION_POOL,\n        NOTE_TOKEN_FACTORY,\n        NOTE_TOKEN, // deprecated\n        TOKEN_GENERATION_EVENT_FACTORY,\n        DISTRIBUTION_OPERATOR,\n        DISTRIBUTION_ASSESSOR,\n        DISTRIBUTION_TRANCHE,\n        LOAN_ASSET_TOKEN,\n        ACCEPTED_INVOICE_TOKEN,\n        LOAN_REGISTRY,\n        LOAN_INTEREST_TERMS_CONTRACT,\n        LOAN_REPAYMENT_ROUTER,\n        LOAN_KERNEL,\n        ERC20_TOKEN_REGISTRY,\n        ERC20_TOKEN_TRANSFER_PROXY,\n        SECURITIZATION_MANAGEMENT_PROJECT,\n        SECURITIZATION_POOL_VALUE_SERVICE,\n        MINTED_INCREASING_INTEREST_TGE, // depreacated\n        MINTED_NORMAL_TGE, // depreacated\n        INVOICE_COLLATERALIZER,\n        INVOICE_DEBT_REGISTRY,\n        INVOICE_FINANCE_INTEREST_TERMS_CONTRACT,\n        INVOICE_LOAN_KERNEL,\n        INVOICE_LOAN_REPAYMENT_ROUTER,\n        GO,\n        POOL_NAV_FACTORY,\n        NOTE_TOKEN_VAULT\n    }\n\n    enum NOTE_TOKEN_TYPE {\n        SENIOR,\n        JUNIOR\n    }\n\n    enum ASSET_PURPOSE {\n        LOAN,\n        INVOICE\n    }\n}\n"
    },
    "contracts/libraries/types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nbytes32 constant POOL_ADMIN = keccak256('POOL_CREATOR');\nbytes32 constant OWNER_ROLE = keccak256('OWNER_ROLE');"
    },
    "contracts/libraries/UnpackLoanParamtersLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.10;\n\nlibrary UnpackLoanParamtersLib {\n    struct InterestParams {\n        uint256 principalAmount;\n        uint256 termStartUnixTimestamp;\n        uint256 termEndUnixTimestamp;\n        AmortizationUnitType amortizationUnitType;\n        uint256 termLengthInAmortizationUnits;\n        // interest rates can, at a maximum, have 4 decimal places of precision.\n        uint256 interestRate;\n    }\n\n    enum AmortizationUnitType {\n        MINUTES, // 0 - since 1.0.13\n        HOURS, // 1\n        DAYS, // 2\n        WEEKS, // 3\n        MONTHS, // 4\n        YEARS // 5\n    }\n\n    /**\n     *\n     * Notice: * uint256 (a) reinterprets a as 256-bit unsigned integer. As long as 256 bit = 32 bytes\n     */\n    function _bitShiftRight(bytes32 value, uint256 amount) internal pure returns (uint256) {\n        return uint256(value) / 2**amount;\n    }\n\n    /**\n     * Unpack parameters from packed bytes32 data\n     */\n    function _unpackLoanTermsParametersFromBytes(bytes32 parameters)\n        internal\n        pure\n        returns (\n            uint256 _principalAmount,\n            uint256 _interestRate,\n            uint256 _amortizationUnitType,\n            uint256 _termLengthInAmortizationUnits,\n            uint256 _gracePeriodInDays\n        )\n    {\n        // The subsequent 12 bytes of the parameters encode the PRINCIPAL AMOUNT.\n        bytes32 principalAmountShifted = parameters &\n            0x00ffffffffffffffffffffffff00000000000000000000000000000000000000;\n        // The subsequent 3 bytes of the parameters encode the INTEREST RATE.\n        bytes32 interestRateShifted = parameters & 0x00000000000000000000000000ffffff00000000000000000000000000000000;\n        // The subsequent 4 bits (half byte) encode the AMORTIZATION UNIT TYPE code.\n        bytes32 amortizationUnitTypeShifted = parameters &\n            0x00000000000000000000000000000000f0000000000000000000000000000000;\n        // The subsequent 12 bytes encode the term length, as denominated in\n        // the encoded amortization unit.\n        bytes32 termLengthInAmortizationUnitsShifted = parameters &\n            0x000000000000000000000000000000000ffffffffffffffffffffffff0000000;\n\n        bytes32 gracePeriodInDaysShifted = parameters &\n            0x000000000000000000000000000000000000000000000000000000000ff00000;\n\n        return (\n            _bitShiftRight(principalAmountShifted, 152),\n            _bitShiftRight(interestRateShifted, 128),\n            _bitShiftRight(amortizationUnitTypeShifted, 124),\n            _bitShiftRight(termLengthInAmortizationUnitsShifted, 28),\n            _bitShiftRight(gracePeriodInDaysShifted, 20)\n        );\n    }\n\n    /**\n     * Unpack data from hex string which including informations about Loan\n     */\n    function unpackParametersFromBytes(bytes32 parameters)\n        internal\n        pure\n        returns (\n            uint256 _principalAmount,\n            uint256 _interestRate,\n            uint256 _amortizationUnitType,\n            uint256 _termLengthInAmortizationUnits,\n            uint256 _gracePeriodInDays\n        )\n    {\n        return _unpackLoanTermsParametersFromBytes(parameters);\n    }\n}\n"
    },
    "contracts/libraries/UntangledMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title UntangledMath\n/// @author Untangled Team\nlibrary UntangledMath {\n    uint256 public constant ONE = 10**27;\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    function uncheckedInc(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + 1;\n        }\n    }\n}\n"
    },
    "contracts/protocol/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport {IUniqueIdentity} from \"../uid/IUniqueIdentity.sol\";\n\nabstract contract IGo {\n  uint256 public constant ID_TYPE_0 = 0; // non-US individual\n  uint256 public constant ID_TYPE_1 = 1; // US accredited individual\n  uint256 public constant ID_TYPE_2 = 2; // US non accredited individual\n  uint256 public constant ID_TYPE_3 = 3; // US entity\n  uint256 public constant ID_TYPE_4 = 4; // non-US entity\n  uint256 public constant ID_TYPE_5 = 5;\n  uint256 public constant ID_TYPE_6 = 6;\n  uint256 public constant ID_TYPE_7 = 7;\n  uint256 public constant ID_TYPE_8 = 8;\n  uint256 public constant ID_TYPE_9 = 9;\n  uint256 public constant ID_TYPE_10 = 10;\n\n  /// @notice Returns the address of the UniqueIdentity contract.\n  function uniqueIdentity() external virtual returns (IUniqueIdentity);\n\n  function go(address account) public view virtual returns (bool);\n\n  function goOnlyIdTypes(\n    address account,\n    uint256[] memory onlyIdTypes\n  ) public view virtual returns (bool);\n}\n"
    },
    "contracts/protocol/loan/ILoanInterestTermsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport \"../../libraries/UnpackLoanParamtersLib.sol\";\n\nabstract contract ILoanInterestTermsContract {\n    Registry public registry;\n\n    mapping(bytes32 => bool) public startedLoan;\n\n    mapping(bytes32 => uint256) public repaidPrincipalAmounts;\n    mapping(bytes32 => uint256) public repaidInterestAmounts;\n\n    mapping(bytes32 => bool) public completedRepayment;\n\n    /// @notice register the start of a loan term\n    function registerTermStart(bytes32 agreementId) public virtual returns (bool);\n\n    /// @notice the total amount of principal and interest repaid for a given loan agreement\n    function getValueRepaidToDate(bytes32 agreementId) public view virtual returns (uint256, uint256);\n\n    /// @notice checks whether the repayments for a batch of loan agreements have been completed\n    function isCompletedRepayments(bytes32[] memory agreementIds) public view virtual returns (bool[] memory);\n\n    /**\n     * Expected repayment value with Amortization of Interest and Principal\n     * (AMORTIZATION) - will be used for repayment from Debtor\n     */\n    /// @notice calculates the expected repayment values (principal and interest) for a given loan agreement and timestamp\n    /// @param agreementId loan asset token in bytes32 format\n    /// @param timestamp unix timestamp\n    /// @return expectedPrincipal value of loan at a specific time\n    /// @return expectedInterest interest value at a specific time\n    function getExpectedRepaymentValues(\n        bytes32 agreementId,\n        uint256 timestamp\n    ) public view virtual returns (uint256 expectedPrincipal, uint256 expectedInterest);\n\n    /// @notice calculates the expected repayment values (principal and interest) for a batch of loan agreements and a given timestamp\n    function getMultiExpectedRepaymentValues(\n        bytes32[] memory agreementIds,\n        uint256 timestamp\n    ) public view virtual returns (uint256[] memory, uint256[] memory);\n\n    /// @dev set loan as repaid\n    function registerConcludeLoan(bytes32 agreementId) external virtual returns (bool);\n\n    /// When called, the registerRepayment function records the debtor's\n    ///  repayment, as well as any auxiliary metadata needed by the contract\n    ///  to determine ex post facto the value repaid (e.g. current USD\n    ///  exchange rate)\n    /// @notice register a loan repayment\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    /// @param  payer address. The address of the payer.\n    /// @param  beneficiary address. The address of the payment's beneficiary.\n    /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.\n    /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.\n    function registerRepayment(\n        bytes32 agreementId,\n        address payer,\n        address beneficiary,\n        uint256 unitsOfRepayment,\n        address tokenAddress\n    ) public virtual returns (uint256 remains);\n\n    /// @notice the interest rate for a given loan agreement\n    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.\n    function getInterestRate(bytes32 agreementId) public view virtual returns (uint256);\n\n    function unpackParamsForAgreementID(bytes32 agreementId)\n    public\n    view\n    virtual\n    returns (UnpackLoanParamtersLib.InterestParams memory params);\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/protocol/loan/ILoanKernel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport '../../tokens/ERC721/types.sol';\n\nabstract contract ILoanKernel {\n    Registry public registry;\n\n    /****************** */\n    // CONSTANTS\n    /****************** */\n    enum Errors {\n        // Debt has been already been issued\n        DEBT_ISSUED, // 0\n        // Order has already expired\n        ORDER_EXPIRED, // 1\n        // Debt issuance associated with order has been cancelled\n        ISSUANCE_CANCELLED, // 2\n        // Order has been cancelled\n        ORDER_CANCELLED, // 3\n        // Order parameters specify amount of creditor / debtor fees\n        // that is not equivalent to the amount of underwriter / relayer fees\n        ORDER_INVALID_INSUFFICIENT_OR_EXCESSIVE_FEES, // 4\n        // Order parameters specify insufficient principal amount for\n        // debtor to at least be able to meet his fees\n        ORDER_INVALID_INSUFFICIENT_PRINCIPAL, // 5\n        // Order parameters specify non zero fee for an unspecified recipient\n        ORDER_INVALID_UNSPECIFIED_FEE_RECIPIENT, // 6\n        // Order signatures are mismatched / malformed\n        ORDER_INVALID_NON_CONSENSUAL, // 7\n        // Insufficient balance or allowance for principal token transfer\n        CREDITOR_BALANCE_OR_ALLOWANCE_INSUFFICIENT, // 8\n        // Debt doesn't exists\n        DEBT_NOT_EXISTS, // 9\n        // Debtor it not completed repayment yet\n        NOT_COMPLETED_REPAYMENT // 10\n    }\n\n    enum FillingAddressesIndex {\n        SECURITIZATION_POOL,\n        PRINCIPAL_TOKEN_ADDRESS,\n        REPAYMENT_ROUTER,\n        TERM_CONTRACT,\n        RELAYER\n    }\n\n    enum FillingNumbersIndex {\n        CREDITOR_FEE,\n        ASSET_PURPOSE\n    }\n\n    bytes32 public constant NULL_ISSUANCE_HASH = bytes32(0);\n    bytes16 public constant NULL_COLLATERAL_INFO_HASH = bytes16(0);\n    address public constant NULL_ADDRESS = address(0x0);\n    //********************************************************* */\n\n    //****** */\n    // EVENTS\n    //****** */\n    event LogDebtKernelError(uint8 indexed _errorId, bytes32 indexed _orderHash, string desc);\n\n    event LogFeeTransfer(address indexed payer, address token, uint256 amount, address indexed beneficiary);\n\n    event IssuedNewInputLoans(address[] debtor, uint256[] loanTokenIds);\n\n    event LogDebtOrderFilled(bytes32 _agreementId, uint256 _principal, address _principalToken, address _relayer);\n\n    //********************************************************* */\n\n    /*********** */\n    // STRUCTURES\n    /*********** */\n\n    struct LoanIssuance {\n        address version;\n        address termsContract;\n        address[] debtors;\n        bytes32[] termsContractParameters; // for different loans\n        bytes32[] agreementIds;\n        uint256[] salts;\n    }\n\n    struct LoanOrder {\n        LoanIssuance issuance;\n        address principalTokenAddress;\n        uint256[] principalAmounts;\n        uint256 creditorFee;\n        address relayer;\n        uint256[] expirationTimestampInSecs;\n        bytes32[] debtOrderHashes;\n        uint8[] riskScores;\n        uint8 assetPurpose;\n    }\n\n    struct FillDebtOrderParam {\n        address[] orderAddresses; // 0-pool, 1-principal token address, 2-repayment router, 3-term contract, 4-relayer,...\n        uint256[] orderValues; //  0-creditorFee, 1-asset purpose,..., [x] principalAmounts, [x] expirationTimestampInSecs, [x] - salts, [x] - riskScores\n        bytes32[] termsContractParameters; // Term contract parameters from different farmers, encoded as hash strings\n        LoanAssetInfo[] latInfo;\n    }\n\n    /*********** */\n    // VARIABLES\n    /*********** */\n    mapping(bytes32 => bool) public issuanceCancelled;\n    mapping(bytes32 => bool) public debtOrderCancelled;\n    mapping(bytes32 => bool) public debtOrderCompleted;\n\n    /// @notice conclude a loan by stopping lending/loan terms or allowing the loan loss. It takes the creditor, agreement ID, and term contract as input\n    function concludeLoan(address creditor, bytes32 agreementId, address termContract) public virtual;\n}\n"
    },
    "contracts/protocol/loan/ILoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\n\nabstract contract ILoanRegistry {\n    Registry public registry;\n\n    // loan -> debtors\n    struct LoanEntry {\n        address loanTermContract;\n        address debtor;\n        address principalTokenAddress;\n        bytes32 termsParam; // actually inside this param was already included P token address\n        uint256 salt;\n        uint256 issuanceBlockTimestamp;\n        uint256 lastRepayTimestamp;\n        uint256 expirationTimestamp;\n        uint8 riskScore;\n        Configuration.ASSET_PURPOSE assetPurpose;\n    }\n\n    event UpdateLoanEntry(bytes32 indexed tokenId, LoanEntry entry);\n    event UpdateCompleteLoan(bytes32 indexed tokenId, bool status);\n\n    mapping(bytes32 => LoanEntry) public entries;\n\n    mapping(bytes32 => bool) public manualInterestLoan;\n    mapping(bytes32 => uint256) public manualInterestAmountLoan;\n\n    mapping(bytes32 => bool) public completedLoans;\n\n    function initialize(Registry _registry) public virtual;\n\n    /**\n     * Record new External Loan to blockchain\n     */\n    function insert(\n        bytes32 tokenId,\n        address termContract,\n        address debtor,\n        bytes32 termsContractParameter,\n        address pTokenAddress,\n        uint256 _salt,\n        uint256 expirationTimestampInSecs,\n        uint8[] calldata assetPurposeAndRiskScore\n    ) external virtual returns (bool);\n\n    /// @notice retrieves loan information\n    function getEntry(bytes32 agreementId) public view virtual returns (LoanEntry memory);\n\n    /// @notice retrieves the debtor's address for a given loan\n    function getLoanDebtor(bytes32 tokenId) public view virtual returns (address);\n\n    /// @notice retrieves the term contract parameters for a given loan\n    function getLoanTermParams(bytes32 tokenId) public view virtual returns (bytes32);\n\n    /// @notice retrieves the principal token address for a given loan agreement ID\n    function getPrincipalTokenAddress(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the debtor's address for a given loan agreement ID\n    function getDebtor(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the term contract address for a given loan agreement ID\n    function getTermContract(bytes32 agreementId) public view virtual returns (address);\n\n    /// @notice retrieves the risk score for a given loan agreement ID\n    function getRiskScore(bytes32 agreementId) public view virtual returns (uint8);\n\n    /// @notice retrieves the asset purpose for a given loan agreement ID\n    function getAssetPurpose(bytes32 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n\n    /// @notice retrieves the timestamp of the block at which a debt agreement was issued\n    function getIssuanceBlockTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    /// @notice retrieves the timestamp of the last repayment made for a given loan agreement ID\n    function getLastRepaymentTimestamp(bytes32 agreementId) public view virtual returns (uint256 timestamp);\n\n    /// @notice retrieves the terms contract parameters for a given loan agreement ID\n    function getTermsContractParameters(bytes32 agreementId) public view virtual returns (bytes32);\n\n    /// @notice retrieves the expiration timestamp for a given loan agreement ID\n    function getExpirationTimestamp(bytes32 agreementId) public view virtual returns (uint256);\n\n    /// @notice updates the timestamp of the last repayment made for a given loan agreement ID\n    function updateLastRepaymentTimestamp(bytes32 agreementId, uint256 newTimestamp) public virtual;\n\n    /// @notice retrieves information about the principal payment for a given loan agreement ID\n    /// @dev Get principal payment info before start doing repayment\n    function principalPaymentInfo(\n        bytes32 agreementId\n    ) public view virtual returns (address pTokenAddress, uint256 pAmount);\n\n    /// @notice marks a loan agreement as completed by setting the completedLoans mapping entry to true for a given agreement ID\n    function setCompletedLoan(bytes32 agreementId) public virtual;\n}\n"
    },
    "contracts/protocol/loan/ILoanRepaymentRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {UntangledBase} from '../../base/UntangledBase.sol';\nimport {Registry} from '../../storage/Registry.sol';\n\nabstract contract ILoanRepaymentRouter is UntangledBase {\n    Registry public registry;\n\n    enum Errors {\n        DEBT_AGREEMENT_NONEXISTENT,\n        PAYER_BALANCE_OR_ALLOWANCE_INSUFFICIENT,\n        REPAYMENT_REJECTED_BY_TERMS_CONTRACT\n    }\n\n    event LogOutputSubmit(bytes32 indexed _agreementId, uint256 indexed _tokenIndex, uint256 _totalAmount);\n\n    function initialize(Registry _registry) public virtual;\n\n    event LogRepayment(\n        bytes32 indexed _agreementId,\n        address indexed _payer,\n        address indexed _beneficiary,\n        uint256 _amount,\n        address _token\n    );\n\n    event LogRepayments(bytes32[] _agreementIds, address _payer, uint256[] _amounts);\n\n    event LogError(uint8 indexed _errorId, bytes32 indexed _agreementId);\n\n    /// @notice allows batch repayment of multiple loans by iterating over the given agreement IDs and amounts\n    /// @dev calls _assertRepaymentRequest and _doRepay for each repayment, and emits the LogRepayments event to indicate the successful batch repayment\n    function repayInBatch(\n        bytes32[] calldata agreementIds,\n        uint256[] calldata amounts,\n        address tokenAddress\n    ) external virtual returns (bool);\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/base/LongSaleInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../libraries/UntangledMath.sol';\n\n/// @title LongSaleInterest\n/// @author Untangled Team\n/// @dev Define some constant for interest calculation\ncontract LongSaleInterest {\n    /// @dev represents the number of days in a year\n    uint256 public constant YEAR_LENGTH_IN_DAYS = 365;\n    // All time units in seconds\n    /// @dev represents the number of seconds in a minute\n    uint256 public constant MINUTE_LENGTH_IN_SECONDS = 60;\n    /// @dev represents the number of seconds in an hour\n    uint256 public constant HOUR_LENGTH_IN_SECONDS = MINUTE_LENGTH_IN_SECONDS * 60;\n    /// @dev represents the number of seconds in a day\n    uint256 public constant DAY_LENGTH_IN_SECONDS = HOUR_LENGTH_IN_SECONDS * 24;\n    /// @dev represents the number of seconds in a year\n    uint256 public constant YEAR_LENGTH_IN_SECONDS = DAY_LENGTH_IN_SECONDS * YEAR_LENGTH_IN_DAYS;\n\n    // To convert an encoded interest rate into its equivalent in percents,\n    // divide it by INTEREST_RATE_SCALING_FACTOR_PERCENT -- e.g.\n    //     10,000 => 1% interest rate\n    /// @dev A constant used to convert an encoded interest rate into its equivalent in percentage.\n    /// To convert an encoded interest rate to a percentage, divide it by this scaling factor\n    uint256 public constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10**4;\n    /// @dev represents the scaling factor for the purchase price calculation\n    uint256 public constant PURCHASE_PRICE_SCALING_FACTOR = 10**4;\n\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/Crowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\n\nimport '../../../base/UntangledBase.sol';\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '../../pool/ISecuritizationPool.sol';\nimport {ISecuritizationTGE} from '../../pool/ISecuritizationTGE.sol';\n\nimport {ConfigHelper} from '../../../libraries/ConfigHelper.sol';\nimport '../../../interfaces/INoteToken.sol';\nimport '../../../interfaces/ICrowdSale.sol';\nimport {ISecuritizationPoolStorage} from '../../pool/ISecuritizationPoolStorage.sol';\n\nabstract contract Crowdsale is UntangledBase, ICrowdSale {\n    using ConfigHelper for Registry;\n\n    event UpdateTotalCap(uint256 totalCap);\n    event UpdateMinBidAmount(uint256 minBidAmount);\n\n    Registry public registry;\n\n    // decimal calculating for rate\n    uint256 public constant RATE_SCALING_FACTOR = 10 ** 4;\n\n    /// @dev Pool address which this sale belongs to\n    address public override pool;\n\n    /// @dev The token being sold\n    address public override token;\n\n    /// @dev The token being sold\n    address public currency;\n\n    // How many token units a buyer gets per currency.\n    uint256 public rate; // support by RATE_SCALING_FACTOR decimal numbers\n    bool public hasStarted;\n    uint64 public firstNoteTokenMintedTimestamp; // Timestamp at which the first asset is collected to pool\n\n    /// @dev Amount of currency raised\n    uint256 internal _currencyRaised;\n\n    /// @dev Amount of token raised\n    uint256 public tokenRaised;\n\n    /// @dev Target raised currency amount\n    uint256 public totalCap;\n\n    /// @dev Minimum currency bid amount for note token\n    uint256 public minBidAmount;\n\n    mapping(address => uint256) public _currencyRaisedByInvestor;\n\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    function __Crowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __UntangledBase__init_unchained(_msgSender());\n        registry = _registry;\n        pool = _pool;\n        token = _token;\n        currency = _currency;\n    }\n\n    modifier securitizationPoolRestricted() {\n        require(_msgSender() == pool, 'Crowdsale: Caller must be pool');\n        _;\n    }\n\n    modifier smpRestricted() {\n        require(\n            _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: Caller must be securitization manager'\n        );\n        _;\n    }\n\n    function currencyRaisedByInvestor(address investor) public view returns (uint256) {\n        return _currencyRaisedByInvestor[investor];\n    }\n\n    /// @notice add funding amount to be added to the total cap\n    function addFunding(uint256 additionalCap) public nonReentrant whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: caller must be owner or manager'\n        );\n        require(additionalCap > 0, 'Crowdsale: total cap is 0');\n\n        totalCap = additionalCap + totalCap;\n\n        emit UpdateTotalCap(totalCap);\n    }\n\n    /// @notice Setup minimum bid amount in currency for note token\n    /// @param _minBidAmount Expected minimum amount\n    function setMinBidAmount(uint256 _minBidAmount) external override whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: caller must be owner or manager'\n        );\n        minBidAmount = _minBidAmount;\n        emit UpdateMinBidAmount(_minBidAmount);\n    }\n\n    /// @notice Set hasStarted variable\n    function setHasStarted(bool _hasStarted) public {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'Crowdsale: caller must be owner or manager'\n        );\n        hasStarted = _hasStarted;\n\n        emit SetHasStarted(hasStarted);\n    }\n\n    /// @notice Sets the rate variable to the new rate\n    function _newSaleRound(uint256 newRate) internal {\n        require(!hasStarted, 'Crowdsale: Sale round overflow');\n\n        rate = newRate;\n    }\n\n    /// @notice  Allows users to buy note token\n    /// @param payee pay for purchase\n    /// @param beneficiary wallet receives note token\n    /// @param currencyAmount amount of currency used for purchase\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public virtual whenNotPaused nonReentrant smpRestricted returns (uint256) {\n        require(currencyAmount >= minBidAmount, 'Crowdsale: Less than minBidAmount');\n        uint256 tokenAmount = getTokenAmount(currencyAmount);\n\n        _preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n\n        // update state\n        _currencyRaised += currencyAmount;\n        _currencyRaisedByInvestor[beneficiary] += currencyAmount;\n\n        ISecuritizationTGE securitizationPool = ISecuritizationTGE(pool);\n        require(securitizationPool.isDebtCeilingValid(), 'Crowdsale: Exceeds Debt Ceiling');\n        tokenRaised += tokenAmount;\n\n        _claimPayment(payee, currencyAmount);\n        _processPurchase(beneficiary, tokenAmount);\n        emit TokensPurchased(_msgSender(), beneficiary, currencyAmount, tokenAmount);\n\n        _forwardFunds(ISecuritizationPoolStorage(pool).pot(), currencyAmount);\n\n        return tokenAmount;\n    }\n\n    /// @notice Check if the total amount of currency raised is equal to the total cap\n    function isDistributedFully() public view returns (bool) {\n        return _currencyRaised == totalCap;\n    }\n\n    /// @notice Catch event redeem token\n    /// @param currencyAmount amount of currency investor want to redeem\n    function onRedeem(uint256 currencyAmount) public virtual override {\n        require(\n            _msgSender() == address(registry.getDistributionOperator()),\n            'Crowdsale: Caller must be distribution operator'\n        );\n        _currencyRaised -= currencyAmount;\n    }\n\n    /// @notice Retrieves the remaining token balance held by the crowdsale contract\n    function getTokenRemainAmount() public view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    /// @notice Calculates the remaining amount of currency available for purchase\n    function getCurrencyRemainAmount() public view virtual returns (uint256) {\n        return totalCap - _currencyRaised;\n    }\n\n    /// @notice Determines whether the current sale round is a long sale\n    /// @dev This is an abstract function that needs to be implemented in derived contracts\n    function isLongSale() public view virtual returns (bool);\n\n    /// @notice Calculates the corresponding token amount based on the currency amount and the current rate\n    /// @dev This is an abstract function that needs to be implemented in derived contracts\n    function getTokenAmount(uint256 currencyAmount) public view virtual returns (uint256);\n\n    /// @notice Requires that the currency amount does not exceed the total cap\n    function _defaultPreValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view {\n        require(beneficiary != address(0), 'Crowdsale: beneficiary is zero address');\n        //        require(currencyAmount != 0, \"currency amount is 0\");\n        require(tokenAmount != 0, 'Crowdsale: token amount is 0');\n        require(hasStarted, 'Crowdsale: sale not started');\n        require(isUnderTotalCap(currencyAmount), 'Crowdsale: cap exceeded');\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view virtual {\n        _defaultPreValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n    }\n\n    /// @dev Mints and delivers tokens to the beneficiary\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\n        INoteToken noteToken = INoteToken(token);\n        if (noteToken.noteTokenType() == uint8(Configuration.NOTE_TOKEN_TYPE.SENIOR) && noteToken.totalSupply() == 0) {\n            firstNoteTokenMintedTimestamp = uint64(block.timestamp);\n            ISecuritizationPool(pool).setUpOpeningBlockTimestamp();\n        }\n        noteToken.mint(beneficiary, tokenAmount);\n    }\n\n    /// @dev Burns and delivers tokens to the beneficiary\n    function _ejectTokens(uint256 tokenAmount) internal {\n        INoteToken(token).burn(tokenAmount);\n    }\n\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\n        _deliverTokens(beneficiary, tokenAmount);\n    }\n\n    /// @dev Transfers the currency from the payer to the crowdsale contract\n    function _claimPayment(address payee, uint256 currencyAmount) internal {\n        require(\n            IERC20(currency).transferFrom(payee, address(this), currencyAmount),\n            'Fail to transfer currency from payee to contract'\n        );\n    }\n\n    // function getTokenAmount(uint256 currencyAmount) public view returns (uint256) {\n    //     require(rate > 0, 'Crowdsale: rate is 0');\n    //     uint256 TEN = 10;\n    //     return\n    //         (currencyAmount * rate * TEN**ERC20(token).decimals()) /\n    //         (RATE_SCALING_FACTOR * TEN**ERC20(currency).decimals());\n    // }\n\n    /// @dev Transfers the currency funds from the crowdsale contract to the specified beneficiary\n    function _forwardFunds(address beneficiary, uint256 currencyAmount) internal {\n        require(IERC20(currency).transfer(beneficiary, currencyAmount), 'Fail to transfer currency to Beneficiary');\n    }\n\n    /// @dev Sets the total cap to the specified amount\n    function _setTotalCap(uint256 cap) internal {\n        require(cap > 0, 'Crowdsale: cap is 0');\n        require(cap >= _currencyRaised, 'Crowdsale: cap is bellow currency raised');\n\n        totalCap = cap;\n\n        emit UpdateTotalCap(totalCap);\n    }\n\n    /// @notice Checks if the total amount of currency raised is greater than or equal to the total cap\n    function totalCapReached() public view returns (bool) {\n        return _currencyRaised >= totalCap;\n    }\n\n    /// @notice Checks if the sum of the current currency raised and the specified currency amount is less than or equal to the total cap\n    function isUnderTotalCap(uint256 currencyAmount) public view returns (bool) {\n        return _currencyRaised + currencyAmount <= totalCap;\n    }\n\n    function currencyRaised() public view virtual override returns (uint256) {\n        return _currencyRaised;\n    }\n\n    uint256[40] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/FinalizableCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './IFinalizableCrowdsale.sol';\nimport './TimedCrowdsale.sol';\n\n/// @title FinalizableCrowdsale\n/// @author Untangled Team\n/// @dev An abstract contract define finalize function for sale\nabstract contract FinalizableCrowdsale is IFinalizableCrowdsale, TimedCrowdsale {\n    bool internal _finalized;\n\n    function finalized() public view virtual override returns (bool) {\n        return _finalized;\n    }\n\n    /// @dev Validates that the crowdsale has not already been finalized and that it has either closed or reached the total cap\n    /// @param claimRemainToken claim remaining token or not\n    /// @param remainTokenRecipient Wallet will receive remaining token\n    function finalize(bool claimRemainToken, address remainTokenRecipient) public whenNotPaused {\n        require(_msgSender() == pool, 'FinalizableCrowdsale: Only pool contract can finalize');\n        require(!finalized(), 'FinalizableCrowdsale: already finalized');\n        require(hasClosed() || totalCapReached(), 'FinalizableCrowdsale: not closed');\n        _finalized = true;\n\n        if (!isDistributedFully() && !isLongSale()) {\n            uint256 tokenRemain = 0;\n            tokenRemain = getTokenAmount(getCurrencyRemainAmount());\n\n            if (claimRemainToken) {\n                _processPurchase(remainTokenRecipient, tokenRemain);\n            } else {\n                _ejectTokens(tokenRemain);\n            }\n        }\n\n        _finalization();\n        emit CrowdsaleFinalized();\n    }\n\n    /// @dev This function is meant to be overridden in derived contracts to implement specific finalization logic\n    function _finalization() internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/ICrowdSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ICrowdSale {\n    event SetHasStarted(bool hasStarted);\n\n    function pool() external view returns (address);\n\n    function token() external view returns (address);\n\n    function currencyRaisedByInvestor(address investor) external view returns (uint256);\n\n    function currencyRaised() external view returns (uint256);\n\n    function firstNoteTokenMintedTimestamp() external view returns (uint64);\n\n    function buyTokens(address payee, address beneficiary, uint256 currencyAmount) external returns (uint256);\n\n    function onRedeem(uint256 currencyAmount) external;\n\n    function setHasStarted(bool _hasStarted) external;\n\n    function setMinBidAmount(uint256 _minBidAmount) external;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/IFinalizableCrowdsale.sol": {
      "content": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IFinalizableCrowdsale {\n    event CrowdsaleFinalized();\n\n    function finalized() external view returns (bool);\n\n    function finalize(bool claimRemainToken, address remainTokenRecipient) external;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/IncreasingInterestCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './FinalizableCrowdsale.sol';\nimport '../IInterestRate.sol';\n\n/// @title IncreasingInterestCrowdsale\n/// @author Untangled Team\nabstract contract IncreasingInterestCrowdsale is IInterestRate, FinalizableCrowdsale {\n    using ConfigHelper for Registry;\n\n    event UpdateInterestRange(uint32 initialInterest, uint32 finalInterest, uint32 timeInterval, uint32 amountChangeEachInterval);\n\n    uint32 public initialInterest;\n    uint32 public finalInterest;\n    uint32 public timeInterval;\n    uint32 public amountChangeEachInterval;\n    uint32 public override pickedInterest;\n\n    function setInterestRange(\n        uint32 _initialInterest,\n        uint32 _finalInterest,\n        uint32 _timeInterval,\n        uint32 _amountChangeEachInterval\n    ) public whenNotPaused {\n        require(hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()), \"IncreasingInterestCrowdsale: Caller must be owner or pool\");\n        require(!hasStarted, 'IncreasingInterestCrowdsale: sale already started');\n        require(\n            _initialInterest <= _finalInterest,\n            'IncreasingInterestCrowdsale: initial interest is not less than final interest'\n        );\n        require(_timeInterval > 0, 'IncreasingInterestCrowdsale: time interval is 0');\n\n        initialInterest = _initialInterest;\n        finalInterest = _finalInterest;\n        timeInterval = _timeInterval;\n        amountChangeEachInterval = _amountChangeEachInterval;\n\n        emit UpdateInterestRange(\n            initialInterest,\n            finalInterest,\n            timeInterval,\n            amountChangeEachInterval\n        );\n    }\n\n    function getCurrentInterest() public view returns (uint32) {\n        if (block.timestamp < openingTime) {\n            return 0;\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint256 elapsedTime = block.timestamp - openingTime;\n        // uint256 numberInterval = elapsedTime / timeInterval;\n        // uint32 currentInterest = uint32(amountChangeEachInterval * numberInterval + initialInterest);\n        uint32 currentInterest = uint32((amountChangeEachInterval * elapsedTime) / timeInterval + initialInterest);\n\n        if (currentInterest > finalInterest) {\n            return finalInterest;\n        } else {\n            return currentInterest;\n        }\n    }\n\n    /// @dev Override _finalization function. In Auction note sale, interest of token determined when the auction ends\n    function _finalization() internal override {\n        super._finalization();\n\n        pickedInterest = getCurrentInterest();\n    }\n\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) internal view override {\n        super._preValidatePurchase(beneficiary, currencyAmount, tokenAmount);\n        require(timeInterval > 0, 'IncreasingInterestCrowdsale: time interval not set');\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/crowdsale/TimedCrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './Crowdsale.sol';\n\n/// @title TimedCrowdsale\n/// @author Untangled Team\n/// @dev Note sale that has open time and close time\nabstract contract TimedCrowdsale is Crowdsale {\n    using ConfigHelper for Registry;\n    uint256 public openingTime;\n    uint256 public closingTime;\n\n    bool public isEnableTimeLimit;\n\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\n    event UpdateUsingTimeLimit(bool isEnableTimeLimit);\n    event UpdateSaleRoundTime(uint256 newOpeningTime, uint256 newClosingTime);\n\n    function __TimedCrowdsale__init(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency\n    ) internal onlyInitializing {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        isEnableTimeLimit = true;\n    }\n\n    modifier onlyWhileOpen() {\n        require(isOpen() || isLongSale(), 'TimedCrowdsale: not open');\n        _;\n    }\n\n    function isOpen() public view returns (bool) {\n        if (!isEnableTimeLimit) {\n            return true;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp >= openingTime && block.timestamp <= closingTime;\n    }\n\n    function hasClosed() public view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > closingTime;\n    }\n\n    /// @notice Updates the closing time with the new closing time\n    function extendTime(uint256 newClosingTime) external whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        require(newClosingTime > closingTime, 'TimedCrowdsale: new closing time is before current closing time');\n\n        emit TimedCrowdsaleExtended(closingTime, newClosingTime);\n        closingTime = newClosingTime;\n    }\n\n    /// @notice Updates the opening time and closing time accordingly\n    function newSaleRoundTime(uint256 newOpeningTime, uint256 newClosingTime) public whenNotPaused {\n        require(hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()), \"Crowdsale: Caller must be owner or pool\");\n        require(newClosingTime >= newOpeningTime, 'TimedCrowdsale: opening time is not before closing time');\n        // not accept opening time in the past\n        if (newOpeningTime < block.timestamp) {\n            newOpeningTime = block.timestamp;\n        }\n\n        if (newClosingTime <= newOpeningTime) {\n            newClosingTime = newOpeningTime + 1;\n        }\n\n        openingTime = newOpeningTime;\n        closingTime = newClosingTime;\n\n        emit UpdateSaleRoundTime(newOpeningTime, newClosingTime);\n    }\n\n    /// @dev Sets the isEnableTimeLimit variable to the specified value\n    function setUsingTimeLimit(bool usingTimeLimit) public whenNotPaused nonReentrant onlyRole(OWNER_ROLE) {\n        isEnableTimeLimit = usingTimeLimit;\n        emit UpdateUsingTimeLimit(usingTimeLimit);\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/fab/INoteTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../storage/Registry.sol';\nimport '../../../interfaces/INoteToken.sol';\n\ninterface INoteTokenFactory {\n    event TokenCreated(\n        address indexed token,\n        address indexed poolAddress,\n        Configuration.NOTE_TOKEN_TYPE indexed tokenType,\n        uint8 decimals,\n        string ticker\n    );\n\n    event UpdateNoteTokenImplementation(address indexed newAddress);\n\n    function tokens(uint256 idx) external view returns (INoteToken);\n\n    function isExistingTokens(address tokenAddress) external view returns (bool);\n\n    function changeMinterRole(address token, address newController) external;\n\n    function setNoteTokenImplementation(address newAddress) external;\n\n    function noteTokenImplementation() external view returns (address);\n\n    /// @notice Creates a new NoteToken contract instance with the specified parameters\n    /// Initializes the token with the provided parameters, including the pool address and note token type\n    function createToken(\n        address poolAddress,\n        Configuration.NOTE_TOKEN_TYPE noteTokenType,\n        uint8 _nDecimals,\n        string calldata ticker\n    ) external returns (address);\n}\n"
    },
    "contracts/protocol/note-sale/fab/ITokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../../storage/Registry.sol';\nimport '../../../interfaces/INoteToken.sol';\n\nabstract contract ITokenGenerationEventFactory {\n    enum SaleType {\n        MINTED_INCREASING_INTEREST_SOT,\n        NORMAL_SALE_JOT,\n        NORMAL_SALE_SOT\n    }\n\n    event UpdateTGEImplAddress(SaleType indexed tgeType, address newImpl);\n    event TokenGenerationEventCreated(address indexed tgeInstance);\n\n    Registry public registry;\n    address[] public tgeAddresses;\n    mapping(address => bool) public isExistingTge;\n    mapping(SaleType => address) public TGEImplAddress;\n\n    /// @notice creates a new TGE instance based on the provided parameters and the sale type\n    function createNewSaleInstance(\n        address issuerTokenController,\n        // address pool,\n        address token,\n        address currency,\n        uint8 saleType,\n        bool longSale\n    ) external virtual returns (address);\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/fab/TokenGenerationEventFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {UntangledBase} from '../../../base/UntangledBase.sol';\nimport {ITokenGenerationEventFactory} from './ITokenGenerationEventFactory.sol';\nimport {ConfigHelper} from '../../../libraries/ConfigHelper.sol';\nimport {Factory} from '../../../base/Factory.sol';\nimport {Registry} from '../../../storage/Registry.sol';\nimport {UntangledMath} from '../../../libraries/UntangledMath.sol';\nimport {MintedIncreasingInterestTGE} from '../MintedIncreasingInterestTGE.sol';\nimport {MintedNormalTGE} from '../MintedNormalTGE.sol';\nimport {Registry} from '../../../storage/Registry.sol';\n\ninterface INoteTokenLike {\n    function poolAddress() external view returns (address);\n}\n\ncontract TokenGenerationEventFactory is ITokenGenerationEventFactory, UntangledBase, Factory {\n    using ConfigHelper for Registry;\n\n    bytes4 constant TGE_INIT_FUNC_SELECTOR = bytes4(keccak256('initialize(address,address,address,address,bool)'));\n\n    function __TokenGenerationEventFactory_init(Registry _registry, address _factoryAdmin) internal onlyInitializing {\n        __UntangledBase__init(_msgSender());\n        __Factory__init(_factoryAdmin);\n\n        registry = _registry;\n    }\n\n    function initialize(Registry _registry, address _factoryAdmin) public initializer {\n        __TokenGenerationEventFactory_init(_registry, _factoryAdmin);\n    }\n\n    function initializeV2(Registry _registry, address _factoryAdmin) public reinitializer(2) {\n        __TokenGenerationEventFactory_init(_registry, _factoryAdmin);\n    }\n\n    function setFactoryAdmin(address _factoryAdmin) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setFactoryAdmin(_factoryAdmin);\n    }\n\n    function setTGEImplAddress(SaleType tgeType, address newImpl) public {\n        require(\n            isAdmin() || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\n            'UntangledBase: Must have admin role to perform this action'\n        );\n        require(newImpl != address(0), 'TokenGenerationEventFactory: TGEImplAddress cannot be zero');\n        TGEImplAddress[tgeType] = newImpl;\n        emit UpdateTGEImplAddress(tgeType, newImpl);\n    }\n\n    function createNewSaleInstance(\n        address issuerTokenController,\n        address token,\n        address currency,\n        uint8 saleType,\n        bool longSale\n    ) external override whenNotPaused nonReentrant returns (address) {\n        registry.requireSecuritizationManager(_msgSender());\n\n        address pool = INoteTokenLike(token).poolAddress();\n\n        if (saleType == uint8(SaleType.MINTED_INCREASING_INTEREST_SOT)) {\n            return\n                _newSale(\n                    TGEImplAddress[SaleType.MINTED_INCREASING_INTEREST_SOT],\n                    issuerTokenController,\n                    pool,\n                    token,\n                    currency,\n                    longSale\n                );\n        }\n\n        if (saleType == uint8(SaleType.NORMAL_SALE_JOT)) {\n            return\n                _newSale(\n                    TGEImplAddress[SaleType.NORMAL_SALE_JOT],\n                    issuerTokenController,\n                    pool,\n                    token,\n                    currency,\n                    longSale\n                );\n        }\n\n        if (saleType == uint8(SaleType.NORMAL_SALE_SOT)) {\n            return\n                _newSale(\n                    TGEImplAddress[SaleType.NORMAL_SALE_SOT],\n                    issuerTokenController,\n                    pool,\n                    token,\n                    currency,\n                    longSale\n                );\n        }\n\n        revert('Unknown sale type');\n    }\n\n    function _newSale(\n        address tgeImpl,\n        address issuerTokenController,\n        address pool,\n        address token,\n        address currency,\n        bool longSale\n    ) private returns (address) {\n        bytes memory _initialData = abi.encodeWithSelector(\n            TGE_INIT_FUNC_SELECTOR,\n            registry,\n            pool,\n            token,\n            currency,\n            longSale\n        );\n\n        address tgeAddress = _deployInstance(tgeImpl, _initialData);\n        UntangledBase tge = UntangledBase(tgeAddress);\n\n        tge.grantRole(tge.OWNER_ROLE(), issuerTokenController);\n        tge.renounceRole(tge.OWNER_ROLE(), address(this));\n\n        tgeAddresses.push(tgeAddress);\n        isExistingTge[tgeAddress] = true;\n\n        emit TokenGenerationEventCreated(tgeAddress);\n\n        return tgeAddress;\n    }\n\n    function pauseUnpauseTge(address tgeAdress) external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(isExistingTge[tgeAdress], 'TokenGenerationEventFactory: tge does not exist');\n        MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAdress);\n        if (tge.paused()) {\n            tge.unpause();\n        } else {\n            tge.pause();\n        }\n    }\n\n    function pauseUnpauseAllTges() external whenNotPaused nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 tgeAddressesLength = tgeAddresses.length;\n        for (uint256 i = 0; i < tgeAddressesLength; i = UntangledMath.uncheckedInc(i)) {\n            MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAddresses[i]);\n            if (tge.paused()) {\n                tge.unpause();\n            } else {\n                tge.pause();\n            }\n        }\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/IInterestRate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IInterestRate {\n    function pickedInterest() external view returns (uint32);\n}\n"
    },
    "contracts/protocol/note-sale/IMintedTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport {IInterestRate} from './IInterestRate.sol';\n\ninterface IMintedTGE is IInterestRate {\n    event YieldUpdated(uint256 newYield);\n    event SetupLongSale(uint256 interestRate, uint256 termLengthInSeconds, uint256 timeStartEarningInterest);\n    event UpdateInitialAmount(uint256 initialAmount);\n\n    enum SaleType {\n        MINTED_INCREASING_INTEREST,\n        NORMAL_SALE\n    }\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _isLongSale\n    ) external;\n\n    /// @notice initialize long sale settings\n    function setupLongSale(\n        uint256 interestRate,\n        uint256 termLengthInSeconds,\n        uint256 timeStartEarningInterest\n    ) external;\n\n    ///@notice investor bids for SOT/JOT token. Paid by pool's currency\n    function buyTokens(address payee, address beneficiary, uint256 currencyAmount) external returns (uint256);\n\n    function startNewRoundSale(uint256 openingTime_, uint256 closingTime_, uint256 rate_, uint256 cap_) external;\n\n    function setTotalCap(uint256 cap_) external;\n\n    function getInterest() external view returns (uint256);\n}\n"
    },
    "contracts/protocol/note-sale/MintedIncreasingInterestTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../base/UntangledBase.sol';\nimport './crowdsale/IncreasingInterestCrowdsale.sol';\nimport './IMintedTGE.sol';\nimport './base/LongSaleInterest.sol';\nimport './IInterestRate.sol';\nimport '../../interfaces/INoteToken.sol';\n\n/// @title MintedIncreasingInterestTGE\n/// @author Untangled Team\n/// @dev Note sale for SOT - auction\ncontract MintedIncreasingInterestTGE is IMintedTGE, UntangledBase, IncreasingInterestCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n\n    uint8 saleType;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n        saleType = uint8(SaleType.MINTED_INCREASING_INTEREST);\n    }\n\n    /// @inheritdoc Crowdsale\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    /// @dev Sets the yield variable to the specified value\n    function setYield(uint256 _yield) public whenNotPaused onlyRole(OWNER_ROLE) {\n        yield = _yield;\n        emit YieldUpdated(_yield);\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n\n            emit SetupLongSale(interestRate, termLengthInSeconds, timeStartEarningInterest);\n            emit YieldUpdated(yield);\n        }\n    }\n\n    /// @notice Calculate token price\n    /// @dev This sale is for SOT. So the function return SOT token price\n    function getTokenPrice() public view returns (uint256) {\n        return registry.getDistributionAssessor().calcTokenPrice(pool, token);\n    }\n\n    /// @notice Get amount of token can receive from an amount of currency\n    function getTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return (currencyAmount * 10 ** INoteToken(token).decimals()) / getTokenPrice();\n    }\n\n    function getInterest() public view override returns (uint256) {\n        return getCurrentInterest();\n    }\n\n    /// @notice Setup a new round sale for note token\n    /// @param openingTime_ Define when the sale should start\n    /// @param closingTime_ Define when the sale should end\n    /// @param cap_ Target amount of raised currency\n    function startNewRoundSale(\n        uint256 openingTime_,\n        uint256 closingTime_,\n        uint256 rate_,\n        uint256 cap_\n    ) external override whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedIncreasingInterestTGE: Caller must be owner or manager'\n        );\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate_);\n        newSaleRoundTime(openingTime_, closingTime_);\n        _setTotalCap(cap_);\n    }\n\n    function setTotalCap(uint256 cap_) external whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedIncreasingInterestTGE: Caller must be owner or manager'\n        );\n        _setTotalCap(cap_);\n    }\n\n    /// @dev Validates that the previous sale round is closed and the time interval for increasing interest is greater than zero\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n        require(timeInterval > 0, 'MintedIncreasingInterestTGE: Time interval increasing interest is 0');\n    }\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public override(IMintedTGE, Crowdsale) returns (uint256 tokenAmount) {\n        tokenAmount = Crowdsale.buyTokens(payee, beneficiary, currencyAmount);\n        if (_currencyRaised >= totalCap) {\n            if (!this.finalized()) {\n                this.finalize(false, pool);\n            }\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/note-sale/MintedNormalTGE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {Crowdsale} from './crowdsale/Crowdsale.sol';\nimport {FinalizableCrowdsale} from './crowdsale/FinalizableCrowdsale.sol';\nimport {ISecuritizationPool} from '../pool/ISecuritizationPool.sol';\nimport {IMintedTGE} from './IMintedTGE.sol';\nimport {LongSaleInterest} from './base/LongSaleInterest.sol';\nimport '../../interfaces/INoteToken.sol';\n\n/// @title MintedNormalTGE\n/// @author Untangled Team\n/// @dev Note sale for JOT\ncontract MintedNormalTGE is IMintedTGE, FinalizableCrowdsale, LongSaleInterest {\n    using ConfigHelper for Registry;\n\n    bool public longSale;\n    uint256 public timeStartEarningInterest;\n    uint256 public termLengthInSeconds;\n    uint256 public interestRate;\n    uint256 public yield;\n    uint256 public initialAmount;\n\n    uint32 public pickedInterest;\n    uint8 saleType;\n\n    function initialize(\n        Registry _registry,\n        address _pool,\n        address _token,\n        address _currency,\n        bool _longSale\n    ) public initializer {\n        __Crowdsale__init(_registry, _pool, _token, _currency);\n\n        longSale = _longSale;\n        saleType = uint8(SaleType.NORMAL_SALE);\n    }\n\n    /// @inheritdoc Crowdsale\n    function isLongSale() public view override returns (bool) {\n        return longSale;\n    }\n\n    /// @dev Sets the yield variable to the specified value\n    function setYield(uint256 _yield) public whenNotPaused onlyRole(OWNER_ROLE) {\n        yield = _yield;\n        emit YieldUpdated(_yield);\n    }\n\n    function setupLongSale(\n        uint256 _interestRate,\n        uint256 _termLengthInSeconds,\n        uint256 _timeStartEarningInterest\n    ) public whenNotPaused securitizationPoolRestricted {\n        if (isLongSale()) {\n            interestRate = _interestRate;\n            timeStartEarningInterest = _timeStartEarningInterest;\n            termLengthInSeconds = _termLengthInSeconds;\n            yield = _interestRate;\n            emit SetupLongSale(interestRate, termLengthInSeconds, timeStartEarningInterest);\n            emit YieldUpdated(yield);\n        }\n    }\n\n    function getTokenPrice() public view returns (uint256) {\n        return registry.getDistributionAssessor().calcTokenPrice(pool, token);\n    }\n\n    function getTokenAmount(uint256 currencyAmount) public view override returns (uint256) {\n        return (currencyAmount * 10 ** INoteToken(token).decimals()) / getTokenPrice();\n    }\n\n    function getInterest() public view override returns (uint256) {\n        return interestRate;\n    }\n\n    /// @notice Setup a new round sale for note token\n    /// @param openingTime_ Define when the sale should start\n    /// @param closingTime_ Define when the sale should end\n    /// @param cap_ Target amount of raised currency\n    function startNewRoundSale(\n        uint256 openingTime_,\n        uint256 closingTime_,\n        uint256 rate_,\n        uint256 cap_\n    ) external override whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or manager'\n        );\n        _preValidateNewSaleRound();\n\n        // call inner function for each extension\n        _newSaleRound(rate_);\n        newSaleRoundTime(openingTime_, closingTime_);\n        _setTotalCap(cap_);\n    }\n\n    function setInterestRate(uint256 _interestRate) external whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or manager'\n        );\n        interestRate = _interestRate;\n    }\n    function setTotalCap(uint256 cap_) external whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or manager'\n        );\n        _setTotalCap(cap_);\n    }\n\n    /// @notice Setup initial amount currency raised for JOT condition\n    /// @param _initialAmount Expected minimum amount of JOT before SOT start\n    function setInitialAmount(uint256 _initialAmount) external whenNotPaused {\n        require(\n            hasRole(OWNER_ROLE, _msgSender()) || _msgSender() == address(registry.getSecuritizationManager()),\n            'MintedNormalTGE: Caller must be owner or manager'\n        );\n        require(initialAmount < totalCap, 'MintedNormalTGE: Initial JOT amount must be less than total cap');\n        initialAmount = _initialAmount;\n        emit UpdateInitialAmount(_initialAmount);\n    }\n\n    /// @dev Validates that the previous sale round is closed and the time interval for increasing interest is greater than zero\n    function _preValidateNewSaleRound() internal view {\n        require(hasClosed() || totalCapReached(), 'MintedIncreasingInterestTGE: Previous round not closed');\n    }\n\n    function _finalization() internal override {\n        super._finalization();\n\n        pickedInterest = uint32(interestRate);\n    }\n\n    function buyTokens(\n        address payee,\n        address beneficiary,\n        uint256 currencyAmount\n    ) public override(IMintedTGE, Crowdsale) returns (uint256) {\n        return Crowdsale.buyTokens(payee, beneficiary, currencyAmount);\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/protocol/pool/base/types.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nstruct RiskScore {\n    uint32 daysPastDue;\n    uint32 advanceRate;\n    uint32 penaltyRate;\n    uint32 interestRate;\n    uint32 probabilityOfDefault;\n    uint32 lossGivenDefault;\n    uint32 writeOffAfterGracePeriod;\n    uint32 gracePeriod;\n    uint32 collectionPeriod;\n    uint32 writeOffAfterCollectionPeriod;\n    uint32 discountRate;\n}\n\n\n// uint32 advanceRate;\n//     uint32 penaltyRate;\n//     uint32 interestRate;\n//     uint32 probabilityOfDefault;\n//     uint32 lossGivenDefault;\n//     uint32 writeOffAfterGracePeriod;\n//     uint32 gracePeriod;\n//     uint32 collectionPeriod;\n//     uint32 writeOffAfterCollectionPeriod;\n//     uint32 discountRate;"
    },
    "contracts/protocol/pool/IDistributionAssessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport './ISecuritizationPool.sol';\n\ninterface IDistributionAssessor {\n    struct NoteToken {\n        address poolAddress;\n        address noteTokenAddress;\n        uint256 balance;\n        uint256 apy;\n    }\n\n    /// @notice current individual asset price for the \"SOT\" tranche at the current timestamp\n    function getSOTTokenPrice(address securitizationPool) external view returns (uint256);\n\n    /// @notice calculates the token price for the \"JOT\" tranche at the current timestamp\n    function getJOTTokenPrice(address securitizationPool) external view returns (uint256);\n\n    /// @notice calculates the token price for a specific token address in the securitization pool\n    function calcTokenPrice(address pool, address tokenAddress) external view returns (uint256);\n\n    function getTokenValues(\n        address[] calldata tokenAddresses,\n        address[] calldata investors\n    ) external view returns (uint256[] memory);\n\n    function getTokenPrices(\n        address[] calldata pools,\n        address[] calldata tokenAddresses\n    ) external view returns (uint256[] memory);\n\n    function getExternalTokenInfos(address poolAddress) external view returns (NoteToken[] memory);\n\n    /// @notice the available cash balance in the securitization pool\n    function getCashBalance(address pool) external view returns (uint256);\n\n    /// @notice calculates the corresponding total asset value for a specific token address, investor, and end time\n    function calcCorrespondingTotalAssetValue(address tokenAddress, address investor) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/IDistributionOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IDistributionOperator {}\n"
    },
    "contracts/protocol/pool/IDistributionTranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IDistributionTranche {\n    /// @notice allows the redemption of tokens for a specific redeemer from a specified pool and tokenAddress\n    function redeem(\n        address usr,\n        address pool,\n        address notesToken,\n        uint256 currencyAmount,\n        uint256 tokenAmount\n    ) external;\n\n    /// @notice allows the distribution operator to redeem tokenAmount tokens of a specific noteToken from a given usr\n    function redeemToken(address noteToken, address usr, uint256 tokenAmount) external;\n}\n"
    },
    "contracts/protocol/pool/INoteTokenVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\ninterface INoteTokenVault {\n    event RedeemOrder(\n        address pool,\n        address noteTokenAddress,\n        address usr,\n        uint256 noteTokenRedeemAmount,\n        uint256 noteTokenPrice\n    );\n    event CancelOrder(address pool, address noteTokenAddress, address usr, uint256 noteTokenRedeemAmount);\n    event DisburseOrder(\n        address pool,\n        address noteTokenAddress,\n        address[] toAddresses,\n        uint256[] amounts,\n        uint256[] redeemedAmount\n    );\n    event SetRedeemDisabled(address pool, bool _redeemDisabled);\n\n    /// @title UserOrder\n    /// @dev Represents a user's order containing the amount of SOT and JOT to redeem.\n    struct UserOrder {\n        uint256 redeemSOTAmount;\n        uint256 redeemJOTAmount;\n    }\n\n    struct RedeemOrderParam {\n        address pool;\n        address noteTokenAddress;\n        uint256 noteTokenRedeemAmount;\n    }\n\n    struct CancelOrderParam {\n        address pool;\n        address noteTokenAddress;\n        uint256 maxTimestamp;\n    }\n\n    /// @notice redeemJOTOrder function can be used to place or revoke a redeem\n    function redeemOrder(RedeemOrderParam calldata redeemParam, bytes calldata signature) external;\n\n    /// @dev Disburses funds and handles JOT redemptions for a pool.\n    /// @param pool The address of the pool contract.\n    /// @param toAddresses An array of recipient addresses.\n    /// @param currencyAmounts An array of amounts to disburse to each recipient.\n    /// @param redeemedNoteAmounts An array of JOT amounts redeemed by each recipient.\n    /// @notice Only accessible by BACKEND_ADMIN role.\n    function disburseAll(\n        address pool,\n        address noteTokenAddress,\n        address[] memory toAddresses,\n        uint256[] memory currencyAmounts,\n        uint256[] memory redeemedNoteAmounts\n    ) external;\n\n    function cancelOrder(CancelOrderParam memory cancelParam, bytes calldata signature) external;\n\n    /// @notice Pause redeem request\n    function setRedeemDisabled(address pool, bool _redeemDisabled) external;\n\n    /// @notice Total amount of SOT redeem order\n    function totalSOTRedeem(address pool) external view returns (uint256);\n\n    /// @notice Get redeem disabled\n    function redeemDisabled(address pool) external view returns (bool);\n\n    /// @notice Total amount of JOT redeem order\n    function totalJOTRedeem(address pool) external view returns (uint256);\n\n    /// @dev Retrieves the amount of JOT tokens that can be redeemed for the specified user.\n    /// @param usr The address of the user for which to retrieve the redeemable JOT amount.\n    /// @return The amount of JOT tokens that can be redeemed by the user.\n    function userRedeemJOTOrder(address pool, address usr) external view returns (uint256);\n\n    function userRedeemSOTOrder(address pool, address usr) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/IPoolNAVFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport '../../interfaces/INoteToken.sol';\n\ninterface IPoolNAVFactory {\n    event UpdatePoolNAVImplementation(address indexed newAddress);\n\n    function setPoolNAVImplementation(address newAddress) external;\n\n    function poolNAVImplementation() external view returns (address);\n\n    function createPoolNAV() external returns (address);\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\n\nimport {OWNER_ROLE, ORIGINATOR_ROLE} from './types.sol';\n\ninterface ISecuritizationAccessControl {\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function isOwner(address account) external view returns (bool);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport './ISecuritizationPool.sol';\n\ninterface ISecuritizationManager {\n    event NewTGECreated(address indexed instanceAddress);\n    event NewNotesTokenCreated(address indexed instanceAddress);\n    event NewPoolCreated(address indexed instanceAddress);\n    event UpdatePotToPool(address indexed pot, address indexed pool);\n    event SotDeployed(address indexed sotAddress, address tgeAddress, address poolAddress);\n    event JotDeployed(address indexed jotAddress, address tgeAddress, address poolAddress);\n\n    function registry() external view returns (Registry);\n\n    function isExistingPools(address pool) external view returns (bool);\n\n    function pools(uint256 idx) external view returns (address);\n\n    function potToPool(address pot) external view returns (address);\n\n    function isExistingTGEs(address tge) external view returns (bool);\n\n    /// @dev Register pot to pool instance\n    /// @param pot Pool linked wallet\n    function registerPot(address pot) external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\nimport '../../base/UntangledBase.sol';\nimport '../../libraries/Configuration.sol';\n\nimport {RiskScore} from './base/types.sol';\n\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\ninterface ISecuritizationPool {\n    event CollectAsset(uint256 value);\n    // event UpdateOpeningBlockTimestamp(uint256 newTimestamp);\n    event SecuritizationPoolWithdraw(address originatorAddress, uint256 amount);\n    event AddTokenAssetAddress(address token);\n    event InsertNFTAsset(address token, uint256 tokenId);\n    event RemoveNFTAsset(address token, uint256 tokenId);\n    event UpdateTGEAddress(address tge, address token, Configuration.NOTE_TOKEN_TYPE noteType);\n    event UpdateInterestRateSOT(uint32 _interestRateSOT);\n    event UpdateLockedDistributeBalance(\n        address indexed tokenAddress,\n        address indexed investor,\n        uint256 lockedDistributeBalance,\n        uint256 lockedRedeemBalances,\n        uint256 totalLockedRedeemBalances,\n        uint256 totalLockedDistributeBalance\n    );\n    event UpdateReserve(uint256 currencyAmount);\n    event UpdatePaidPrincipalAmountSOTByInvestor(address indexed user, uint256 currencyAmount);\n\n    /// @notice A view function that returns the length of the NFT (non-fungible token) assets array\n    function getNFTAssetsLength() external view returns (uint256);\n\n    /// @notice A view function that returns an array of token asset addresses\n    function getTokenAssetAddresses() external view returns (address[] memory);\n\n    /// @notice A view function that returns the length of the token asset addresses array\n    function getTokenAssetAddressesLength() external view returns (uint256);\n\n    /// @notice Riks scores length\n    /// @return the length of the risk scores array\n    function getRiskScoresLength() external view returns (uint256);\n\n    function riskScores(uint256 index) external view returns (RiskScore memory);\n\n    /// @notice sets up the risk scores for the contract for pool\n    function setupRiskScores(\n        uint32[] calldata _daysPastDues,\n        uint32[] calldata _ratesAndDefaults,\n        uint32[] calldata _periodsAndWriteOffs\n    ) external;\n\n    /// @notice exports NFT assets to another pool address\n    function exportAssets(address tokenAddress, address toPoolAddress, uint256[] calldata tokenIds) external;\n\n    /// @notice withdraws NFT assets from the contract and transfers them to recipients\n    function withdrawAssets(\n        address[] calldata tokenAddresses,\n        uint256[] calldata tokenIds,\n        address[] calldata recipients\n    ) external;\n\n    /// @notice collects NFT assets from a specified address\n    function collectAssets(uint256[] calldata tokenIds) external returns(uint256);\n\n    /// @notice collects ERC20 assets from specified senders\n    function collectERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata senders,\n        uint256[] calldata amounts\n    ) external;\n\n    /// @notice withdraws ERC20 assets from the contract and transfers them to recipients\\\n    function withdrawERC20Assets(\n        address[] calldata tokenAddresses,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external;\n\n    function nftAssets(uint256 idx) external view returns (ISecuritizationPoolStorage.NFTAsset memory);\n\n    function tokenAssetAddresses(uint256 idx) external view returns (address);\n\n    /// @dev Trigger set up opening block timestamp\n    function setUpOpeningBlockTimestamp() external;\n\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport '../../storage/Registry.sol';\n\nimport {RiskScore} from './base/types.sol';\n\ninterface ISecuritizationPoolStorage {\n    event UpdateOpeningBlockTimestamp(uint256 newTimestamp);\n\n    struct NFTAsset {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    enum CycleState {\n        INITIATED,\n        CROWDSALE,\n        OPEN,\n        CLOSED\n    }\n\n    struct NewPoolParams {\n        address currency;\n        uint32 minFirstLossCushion;\n        bool validatorRequired;\n        uint256 debtCeiling;\n    }\n\n    struct Storage {\n        bool validatorRequired;\n        uint64 firstAssetTimestamp;\n        RiskScore[] riskScores;\n        NFTAsset[] nftAssets;\n        address[] tokenAssetAddresses;\n        mapping(address => bool) existsTokenAssetAddress;\n        // TGE\n        address tgeAddress;\n        address secondTGEAddress;\n        address sotToken;\n        address jotToken;\n        address underlyingCurrency;\n        uint256 reserve; // Money in pool\n        uint32 minFirstLossCushion;\n        uint64 openingBlockTimestamp;\n        uint64 termLengthInSeconds;\n        // by default it is address(this)\n        address pot;\n        // for base (sell-loan) operation\n        uint256 principalAmountSOT;\n        uint256 paidPrincipalAmountSOT;\n        uint32 interestRateSOT; // Annually, support 4 decimals num\n        uint256 totalAssetRepaidCurrency;\n        mapping(address => uint256) paidPrincipalAmountSOTByInvestor;\n        uint256 debtCeiling;\n        CycleState state;\n        // lock distribution\n        mapping(address => mapping(address => uint256)) lockedDistributeBalances;\n        uint256 totalLockedDistributeBalance;\n        mapping(address => mapping(address => uint256)) lockedRedeemBalances;\n        // token address -> total locked\n        mapping(address => uint256) totalLockedRedeemBalances;\n        uint256 totalRedeemedCurrency; // Total $ (cUSD) has been redeemed\n        address poolNAV;\n    }\n\n    function tgeAddress() external view returns (address);\n\n    function secondTGEAddress() external view returns (address);\n\n    function state() external view returns (CycleState);\n\n    /// @notice checks if the contract is in a closed state\n    function isClosedState() external view returns (bool);\n\n    function pot() external view returns (address);\n\n    function poolNAV() external view returns (address);\n\n    function validatorRequired() external view returns (bool);\n\n    function openingBlockTimestamp() external view returns (uint64);\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationPoolValueService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ISecuritizationPoolValueService {\n    /// @notice calculates the total expected value of all assets in the securitization pool at a given timestamp\n    /// @dev iterates over the NFT assets and token assets in the pool, calling getExpectedAssetValue\n    /// or getExpectedERC20AssetValue for each asset and summing up the values\n    function getExpectedAssetsValue(address poolAddress) external view returns (uint256 expectedAssetsValue);\n\n    /// @notice the amount which belongs to the senior investor (SOT) in a pool\n    /// @dev  calculates  the amount which accrues interest for the senior tranche in the securitization pool at a given timestamp\n    function getSeniorAsset(address poolAddress) external view returns (uint256);\n\n    /// @notice calculates  the amount of Junior Debt at the current time\n    function getJuniorAsset(address poolAddress) external view returns (uint256);\n\n    /// @notice returns the rate that belongs to Junior investors at the current time\n    function getJuniorRatio(address poolAddress) external view returns (uint256);\n}\n"
    },
    "contracts/protocol/pool/ISecuritizationTGE.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {Configuration} from '../../libraries/Configuration.sol';\n\ninterface ISecuritizationTGE {\n    // event UpdateOpeningBlockTimestamp(uint256 newTimestamp);\n    event UpdateTGEAddress(address tge, Configuration.NOTE_TOKEN_TYPE noteType);\n    event UpdatePaidPrincipalAmountSOTByInvestor(address indexed user, uint256 currencyAmount);\n    event UpdateReserve(uint256 currencyAmount);\n    event UpdateInterestRateSOT(uint32 _interestRateSOT);\n    event UpdateDebtCeiling(uint256 _debtCeiling);\n    event UpdateMintFirstLoss(uint32 _mintFirstLoss);\n    event Withdraw(address originatorAddress, uint256 amount);\n    event UpdatePoolNAV(address poolNav);\n\n    function termLengthInSeconds() external view returns (uint64);\n\n    /// @notice sets the pot address for the contract\n    function setPot(address _pot) external;\n\n    /// @notice sets debt ceiling value\n    function setDebtCeiling(uint256 _debtCeiling) external;\n\n    /// @notice sets mint first loss value\n    function setMinFirstLossCushion(uint32 _minFirstLossCushion) external;\n\n    // function pot() external view returns (address);\n\n    /// @dev trigger update reserve when buy note token action happens\n    function increaseReserve(uint256 currencyAmount) external;\n\n    /// @dev trigger update reserve\n    function decreaseReserve(uint256 currencyAmount) external;\n\n    // function tgeAddress() external view returns (address);\n\n    // function secondTGEAddress() external view returns (address);\n\n    function sotToken() external view returns (address);\n\n    function jotToken() external view returns (address);\n\n    function underlyingCurrency() external view returns (address);\n\n    function paidPrincipalAmountSOT() external view returns (uint256);\n\n    function paidPrincipalAmountSOTByInvestor(address user) external view returns (uint256);\n\n    function reserve() external view returns (uint256);\n\n    function principalAmountSOT() external view returns (uint256);\n\n    function debtCeiling() external view returns (uint256);\n\n    function interestRateSOT() external view returns (uint32); // Annually, support 4 decimals num\n\n    function minFirstLossCushion() external view returns (uint32);\n\n    function totalAssetRepaidCurrency() external view returns (uint256); // Total $ (cUSD) paid for Asset repayment - repayInBatch\n\n    /// @notice injects the address of the Token Generation Event (TGE) and the associated token address\n    function injectTGEAddress(\n        address _tgeAddress,\n        // address _tokenAddress,\n        Configuration.NOTE_TOKEN_TYPE _noteToken\n    ) external;\n\n    /// @dev trigger update asset value repaid\n    function increaseTotalAssetRepaidCurrency(uint256 amount) external;\n\n    function redeem(address usr, address notesToken, uint256 currencyAmount, uint256 tokenAmount) external;\n\n    /// @dev Disburses a specified amount of currency to the given user.\n    /// @param usr The address of the user to receive the currency.\n    /// @param currencyAmount The amount of currency to disburse.\n    function disburse(address usr, uint256 currencyAmount) external;\n\n    /// @notice checks if the redemption process has finished\n    function hasFinishedRedemption() external view returns (bool);\n\n    ///@notice check current debt ceiling is valid\n    function isDebtCeilingValid() external view returns (bool);\n\n    /// @notice sets the interest rate for the senior tranche of tokens\n    function setInterestRateForSOT(uint32 _interestRateSOT) external;\n\n    function claimCashRemain(address recipientWallet) external;\n\n    // function openingBlockTimestamp() external view returns (uint64);\n\n    function startCycle(\n        uint64 _termLengthInSeconds,\n        uint256 _principalAmountForSOT,\n        uint32 _interestRateForSOT,\n        uint64 _timeStartEarningInterest\n    ) external;\n\n    /// @notice allows the originator to withdraw from reserve\n    function withdraw(address to, uint256 amount) external;\n\n    function setUpPoolNAV() external;\n}\n"
    },
    "contracts/protocol/pool/RegistryInjection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nimport {Registry} from '../../storage/Registry.sol';\n\ncontract RegistryInjection {\n    // keccak256(abi.encode(uint256(keccak256(\"untangled.storage.RegistryInjection\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant RegistryInjectionStorageLocation =\n        0x5f6bd0daaaf246715f06ec0ea7e99af4468b70381a38e1f10cb19776ed17ce00;\n\n    event UpdateRegistry(address registry);\n\n    /// @custom:storage-location erc7201:untangled.storage.RegistryInjection\n    struct RegistryInjectionStorage {\n        Registry registry;\n    }\n\n    function _getRegistryInjection() private pure returns (RegistryInjectionStorage storage $) {\n        assembly {\n            $.slot := RegistryInjectionStorageLocation\n        }\n    }\n\n    function _setRegistry(Registry _registry) internal {\n        RegistryInjectionStorage storage $ = _getRegistryInjection();\n        $.registry = _registry;\n        emit UpdateRegistry(address(_registry));\n    }\n\n    function registry() public view returns (Registry) {\n        return _getRegistryInjection().registry;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationAccessControl.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC165Upgradeable} from '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {RegistryInjection} from './RegistryInjection.sol';\n\nimport {OWNER_ROLE, ORIGINATOR_ROLE} from './types.sol';\n\nimport {ISecuritizationAccessControl} from './ISecuritizationAccessControl.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\nimport {ISecuritizationPoolExtension, SecuritizationPoolExtension} from './SecuritizationPoolExtension.sol';\n\ncontract SecuritizationAccessControl is\n    ERC165Upgradeable,\n    RegistryInjection,\n    ContextUpgradeable,\n    ISecuritizationAccessControl,\n    SecuritizationPoolExtension\n{\n    // keccak256(abi.encode(uint256(keccak256(\"untangled.storage.SecuritizationAccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant SecuritizationAccessControlStorageLocation =\n        0xb38e00afe21f8bf8961a30ad85d453b5f474f19414b8973dee80c89fb0d97b00;\n\n    /// @custom:storage-location erc7201:untangled.storage.SecuritizationAccessControl\n    struct SecuritizationAccessControlStorage {\n        mapping(address => mapping(bytes32 => bool)) roles;\n    }\n\n    function _getSecuritizationAccessControl() private pure returns (SecuritizationAccessControlStorage storage $) {\n        assembly {\n            $.slot := SecuritizationAccessControlStorageLocation\n        }\n    }\n\n    modifier onlyOwner() {\n        address account = _msgSender();\n\n        require(isOwner(account), 'AccessControl: caller is not an owner');\n        _;\n    }\n\n    modifier onlyRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), 'AccessControl: caller is not an originator');\n        _;\n    }\n\n    function installExtension(bytes memory params) public virtual override onlyCallInTargetPool {\n        __SecuritizationAccessControl_init_unchained(_msgSender());\n    }\n\n    function __SecuritizationAccessControl_init_unchained(address _owner) internal {\n        _setRole(OWNER_ROLE, _owner);\n    }\n\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        return $.roles[account][role];\n    }\n\n    function isOwner(address account) public view override returns (bool) {\n        return hasRole(OWNER_ROLE, account);\n    }\n\n    function grantRole(bytes32 role, address account) public virtual override onlyOwner {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = true;\n        emit RoleGranted(role, account, _msgSender());\n    }\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyOwner {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = false;\n        emit RoleRevoked(role, account, _msgSender());\n    }\n\n    function _setRole(bytes32 role, address account) internal virtual {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = true;\n        emit RoleRevoked(role, account, _msgSender());\n    }\n\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        SecuritizationAccessControlStorage storage $ = _getSecuritizationAccessControl();\n        $.roles[account][role] = false;\n        emit RoleRevoked(role, account, _msgSender());\n    }\n\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\n        _revokeRole(role, account);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            super.supportsInterface(interfaceId) ||\n            type(ISecuritizationAccessControl).interfaceId == interfaceId ||\n            type(ISecuritizationPoolExtension).interfaceId == interfaceId;\n    }\n\n    function getFunctionSignatures() public view virtual override returns (bytes4[] memory) {\n        bytes4[] memory _functionSignatures = new bytes4[](6);\n\n        _functionSignatures[0] = this.hasRole.selector;\n        _functionSignatures[1] = this.isOwner.selector;\n        _functionSignatures[2] = this.renounceRole.selector;\n        _functionSignatures[3] = this.grantRole.selector;\n        _functionSignatures[4] = this.revokeRole.selector;\n        _functionSignatures[5] = this.supportsInterface.selector;\n\n        return _functionSignatures;\n    }\n}\n"
    },
    "contracts/protocol/pool/SecuritizationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IAccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol';\n\nimport {UntangledBase} from '../../base/UntangledBase.sol';\n\nimport {IRequiresUID} from '../../interfaces/IRequiresUID.sol';\nimport {INoteToken} from '../../interfaces/INoteToken.sol';\n\nimport {Factory2} from '../../base/Factory2.sol';\nimport {ConfigHelper} from '../../libraries/ConfigHelper.sol';\nimport {INoteTokenFactory} from '../note-sale/fab/INoteTokenFactory.sol';\nimport {ISecuritizationManager} from './ISecuritizationManager.sol';\nimport {ISecuritizationPool} from './ISecuritizationPool.sol';\nimport {ICrowdSale} from '../note-sale/crowdsale/ICrowdSale.sol';\nimport {Registry} from '../../storage/Registry.sol';\nimport {Configuration} from '../../libraries/Configuration.sol';\nimport {POOL_ADMIN} from './types.sol';\nimport {VALIDATOR_ROLE} from '../../tokens/ERC721/types.sol';\nimport {MintedNormalTGE} from '../note-sale/MintedNormalTGE.sol';\nimport {MintedIncreasingInterestTGE} from '../note-sale/MintedIncreasingInterestTGE.sol';\nimport {IMintedTGE} from '../note-sale/IMintedTGE.sol';\nimport {TokenGenerationEventFactory} from '../note-sale/fab/TokenGenerationEventFactory.sol';\nimport {ITokenGenerationEventFactory} from '../note-sale/fab/ITokenGenerationEventFactory.sol';\nimport {ISecuritizationTGE} from './ISecuritizationTGE.sol';\n\nimport {SecuritizationAccessControl} from './SecuritizationAccessControl.sol';\nimport {ISecuritizationPoolStorage} from './ISecuritizationPoolStorage.sol';\n\nabstract contract SecuritizationManagerBase is ISecuritizationManager {\n    Registry public override registry;\n\n    mapping(address => bool) public override isExistingPools;\n    address[] public override pools;\n\n    mapping(address => address) public override potToPool;\n\n    mapping(address => bool) public override isExistingTGEs;\n\n    uint256[44] private __gap;\n}\n\n/// @title SecuritizationManager\n/// @author Untangled Team\n/// @notice You can use this contract for creating new pool, setting up note toke sale, buying note token\ncontract SecuritizationManager is UntangledBase, Factory2, SecuritizationManagerBase, IRequiresUID {\n    using ConfigHelper for Registry;\n\n    event UpdateAllowedUIDTypes(uint256[] uids);\n    //noteSaleAddress, investor, amount, tokenAmount\n    event TokensPurchased(address indexed investor, address indexed tgeAddress, uint256 amount, uint256 tokenAmount);\n    event NoteTokenPurchased(\n        address indexed investor,\n        address indexed tgeAddress,\n        address poolAddress,\n        uint256 amount,\n        uint256 tokenAmount\n    );\n\n    bytes4 public constant POOL_INIT_FUNC_SELECTOR = bytes4(keccak256('initialize(address,bytes)'));\n\n    uint256[] public allowedUIDTypes;\n\n    struct NewRoundSaleParam {\n        uint256 openingTime;\n        uint256 closingTime;\n        uint256 rate;\n        uint256 cap;\n    }\n    struct TGEParam {\n        address issuerTokenController;\n        address pool;\n        uint256 minBidAmount;\n        bool longSale;\n        string ticker;\n        uint8 saleType;\n    }\n\n    struct IncreasingInterestParam {\n        uint32 initialInterest;\n        uint32 finalInterest;\n        uint32 timeInterval;\n        uint32 amountChangeEachInterval;\n    }\n\n    struct TGEInfoParam {\n        address tgeAddress;\n        uint256 totalCap;\n        uint256 minBidAmount;\n    }\n\n    function initialize(Registry _registry, address _factoryAdmin) public initializer {\n        __UntangledBase__init(_msgSender());\n        __Factory__init(_factoryAdmin);\n        _setRoleAdmin(POOL_ADMIN, OWNER_ROLE);\n\n        registry = _registry;\n    }\n\n    modifier onlyPoolExisted(address pool) {\n        require(isExistingPools[pool], 'SecuritizationManager: Pool does not exist');\n        _;\n    }\n\n    modifier onlyManager(address pool) {\n        require(\n            // pool.hasRole(pool.OWNER_ROLE(), _msgSender()) ||\n            hasRole(POOL_ADMIN, _msgSender()),\n            'SecuritizationManager: Not the controller of the project'\n        );\n        _;\n    }\n\n    modifier onlyIssuer(address pool) {\n        require(\n            IAccessControlUpgradeable(pool).hasRole(OWNER_ROLE, _msgSender()),\n            'SecuritizationManager: Not the controller of the project'\n        );\n        _;\n    }\n\n    modifier doesSOTExist(address pool) {\n        require(ISecuritizationTGE(pool).sotToken() == address(0), 'SecuritizationManager: Already exists SOT token');\n        _;\n    }\n\n    modifier doesJOTExist(address pool) {\n        require(ISecuritizationTGE(pool).jotToken() == address(0), 'SecuritizationManager: Already exists JOT token');\n        _;\n    }\n\n    function setFactoryAdmin(address _factoryAdmin) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setFactoryAdmin(_factoryAdmin);\n    }\n\n    function getPoolsLength() public view returns (uint256) {\n        return pools.length;\n    }\n\n    /// @notice Creates a new securitization pool\n    /// @param params params data of the securitization pool\n    /// @dev Creates a new instance of a securitization pool. Set msg sender as owner of the new pool\n    function newPoolInstance(\n        bytes32 salt,\n        address poolOwner,\n        bytes memory params\n    ) external whenNotPaused onlyRole(POOL_ADMIN) returns (address) {\n        // impl from eip1987\n        // _implementation\n        address poolImplAddress = address(registry.getSecuritizationPool());\n\n        bytes memory _initialData = abi.encodeWithSelector(POOL_INIT_FUNC_SELECTOR, registry, params);\n\n        address poolAddress = _deployInstance(poolImplAddress, _initialData, salt);\n        SecuritizationAccessControl poolInstance = SecuritizationAccessControl(poolAddress);\n\n        isExistingPools[poolAddress] = true;\n        pools.push(poolAddress);\n\n        poolInstance.grantRole(OWNER_ROLE, poolOwner);\n        poolInstance.renounceRole(OWNER_ROLE, address(this));\n        ISecuritizationTGE(poolAddress).setUpPoolNAV();\n\n        emit NewPoolCreated(poolAddress);\n\n        return poolAddress;\n    }\n\n    /// @inheritdoc ISecuritizationManager\n    function registerPot(address pot) external override whenNotPaused {\n        require(isExistingPools[_msgSender()], 'SecuritizationManager: Only SecuritizationPool');\n        require(potToPool[pot] == address(0), 'SecuritizationManager: pot used for another pool');\n        potToPool[pot] = _msgSender();\n\n        emit UpdatePotToPool(pot, _msgSender());\n    }\n\n    /// @notice sets up the initial token generation event (TGE) for the junior tranche (SOT) of a securitization pool\n    /// @param issuerTokenController who acts as owner of note sale\n    /// @param pool SecuritizationPool address where this sale belongs to\n    /// @param saleType Contains sale type parameter\n    /// @param longSale Define this sale is long sale. Default true\n    /// @param ticker Prefix for note token symbol name. Ex: Saff_SOT\n    function initialTGEForSOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) public onlyManager(pool) returns (address) {\n        return _initialTGEForSOT(issuerTokenController, pool, saleType, longSale, ticker);\n    }\n\n    function _initialTGEForSOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) internal whenNotPaused nonReentrant onlyPoolExisted(pool) doesSOTExist(pool) returns (address) {\n        INoteTokenFactory noteTokenFactory = registry.getNoteTokenFactory();\n        require(address(noteTokenFactory) != address(0), 'Note Token Factory was not registered');\n        require(address(registry.getTokenGenerationEventFactory()) != address(0), 'TGE Factory was not registered');\n\n        address underlyingCurrency = ISecuritizationTGE(pool).underlyingCurrency();\n        address sotToken = noteTokenFactory.createToken(\n            pool,\n            Configuration.NOTE_TOKEN_TYPE.SENIOR,\n            INoteToken(underlyingCurrency).decimals(),\n            ticker\n        );\n        require(sotToken != address(0), 'SOT token must be created');\n\n        address tgeAddress = registry.getTokenGenerationEventFactory().createNewSaleInstance(\n            issuerTokenController,\n            sotToken,\n            underlyingCurrency,\n            saleType,\n            longSale\n        );\n        noteTokenFactory.changeMinterRole(sotToken, tgeAddress);\n\n        ISecuritizationTGE(pool).injectTGEAddress(tgeAddress, Configuration.NOTE_TOKEN_TYPE.SENIOR);\n\n        isExistingTGEs[tgeAddress] = true;\n\n        emit NewTGECreated(tgeAddress);\n        emit NewNotesTokenCreated(sotToken);\n        emit SotDeployed(sotToken, tgeAddress, address(pool));\n        return tgeAddress;\n    }\n\n    /// @notice Sets up the token generation event (TGE) for the senior tranche (SOT) of a securitization pool with additional configuration parameters\n    /// @param increasingInterestParam Increasing interest parameters\n    /// @param tgeParam TGE parameters\n    /// @param saleParam Some parameters for new round token sale. Ex: openingTime, closeTime, totalCap...\n    function setUpTGEForSOT(\n        TGEParam memory tgeParam,\n        NewRoundSaleParam memory saleParam,\n        IncreasingInterestParam memory increasingInterestParam\n    ) public onlyIssuer(tgeParam.pool) {\n        address tgeAddress = _initialTGEForSOT(\n            tgeParam.issuerTokenController,\n            tgeParam.pool,\n            tgeParam.saleType,\n            tgeParam.longSale,\n            tgeParam.ticker\n        );\n        MintedIncreasingInterestTGE tge = MintedIncreasingInterestTGE(tgeAddress);\n        uint8 saleType = tgeParam.saleType;\n        if (saleType == uint8(ITokenGenerationEventFactory.SaleType.MINTED_INCREASING_INTEREST_SOT)) {\n            tge.setInterestRange(\n                increasingInterestParam.initialInterest,\n                increasingInterestParam.finalInterest,\n                increasingInterestParam.timeInterval,\n                increasingInterestParam.amountChangeEachInterval\n            );\n        } else if (saleType == uint8(ITokenGenerationEventFactory.SaleType.NORMAL_SALE_SOT)) {\n            MintedNormalTGE(tgeAddress).setInterestRate(increasingInterestParam.finalInterest);\n        }\n        tge.startNewRoundSale(saleParam.openingTime, saleParam.closingTime, saleParam.rate, saleParam.cap);\n        tge.setMinBidAmount(tgeParam.minBidAmount);\n    }\n\n    /// @notice sets up the token generation event (TGE) for the junior tranche (JOT) of a securitization pool with additional configuration parameters\n    /// @param tgeParam Parameters for TGE\n    /// @param initialJOTAmount Minimum amount of JOT raised in currency before SOT can start\n    /// @param saleParam Some parameters for new round token sale. Ex: openingTime, closeTime, totalCap...\n    function setUpTGEForJOT(\n        TGEParam memory tgeParam,\n        NewRoundSaleParam memory saleParam,\n        uint256 initialJOTAmount\n    ) public onlyIssuer(tgeParam.pool) {\n        address tgeAddress = _initialTGEForJOT(\n            tgeParam.issuerTokenController,\n            tgeParam.pool,\n            tgeParam.saleType,\n            tgeParam.longSale,\n            tgeParam.ticker\n        );\n        MintedNormalTGE tge = MintedNormalTGE(tgeAddress);\n        tge.startNewRoundSale(saleParam.openingTime, saleParam.closingTime, saleParam.rate, saleParam.cap);\n        tge.setHasStarted(true);\n        tge.setMinBidAmount(tgeParam.minBidAmount);\n        tge.setInitialAmount(initialJOTAmount);\n    }\n\n    function _initialTGEForJOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) public whenNotPaused nonReentrant onlyPoolExisted(pool) doesJOTExist(pool) returns (address) {\n        INoteTokenFactory noteTokenFactory = registry.getNoteTokenFactory();\n        address underlyingCurrency = ISecuritizationTGE(pool).underlyingCurrency();\n        address jotToken = noteTokenFactory.createToken(\n            address(pool),\n            Configuration.NOTE_TOKEN_TYPE.JUNIOR,\n            INoteToken(underlyingCurrency).decimals(),\n            ticker\n        );\n\n        address tgeAddress = registry.getTokenGenerationEventFactory().createNewSaleInstance(\n            issuerTokenController,\n            jotToken,\n            underlyingCurrency,\n            saleType,\n            longSale\n        );\n        noteTokenFactory.changeMinterRole(jotToken, tgeAddress);\n\n        ISecuritizationTGE(pool).injectTGEAddress(tgeAddress, Configuration.NOTE_TOKEN_TYPE.JUNIOR);\n\n        isExistingTGEs[tgeAddress] = true;\n\n        emit NewTGECreated(tgeAddress);\n        emit NewNotesTokenCreated(jotToken);\n        emit JotDeployed(jotToken, tgeAddress, address(pool));\n        return tgeAddress;\n    }\n\n    /// @notice sets up the initial token generation event (TGE) for the junior tranche (JOT) of a securitization pool\n    /// @param issuerTokenController who acts as owner of note sale\n    /// @param pool SecuritizationPool address where this sale belongs to\n    /// @param saleType Contains sale type parameter\n    /// @param longSale Define this sale is long sale. Default true\n    /// @param ticker Prefix for note token symbol name. Ex: Saff_JOT\n    function initialTGEForJOT(\n        address issuerTokenController,\n        address pool,\n        uint8 saleType,\n        bool longSale,\n        string memory ticker\n    ) public onlyManager(pool) returns (address) {\n        return _initialTGEForJOT(issuerTokenController, pool, saleType, longSale, ticker);\n    }\n\n    /// @notice Investor bid for SOT or JOT token\n    /// @param tgeAddress SOT/JOT token sale instance\n    /// @param currencyAmount Currency amount investor will pay\n    function buyTokens(address tgeAddress, uint256 currencyAmount) external whenNotPaused nonReentrant {\n        require(isExistingTGEs[tgeAddress], 'SMP: Note sale does not exist');\n        require(hasAllowedUID(_msgSender()), 'Unauthorized. Must have correct UID');\n\n        ICrowdSale tge = ICrowdSale(tgeAddress);\n        uint256 tokenAmount = tge.buyTokens(_msgSender(), _msgSender(), currencyAmount);\n        address pool = tge.pool();\n        require(registry.getNoteTokenVault().redeemDisabled(pool) == false, 'SM: Buy token paused');\n\n        if (INoteToken(tge.token()).noteTokenType() == uint8(Configuration.NOTE_TOKEN_TYPE.JUNIOR)) {\n            if (MintedNormalTGE(tgeAddress).currencyRaised() >= MintedNormalTGE(tgeAddress).initialAmount()) {\n                // Currency Raised For JOT > initialJOTAmount => SOT sale start\n                address sotTGEAddress = ISecuritizationPoolStorage(pool).tgeAddress();\n                if (sotTGEAddress != address(0)) {\n                    ICrowdSale(sotTGEAddress).setHasStarted(true);\n                }\n            }\n        }\n\n        ISecuritizationTGE(pool).increaseReserve(currencyAmount);\n        address poolOfPot = registry.getSecuritizationManager().potToPool(_msgSender());\n        if (poolOfPot != address(0)) {\n            ISecuritizationTGE(poolOfPot).decreaseReserve(currencyAmount);\n        }\n\n        emit TokensPurchased(_msgSender(), tgeAddress, currencyAmount, tokenAmount);\n        emit NoteTokenPurchased(_msgSender(), tgeAddress, address(pool), currencyAmount, tokenAmount);\n    }\n\n    function setAllowedUIDTypes(uint256[] calldata ids) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        allowedUIDTypes = ids;\n        emit UpdateAllowedUIDTypes(ids);\n    }\n\n    /// @notice Check if an user has valid UID type\n    function hasAllowedUID(address sender) public view override returns (bool) {\n        return registry.getGo().goOnlyIdTypes(sender, allowedUIDTypes);\n    }\n\n    function updateTgeInfo(TGEInfoParam[] calldata tgeInfos) public {\n        for (uint i = 0; i < tgeInfos.length; i++) {\n            require(\n                IAccessControlUpgradeable(ICrowdSale(tgeInfos[i].tgeAddress).pool()).hasRole(OWNER_ROLE, _msgSender()),\n                'SecuritizationManager: Not the controller of the project'\n            );\n            IMintedTGE(tgeInfos[i].tgeAddress).setTotalCap(tgeInfos[i].totalCap);\n            ICrowdSale(tgeInfos[i].tgeAddress).setMinBidAmount(tgeInfos[i].minBidAmount);\n        }\n    }\n\n    function registerValidator(address validator) public onlyRole(POOL_ADMIN) {\n        require(validator != address(0), 'SecuritizationManager: Invalid validator address');\n        IAccessControlUpgradeable(address(registry.getLoanAssetToken())).grantRole(VALIDATOR_ROLE, validator);\n    }\n\n    function unregisterValidator(address validator) public onlyRole(POOL_ADMIN) {\n        IAccessControlUpgradeable(address(registry.getLoanAssetToken())).revokeRole(VALIDATOR_ROLE, validator);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/pool/SecuritizationPoolExtension.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\ninterface ISecuritizationPoolLike {\n    function original() external view returns (address);\n}\n\n/**\n * @title Untangled's SecuritizationPool contract\n * @notice Main entry point for senior LPs (a.k.a. capital providers)\n *  Automatically invests across borrower pools using an adjustable strategy.\n * @author Untangled Team\n */\ninterface ISecuritizationPoolExtension {\n    function installExtension(bytes memory params) external;\n\n    function getFunctionSignatures() external view returns (bytes4[] memory);\n}\n\nabstract contract SecuritizationPoolExtension is ISecuritizationPoolExtension {\n    modifier onlyCallInTargetPool() {\n        ISecuritizationPoolLike current = ISecuritizationPoolLike(address(this));\n        // current contract is not poolImpl, => delegate call\n        require(current.original() != address(this), 'Only call in target pool');\n        _;\n    }\n}\n"
    },
    "contracts/protocol/pool/types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nbytes32 constant OWNER_ROLE = keccak256('OWNER_ROLE');\nbytes32 constant POOL_ADMIN = keccak256('POOL_CREATOR');\nbytes32 constant ORIGINATOR_ROLE = keccak256('ORIGINATOR_ROLE');\n\nbytes32 constant BACKEND_ADMIN = keccak256('BACKEND_ADMIN');\nbytes32 constant SIGNER_ROLE = keccak256('SIGNER_ROLE');\n\n// In PoolNAV we use this\nbytes32 constant POOL = keccak256('POOL');\n\nuint256 constant RATE_SCALING_FACTOR = 10 ** 4;\n"
    },
    "contracts/storage/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {UntangledBase} from '../base/UntangledBase.sol';\nimport {Configuration} from '../libraries/Configuration.sol';\n\n/**\n * @title Registry\n * @notice This contract stores mappings of useful \"protocol config state\", giving a central place\n *  for all other contracts to access it. These config vars\n *  are enumerated in the `Configuration` library, and can only be changed by admins of the protocol.\n * @author Untangled Team\n */\ncontract Registry is UntangledBase {\n    mapping(uint8 => address) public contractAddresses;\n\n    event AddressUpdated(address owner, uint8 index, address oldValue, address newValue);\n\n    function initialize() public initializer {\n        __UntangledBase__init(_msgSender());\n    }\n\n    function _setAddress(uint8 addressIndex, address newAddress) private {\n        emit AddressUpdated(_msgSender(), addressIndex, contractAddresses[addressIndex], newAddress);\n        contractAddresses[addressIndex] = newAddress;\n    }\n\n    function getAddress(uint8 index) public view returns (address) {\n        return contractAddresses[index];\n    }\n\n    function setSecuritizationManager(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_MANAGER), newAddress);\n    }\n\n    function setSecuritizationPool(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL), newAddress);\n    }\n\n    function setNoteTokenFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN_FACTORY), newAddress);\n    }\n\n    // function setNoteToken(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN), newAddress);\n    // }\n\n    function setTokenGenerationEventFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.TOKEN_GENERATION_EVENT_FACTORY), newAddress);\n    }\n\n    // function setMintedIncreasingInterestTGE(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_INCREASING_INTEREST_TGE), newAddress);\n    // }\n\n    // function setMintedNormalTGE(address newAddress) public onlyAdmin whenNotPaused {\n    //     _setAddress(uint8(Configuration.CONTRACT_TYPE.MINTED_NORMAL_TGE), newAddress);\n    // }\n\n    function setDistributionOperator(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_OPERATOR), newAddress);\n    }\n\n    function setDistributionAssessor(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_ASSESSOR), newAddress);\n    }\n\n    function setLoanAssetToken(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_ASSET_TOKEN), newAddress);\n    }\n\n    function setDistributionTranche(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.DISTRIBUTION_TRANCHE), newAddress);\n    }\n\n    function setSecuritizationPoolValueService(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.SECURITIZATION_POOL_VALUE_SERVICE), newAddress);\n    }\n\n    function setLoanRegistry(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REGISTRY), newAddress);\n    }\n\n    function setLoanInterestTermsContract(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_INTEREST_TERMS_CONTRACT), newAddress);\n    }\n\n    function setLoanRepaymentRouter(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_REPAYMENT_ROUTER), newAddress);\n    }\n\n    function setLoanKernel(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.LOAN_KERNEL), newAddress);\n    }\n\n    function setGo(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.GO), newAddress);\n    }\n\n    function setPoolNAVFactory(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.POOL_NAV_FACTORY), newAddress);\n    }\n\n    function setNoteTokenVault(address newAddress) public onlyAdmin whenNotPaused {\n        _setAddress(uint8(Configuration.CONTRACT_TYPE.NOTE_TOKEN_VAULT), newAddress);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/ERC20/INoteToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {IERC20MetadataUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol';\nimport {IPauseable} from '../../base/IPauseable.sol';\n\ninterface INoteToken is IERC20Upgradeable, IERC20MetadataUpgradeable, IPauseable {\n    // address public poolAddress;\n    // uint8 public noteTokenType;\n\n    // uint8 internal immutable _d;\n    function poolAddress() external view returns (address);\n\n    function noteTokenType() external view returns (uint8);\n\n    function mint(address receiver, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n}\n"
    },
    "contracts/tokens/ERC721/ILoanAssetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../../interfaces/IUntangledERC721.sol';\nimport './types.sol';\n\nabstract contract ILoanAssetToken is IUntangledERC721 {\n  \n  function safeMint(address creditor, LoanAssetInfo calldata latInfo) external virtual;\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/IUntangledERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol';\nimport '../../storage/Registry.sol';\n\nabstract contract IUntangledERC721 is ERC721PresetMinterPauserAutoIdUpgradeable {\n    Registry public registry;\n\n    function __UntangledERC721__init(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __UntangledERC721__init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function __UntangledERC721__init_unchained(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) internal onlyInitializing {\n        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n    }\n\n    function mint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _safeMint(to, tokenId);\n    }\n\n    /// @notice calculates the total expected repayment value (principal + interest) for a loan asset token at a given timestamp\n    function getTotalExpectedRepaymentValue(\n        uint256 agreementId,\n        uint256 timestamp\n    ) external view virtual returns (uint256);\n\n    /// @notice the expected principal and interest for an asset\n    function getExpectedRepaymentValues(\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view virtual returns (uint256 expectedPrincipal, uint256 expectedInterest);\n\n    /// @notice the expiration timestamp of an invoice/loan token\n    function getExpirationTimestamp(uint256 agreementId) external view virtual returns (uint256);\n\n    /// @notice  the interest rate associated with an token\n    function getInterestRate(uint256 agreementId) external view virtual returns (uint256);\n\n    /// @notice the risk score associated with a token\n    function getRiskScore(uint256 agreementId) external view virtual returns (uint8);\n\n    /// @notice retrieves the asset purpose for a given loan agreement ID\n    function getAssetPurpose(uint256 agreementId) public view virtual returns (Configuration.ASSET_PURPOSE);\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/ERC721/types.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nstruct LoanAssetInfo {\n    uint256[] tokenIds;\n    uint256[] nonces;\n    address validator;\n    bytes validateSignature;\n}\n\nbytes32 constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\nbytes32 constant VALIDATOR_ADMIN_ROLE = keccak256(\"VALIDATOR_ADMIN_ROLE\");"
    },
    "contracts/uid/IRequiresUID.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IRequiresUID {\n  function hasAllowedUID(address sender) external view returns (bool);\n}\n"
    },
    "contracts/uid/IUniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface IUniqueIdentity is IERC1155Upgradeable {\n    /// @notice Mint a new UniqueIdentity token to the msgSender\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding mint params:\n    ///                  account, id, expiresAt, address(this), nonces[account], block.chainid\n    ///                  from an address with the SIGNER_ROLE.\n    function mint(uint256 id, uint256 expiresAt, bytes calldata signature) external payable;\n\n    /// @notice Mint a new UniqueIdentity token to the `recipient`\n    /// @param recipient The recipient address to be minted to.\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding mintTo params:\n    ///                  (account, recipient, id, expiresAt, address(this), nonces[account], block.chainid)\n    ///                  from an address with the SIGNER_ROLE.\n    function mintTo(\n        address recipient,\n        uint256 id,\n        uint256 expiresAt,\n        bytes calldata signature\n    ) external payable;\n\n    /// @notice Burn a UniqueIdentity token of `id` from the `account`\n    /// @param account The account which currently owns the UID\n    /// @param id The id representing the KYC type of the UniqueIdentity\n    /// @param expiresAt The expiration time of the signature\n    /// @param signature An EIP-191 signature of the corresponding burn params:\n    ///                  (account, id, expiresAt, address(this), nonces[account], block.chainid)\n    ///                  from an address with the SIGNER_ROLE.\n    function burn(address account, uint256 id, uint256 expiresAt, bytes calldata signature) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}